<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <title>Specification for JEP 325: Switch Expressions</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  body { font-family:sans-serif; margin-left:2em; margin-right:2em; font-size:90%; line-height:1.3; }
  h1 { font-size:140%; margin-bottom:0em; }
  h2 { font-size:120%; margin-top:2em; }
  h3 { font-size:100%; }
  h2.author:empty { display:none; }
  h3.date { font-style:italic; font-weight:normal; margin-top:0em; }
  .inserted, strong, ins { background-color:#d0ffd0; font-weight:inherit; border-bottom:1px dotted #a0a0a0; }
  .deleted, del { background-color:#ffe0e0; text-decoration:line-through; }
  code { font-size:120%; }
  a[href^="http"]::after { content:"\202F⇗"; }
  #TOC { line-height:1.6; }
  div.editorial { margin-left:1em; padding:0em .3em; font-style:italic; background-color:#e8e8e8; border:1px dotted #a0a0a0; }
  div.legal { font-size:smaller; font-style:italic; }
  \</style>
<script>window.ohcglobal || document.write('<script src="https://docs.oracle.com/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<header id="title-block-header">
<h1 class="title">Specification for JEP 325: Switch Expressions</h1>
<p class="author"></p>
<p class="date">June 2018, Edited: Jan 2019</p>
</header>
<div class="legal">
<p>Copyright © 2018 Oracle America, Inc. <a href="switch-expressions.html#jep325-legal">Legal Notice</a>.</p>
</div>
<p>This document proposes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se12/html">Java Language Specification</a> to support extensions to the <code>switch</code> statement so that it can be used as either a statement or an expression, along with associated changes to the <code>break</code> statement. See <a href="http://openjdk.java.net/jeps/325">JEP 325</a> for an overview.</p>
<p>To assist reading, this document contains complete replacements for sections <a href="switch-expressions.html#jep325-5.6">5.6</a>, <a href="switch-expressions.html#jep325-11.2.1">11.2.1</a>, <a href="switch-expressions.html#jep325-11.2.2">11.2.2</a>, <a href="switch-expressions.html#jep325-14.1">14.1</a>, <a href="switch-expressions.html#jep325-14.11">14.11</a>, <a href="switch-expressions.html#jep325-14.15">14.15</a>, <a href="switch-expressions.html#jep325-14.16">14.16</a>, <a href="switch-expressions.html#jep325-14.17">14.17</a>, <a href="switch-expressions.html#jep325-14.21">14.21</a>, <a href="switch-expressions.html#jep325-15.1">15.1</a>, <a href="switch-expressions.html#jep325-15.2">15.2</a>, <a href="switch-expressions.html#jep325-15.6">15.6</a>, <a href="switch-expressions.html#jep325-15.12.2.1">15.12.2.1</a>, <a href="switch-expressions.html#jep325-15.12.2.5">15.12.2.5</a>, <a href="switch-expressions.html#jep325-15.15">15.15</a>, <a href="switch-expressions.html#jep325-15.25">15.25</a>, <a href="switch-expressions.html#jep325-16.2.9">16.2.9</a>, <a href="switch-expressions.html#jep325-16.2.13">16.2.13</a>, <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>, and <a href="switch-expressions.html#jep325-18.5.4">18.5.4</a> along with entirely new sections <a href="switch-expressions.html#jep325-5.6.3">5.6.3</a>, <a href="switch-expressions.html#jep325-16.1.7">16.1.7</a>, and <a href="switch-expressions.html#jep325-16.1.8">16.1.8</a>. It is proposed to introduce a new section on switch expressions as <a href="switch-expressions.html#jep325-15.28">15.28</a> and renumber (and update) the current section on constant expressions as <a href="switch-expressions.html#jep325-15.29">15.29</a>. In the replacement sections, new text is highlighted like <strong>this</strong> and deleted text is highlighted like <del>this</del>.</p>
<!---------------------- Chapter 5 -------------------------------->
<h2 id="jep325-5.6">5.6. Numeric Contexts</h2>
<p><em>Numeric contexts</em> apply to the operands of an arithmetic operator<strong>, or the result expressions of a <code>switch</code> expression</strong>.</p>
<p>Numeric contexts allow the use of:</p>
<ul>
<li><p>an identity conversion (<a href="../../se10/html/jls-5.html#jls-5.1.1">5.1.1</a>)</p></li>
<li><p>a widening primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.2">5.1.2</a>)</p></li>
<li><p>an unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>) optionally followed by a widening primitive conversion</p></li>
</ul>
<p>A <em>numeric promotion</em> is a process by which, given <strong>either</strong> an arithmetic operator and its argument expressions, <strong>or a <code>switch</code> expression and its result expressions,</strong> the <del>arguments</del> <strong>subexpressions</strong> are converted to an inferred target type <em>T</em>. <em>T</em> is chosen during promotion such that each <del>argument expression</del> <strong>subexpression</strong> can be converted to <em>T</em> and<strong>, in the case of an</strong> <del>the</del> arithmetic operation<strong>, it</strong> is defined for values of type <em>T</em>.</p>
<p>The <del>two</del> <strong>three</strong> kinds of numeric promotion are unary numeric promotion (<a href="switch-expressions.html#jep325-5.6.1">5.6.1</a>)<strong>,</strong> <del>and</del> binary numeric promotion (<a href="switch-expressions.html#jep325-5.6.2">5.6.2</a>)<strong>, and switch numeric promotion (<a href="switch-expressions.html#jep325-5.6.3">5.6.3</a>)</strong>.</p>
<h3 id="unary-numeric-promotion">5.6.1. Unary Numeric Promotion</h3>
<p>Some operators apply <em>unary numeric promotion</em> to a single operand, which must produce a value of a numeric type:</p>
<ul>
<li><p>If the operand is of compile-time type <code>Byte</code>, <code>Short</code>, <code>Character</code>, or <code>Integer</code>, it is subjected to unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>). The result is then promoted to a value of type <code>int</code> by a widening primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.2">5.1.2</a>) or an identity conversion (<a href="../../se10/html/jls-5.html#jls-5.1.1">5.1.1</a>).</p></li>
<li><p>Otherwise, if the operand is of compile-time type <code>Long</code>, <code>Float</code>, or <code>Double</code>, it is subjected to unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p></li>
<li><p>Otherwise, if the operand is of compile-time type <code>byte</code>, <code>short</code>, or <code>char</code>, it is promoted to a value of type <code>int</code> by a widening primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.2">5.1.2</a>).</p></li>
<li><p>Otherwise, a unary numeric operand remains as is and is not converted.</p></li>
</ul>
<p>After the conversion(s), if any, value set conversion (<a href="../../se10/html/jls-5.html#jls-5.1.13">5.1.13</a>) is then applied.</p>
<p>Unary numeric promotion is performed on expressions in the following situations:</p>
<ul>
<li><p>Each dimension expression in an array creation expression (<a href="../../se10/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>The index expression in an array access expression (<a href="../../se10/html/jls-15.html#jls-15.10.3">15.10.3</a>)</p></li>
<li><p>The operand of a unary plus operator <code>+</code> (<a href="../../se10/html/jls-15.html#jls-15.15.3">15.15.3</a>)</p></li>
<li><p>The operand of a unary minus operator <code>-</code> (<a href="../../se10/html/jls-15.html#jls-15.15.4">15.15.4</a>)</p></li>
<li><p>The operand of a bitwise complement operator <code>~</code> (<a href="../../se10/html/jls-15.html#jls-15.15.5">15.15.5</a>)</p></li>
<li><p>Each operand, separately, of a shift operator <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, or <code>&gt;&gt;&gt;</code> (<a href="../../se10/html/jls-15.html#jls-15.19">15.19</a>).</p>
<p>A <code>long</code> shift distance (right operand) does not promote the value being shifted (left operand) to <code>long</code>.</p></li>
</ul>
<div class="editorial">
<p><em>Example 5.6.1-1. Unary Numeric Promotion</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">        <span class="dt">byte</span> b = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">        <span class="dt">int</span> a[] = <span class="kw">new</span> <span class="dt">int</span>[b];  <span class="co">// dimension expression promotion</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        <span class="dt">char</span> c = <span class="ch">&#39;\u0001&#39;</span>;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        a[c] = <span class="dv">1</span>;              <span class="co">// index expression promotion</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        a[<span class="dv">0</span>] = -c;             <span class="co">// unary - promotion</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;a: &quot;</span> + a[<span class="dv">0</span>] + <span class="st">&quot;,&quot;</span> + a[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">        b = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="dt">int</span> i = ~b;            <span class="co">// bitwise complement promotion</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;~0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(b)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">                           + <span class="st">&quot;==0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(i));</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">        i = b &lt;&lt; 4L;           <span class="co">// shift promotion (left operand)</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(b)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">                           + <span class="st">&quot;&lt;&lt;4L==0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(i));</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">}</a></code></pre></div>
<p>This program produces the output:</p>
<pre><code>a: -1,1
~0xffffffff==0x0
0xffffffff&lt;&lt;4L==0xfffffff0</code></pre>
</div>
<h3 id="binary-numeric-promotion">5.6.2. Binary Numeric Promotion</h3>
<p>When an operator applies <em>binary numeric promotion</em> to a pair of operands, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:</p>
<ol type="1">
<li><p>If any operand is of a reference type, it is subjected to unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p></li>
<li><p>Widening primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.2">5.1.2</a>) is applied to convert either or both operands as specified by the following rules:</p>
<ul>
<li><p>If either operand is of type <code>double</code>, the other is converted to <code>double</code>.</p></li>
<li><p>Otherwise, if either operand is of type <code>float</code>, the other is converted to <code>float</code>.</p></li>
<li><p>Otherwise, if either operand is of type <code>long</code>, the other is converted to <code>long</code>.</p></li>
<li><p>Otherwise, both operands are converted to type <code>int</code>.</p></li>
</ul></li>
</ol>
<p>After the conversion(s), if any, value set conversion (<a href="../../se10/html/jls-5.html#jls-5.1.13">5.1.13</a>) is then applied to each operand.</p>
<p>Binary numeric promotion is performed on the operands of certain operators:</p>
<ul>
<li><p>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> (<a href="../../se10/html/jls-15.html#jls-15.17">15.17</a>)</p></li>
<li><p>The addition and subtraction operators for numeric types <code>+</code> and <code>-</code> (<a href="../../se10/html/jls-15.html#jls-15.18.2">15.18.2</a>)</p></li>
<li><p>The numerical comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (<a href="../../se10/html/jls-15.html#jls-15.20.1">15.20.1</a>)</p></li>
<li><p>The numerical equality operators <code>==</code> and <code>!=</code> (<a href="../../se10/html/jls-15.html#jls-15.21.1">15.21.1</a>)</p></li>
<li><p>The integer bitwise operators <code>&amp;</code>, <code>^</code>, and <code>|</code> (<a href="../../se10/html/jls-15.html#jls-15.22.1">15.22.1</a>)</p></li>
<li><p>In certain cases, the conditional operator <code>? :</code> (<a href="switch-expressions.html#jep325-15.25">15.25</a>)</p></li>
</ul>
<div class="editorial">
<p><em>Example 5.6.2-1. Binary Numeric Promotion</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="dt">int</span> i    = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="dt">float</span> f  = <span class="fl">1.0f</span>;</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="dt">double</span> d = <span class="fl">2.0</span>;</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        <span class="co">// First int*float is promoted to float*float, then</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        <span class="co">// float==double is promoted to double==double:</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        <span class="kw">if</span> (i * f == d) <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;oops&quot;</span>);</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        </a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        <span class="co">// A char&amp;byte is promoted to int&amp;int:</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">        <span class="dt">byte</span> b = <span class="bn">0x1f</span>;</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">        <span class="dt">char</span> c = <span class="ch">&#39;G&#39;</span>;</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        <span class="dt">int</span> control = c &amp; b;</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="bu">Integer</span>.<span class="fu">toHexString</span>(control));</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">        </a>
<a class="sourceLine" id="cb3-16" data-line-number="16">        <span class="co">// Here int:float is promoted to float:float:</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">        f = (b==<span class="dv">0</span>) ? i : <span class="fl">4.0f</span>;</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="fl">1.0</span>/f);</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">}</a></code></pre></div>
<p>This program produces the output:</p>
<pre><code>7
0.25</code></pre>
<p>The example converts the ASCII character <code>G</code> to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The <code>7</code> is the numeric value of this control character.</p>
</div>
<h3 id="jep325-5.6.3"><strong>5.6.3 Switch Numeric Promotion</strong></h3>
<p><strong>When a switch expression applies numeric promotion to a set of result expressions, each of which must denote a value that is convertible to a numeric type, the following rules apply, in order:</strong></p>
<ul>
<li><p><strong>If any result expression is of a reference type, it is subjected to unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>).</strong></p></li>
<li><strong>Widening primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.2">5.1.2</a>) and narrowing primitive conversion (<a href="../../se10/html/jls-5.html#jls-5.1.3">5.1.3</a>) are applied to some result expressions as specified by the following rules:</strong>
<ul>
<li><strong>If any result expression is of type <code>double</code>, then other result expressions that are not of type <code>double</code> are widened to <code>double</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>float</code>, then other result expressions that are not of type <code>float</code> are widened to <code>float</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>long</code>, then other result expressions that are not of type <code>long</code> are widened to <code>long</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>int</code> and is not a constant expression, the other result expressions that are not of type <code>int</code> are widened to <code>int</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>char</code>, and every other result expression is either of type <code>char</code>, or a constant expression of type <code>int</code> with a value that is representable in the type <code>char</code>, then the <code>int</code> results are narrowed to <code>char</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>short</code>, and every other result expression is either of type <code>short</code>, or of type <code>byte</code>, or a constant expression of type <code>int</code> with a value that is representable in the type <code>short</code>, then the <code>byte</code> results are widened to <code>short</code> and the <code>int</code> results are narrowed to <code>short</code>.</strong></li>
<li><strong>Otherwise, if any result expression is of type <code>byte</code>, and every other result expression is either of type <code>byte</code> or a constant expression of type <code>int</code> with a value that is representable in the type <code>byte</code>, then the <code>int</code> results are narrowed to <code>byte</code>.</strong></li>
<li><strong>Otherwise, all the result expressions that are not of type <code>int</code> are widened to <code>int</code>.</strong></li>
</ul></li>
</ul>
<p><strong>After the conversion(s), if any, value set conversion (<a href="../../se10/html/jls-5.html#jls-5.1.13">5.1.13</a>) is then applied to each result expression.</strong></p>
<!---------------------- Chapter 11 -------------------------------->
<h3 id="jep325-11.2.1">11.2.1. Exception Analysis of Expressions</h3>
<p>A class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>) can throw an exception class <span class="type">E</span> iff either:</p>
<ul>
<li><p>The expression is a qualified class instance creation expression and the qualifying expression can throw <span class="type">E</span>; or</p></li>
<li><p>Some expression of the argument list can throw <span class="type">E</span>; or</p></li>
<li><p><span class="type">E</span> is one of the exception types of the invocation type of the chosen constructor (<a href="../../se10/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>); or</p></li>
<li><p>The class instance creation expression includes a <span class="emphasis"><em>ClassBody</em></span>, and some instance initializer or instance variable initializer in the <span class="emphasis"><em>ClassBody</em></span> can throw <span class="type">E</span>.</p></li>
</ul>
<p>A method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>) can throw an exception class <span class="type">E</span> iff either:</p>
<ul>
<li><p>The method invocation expression is of the form <span class="emphasis"><em>Primary</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> and the <span class="emphasis"><em>Primary</em></span> expression can throw <span class="type">E</span>; or</p></li>
<li><p>Some expression of the argument list can throw <span class="type">E</span>; or</p></li>
<li><p><span class="type">E</span> is one of the exception types of the invocation type of the chosen method (<a href="../../se10/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
</ul>
<p><strong>A <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) can throw an exception class <span class="type">E</span> iff either:</strong></p>
<ul>
<li><p><strong>The selector expression can throw <span class="type">E</span>; or</strong></p></li>
<li><p><strong>Some expression or statement in the switch block can throw <span class="type">E</span>.</strong></p></li>
</ul>
<p>A lambda expression (<a href="../../se10/html/jls-15.html#jls-15.27">15.27</a>) can throw no exception classes.</p>
<p>For every other kind of expression, the expression can throw an exception class <span class="type">E</span> iff one of its immediate subexpressions can throw <span class="type">E</span>.</p>
<div class="editorial">
<p>Note that a method reference expression (<a href="../../se10/html/jls-15.html#jls-15.13">15.13</a>) of the form <span class="emphasis"><em>Primary <code class="literal">::</code> [TypeArguments] Identifier</em></span> can throw an exception class if the <span class="emphasis"><em>Primary</em></span> subexpression can throw an exception class. In contrast, a lambda expression can throw nothing, and has no immediate subexpressions on which to perform exception analysis. It is the <span class="emphasis"><em>body</em></span> of a lambda expression, containing expressions and statements, that can throw exception classes.</p>
</div>
<h3 id="jep325-11.2.2">11.2.2. Exception Analysis of Statements</h3>
<p>A <code class="literal">throw</code> statement (<a href="../../se10/html/jls-14.html#jls-14.18">14.18</a>) whose thrown expression has static type <span class="type">E</span> and is not a final or effectively final exception parameter can throw <span class="type">E</span> or any exception class that the thrown expression can throw.</p>
<div class="editorial">
<p>For example, the statement <code class="literal">throw new java.io.FileNotFoundException();</code> can throw <code class="literal">java.io.FileNotFoundException</code> only. Formally, it is not the case that it “can throw” a subclass or superclass of <code class="literal">java.io.FileNotFoundException</code>.</p>
</div>
<p>A <code class="literal">throw</code> statement whose thrown expression is a final or effectively final exception parameter of a <code class="literal">catch</code> clause <span class="type">C</span> can throw an exception class <span class="type">E</span> iff:</p>
<div class="norm">
<ul>
<li><p><span class="type">E</span> is an exception class that the <code class="literal">try</code> block of the <code class="literal">try</code> statement which declares <span class="type">C</span> can throw; and</p></li>
<li><p><span class="type">E</span> is assignment compatible with any of <span class="type">C</span>’s catchable exception classes; and</p></li>
<li><p><span class="type">E</span> is not assignment compatible with any of the catchable exception classes of the <code class="literal">catch</code> clauses declared to the left of <span class="type">C</span> in the same <code class="literal">try</code> statement.</p></li>
</ul>
</div>
<p>A <code class="literal">try</code> statement (<a href="../../se10/html/jls-14.html#jls-14.20">14.20</a>) can throw an exception class <span class="type">E</span> iff either:</p>
<div class="norm">
<ul>
<li><p>The <code class="literal">try</code> block can throw <span class="type">E</span>, or an expression used to initialize a resource (in a <code class="literal">try</code>-with-resources statement) can throw <span class="type">E</span>, or the automatic invocation of the <code class="literal">close()</code> method of a resource (in a <code class="literal">try</code>-with-resources statement) can throw <span class="type">E</span>, and <span class="type">E</span> is not assignment compatible with any catchable exception class of any <code class="literal">catch</code> clause of the <code class="literal">try</code> statement, and either no <code class="literal">finally</code> block is present or the <code class="literal">finally</code> block can complete normally; or</p></li>
<li><p>Some <code class="literal">catch</code> block of the <code class="literal">try</code> statement can throw <span class="type">E</span> and either no <code class="literal">finally</code> block is present or the <code class="literal">finally</code> block can complete normally; or</p></li>
<li><p>A <code class="literal">finally</code> block is present and can throw <span class="type">E</span>.</p></li>
</ul>
</div>
<p>An explicit constructor invocation statement (<a href="../../se10/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>) can throw an exception class <span class="type">E</span> iff either:</p>
<div class="norm">
<ul>
<li><p>Some expression of the constructor invocation’s parameter list can throw <span class="type">E</span>; or</p></li>
<li><p><span class="type">E</span> is determined to be an exception class of the <code class="literal">throws</code> clause of the constructor that is invoked (<a href="../../se10/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
</ul>
</div>
<p><strong>A <code>switch</code> statement (<a href="switch-expressions.html#jep325-14.11">14.11</a>) can throw an exception class <span class="type">E</span> iff either:</strong></p>
<ul>
<li><p><strong>The selector expression can throw <span class="type">E</span>; or</strong></p></li>
<li><p><strong>Some expression or statement in the switch block can throw <span class="type">E</span>.</strong></p></li>
</ul>
<p>Any other statement <span class="emphasis"><em>S</em></span> can throw an exception class <span class="type">E</span> iff an expression or statement immediately contained in <span class="emphasis"><em>S</em></span> can throw <span class="type">E</span>.</p>
<!---------------------- Chapter 14 -------------------------------->
<h2 id="jep325-14.1">14.1. Normal and Abrupt Completion of Statements</h2>
<p>Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement.</p>
<p>If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to <em>complete normally</em>. However, certain events may prevent a statement from completing normally:</p>
<ul>
<li><p>The <code>break</code> (<a href="switch-expressions.html#jep325-14.15">14.15</a>), <code>continue</code> (<a href="switch-expressions.html#jep325-14.16">14.16</a>), and <code>return</code> (<a href="switch-expressions.html#jep325-14.17">14.17</a>) statements cause a transfer of control that may prevent normal completion of statements that contain them.</p></li>
<li><p>Evaluation of certain expressions may throw exceptions from the Java Virtual Machine (<a href="switch-expressions.html#jep325-15.6">15.6</a>). An explicit <code>throw</code> (<a href="../../se10/html/jls-14.html#jls-14.18">14.18</a>) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.</p></li>
</ul>
<p>If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to <em>complete abruptly</em>.</p>
<p>An abrupt completion always has an associated <em>reason</em>, which is one of the following:</p>
<ul>
<li><p>A <code>break</code> with no label <strong>or value</strong></p></li>
<li><p>A <code>break</code> with a given label</p></li>
<li><p><strong>A <code>break</code> with a given value</strong></p></li>
<li><p>A <code>continue</code> with no label</p></li>
<li><p>A <code>continue</code> with a given label</p></li>
<li><p>A <code>return</code> with no value</p></li>
<li><p>A <code>return</code> with a given value</p></li>
<li><p>A <code>throw</code> with a given value, including exceptions thrown by the Java Virtual Machine</p></li>
</ul>
<p>The terms “complete normally” and “complete abruptly” also apply to the evaluation of expressions (<a href="switch-expressions.html#jep325-15.6">15.6</a>). The only reason an expression can complete abruptly is that an exception is thrown, because of either a <code>throw</code> with a given value (<a href="../../se10/html/jls-14.html#jls-14.18">14.18</a>) or a run-time exception or error ([11 (<em>Exceptions</em>)], <a href="switch-expressions.html#jep325-15.6">15.6</a>).</p>
<p>If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.</p>
<p>Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.</p>
<p>Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.</p>
<h2 id="jep325-14.11">14.11. The <code>switch</code> Statement</h2>
<div class="editorial">
<p>[<em>Editorial note:</em> The existing section 14.11 is replaced in its entirety with the following.]</p>
</div>
<p>The <code>switch</code> statement transfers control to one of several statements depending on the value of an expression. This expression is known as the <em>selector expression</em>.</p>
<blockquote>
<p><em>SwitchStatement</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>switch</code> <code>(</code> <em>Expression</em> <code>)</code> <em>SwitchBlock</em></p>
</blockquote>
</blockquote>
<p>The type of the selector expression must be <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>Character</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>String</code>, or an enum type (<a href="../../se10/html/jls-8.html#jls-8.9">8.9</a>), or a compile-time error occurs.</p>
<h3 id="jep325-14.11.1">14.11.1 Switch Block</h3>
<blockquote>
<p><em>SwitchBlock</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>{</code> <em>SwitchLabeledRule</em> <em>{</em> <em>SwitchLabeledRule</em> <em>}</em> <code>}</code><br />
<code>{</code> <em>{</em> <em>SwitchLabeledStatementGroup</em> <em>}</em> <em>{</em> <em>SwitchLabel</em> <code>:</code> <em>}</em> <code>}</code></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabeledRule</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>SwitchLabeledExpression</em><br />
<em>SwitchLabeledBlock</em><br />
<em>SwitchLabeledThrowStatement</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabeledExpression</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>SwitchLabel</em> <code>-&gt;</code> <em>Expression</em> <code>;</code></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabeledBlock</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>SwitchLabel</em> <code>-&gt;</code> <em>Block</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabeledThrowStatement</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>SwitchLabel</em> <code>-&gt;</code> <em>ThrowStatement</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabel</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><code>case</code> <em>CaseConstant</em> <em>{</em> <code>,</code> <em>CaseConstant</em> <em>}</em><br />
<code>default</code></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>CaseConstant</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>ConditionalExpression</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>SwitchLabeledStatementGroup</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>SwitchLabel</em> <code>:</code> <em>{</em> <em>SwitchLabel</em> <code>:</code> <em>}</em> <em>BlockStatements</em></p>
</blockquote>
</blockquote>
<!--The body of both a `switch` statement and a `switch` expression ([15.28]) is known as a _switch block_. This block can either be empty, or take one of two forms:

1. A switch block can consist of one or more _switch labeled rules_, which is either a switch labeled expression, block, or throw statement. 

2. A switch block can consist of one or more _switch labeled statement groups_, optionally followed by switch labels. A switch labeled statement group consists of one or more block statements labeled with one or more switch labels.  

A _switch label_ can be either a `case` label or a `default` label. Every `case` label has at least one `case` constant.  `case` and `default` labels, and the `case` constants of `case` labels, are said to be _associated_ with the switch block.-->
<p>The body of both a <code>switch</code> statement and a <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) is known as a <em>switch block</em>. This block can consist of either:</p>
<ol type="1">
<li><p><em>Switch labeled rules</em>, which use ‘<code>-&gt;</code>’ to introduce either a <em>switch labeled expression</em>, block, or throw statement; or</p></li>
<li><p><em>Switch labeled statement groups</em>, which use ‘<code>:</code>’ to introduce <em>switch labeled block statements</em>.</p></li>
</ol>
<p>A <em>switch label</em> can be either a <code>case</code> label or a <code>default</code> label. Every <code>case</code> label has at least one <code>case</code> constant. <code>case</code> and <code>default</code> labels, and the <code>case</code> constants of <code>case</code> labels, are said to be <em>associated</em> with the switch block.</p>
<p>Every <code>case</code> constant associated with a given switch block must be either a constant expression (<del>15.28</del><strong><a href="switch-expressions.html#jep325-15.29">15.29</a></strong>) or the name of an enum constant, or a compile-time error occurs.</p>
<div class="editorial">
<p>This excludes the possibility of using <code>null</code> as a <code>case</code> constant.</p>
</div>
<!--- Type checking --->
<p>A switch block is said to be <em>compatible</em> with the type of the selector expression, <em>T</em>, if both of the following are true:</p>
<ul>
<li><p>Every <code>case</code> constant associated with the switch block is assignment compatible with <em>T</em> (<a href="../../se10/html/jls-5.html#jls-5.2">5.2</a>).</p></li>
<li><p>If <em>T</em> is an enum type, then every <code>case</code> constant associated with the switch block is an enum constant of type <em>T</em>.</p></li>
</ul>
<!--- Matching --->
<p>At run time, the value of the selector expression is compared with each <code>case</code> constant (if the selector expression is a reference type that is not the type <code>String</code>, then it is first subject to an unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>)):</p>
<ul>
<li><p>If one of the <code>case</code> constants is equal to the value of the selector expression, then we say that the <code>case</code> label <em>matches</em>.</p></li>
<li><p>If no <code>case</code> label matches but there is a <code>default</code> label, then we say that the <code>default</code> label <em>matches</em>.</p></li>
</ul>
<div class="editorial">
<p>The prohibition against using <code>null</code> as a <code>case</code> constant prevents code being written that can never be executed. If the selector expression is of a reference type, that is, <code>String</code> or a boxed primitive type or an enum type, then an exception will be thrown will occur if the <em>Expression</em> evaluates to <code>null</code> at run time. In the judgment of the designers of the Java programming language, this is a better outcome than either the switch block not matching or even the <code>default</code> label matching.</p>
<p>In C and C++ the body of a <code>switch</code> statement can be a statement and statements with <code>case</code> heads do not have to be immediately contained by that statement. Consider the simple loop:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; n; ++i) <span class="fu">foo</span>();</a></code></pre></div>
<p>where <code>n</code> is known to be positive. A trick known as <em>Duff’s device</em> can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="dt">int</span> q = (n+<span class="dv">7</span>)/<span class="dv">8</span>;</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">switch</span> (n%<span class="dv">8</span>) {</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="kw">case</span> <span class="dv">0</span>: <span class="kw">do</span> { <span class="fu">foo</span>();    <span class="co">// Great C hack, Tom,</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="kw">case</span> <span class="dv">7</span>:      <span class="fu">foo</span>();    <span class="co">// but it&#39;s not valid here.</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="kw">case</span> <span class="dv">6</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="kw">case</span> <span class="dv">5</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="kw">case</span> <span class="dv">4</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="kw">case</span> <span class="dv">3</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">case</span> <span class="dv">2</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="kw">case</span> <span class="dv">1</span>:      <span class="fu">foo</span>();</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">            } <span class="kw">while</span> (--q &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">}</a></code></pre></div>
<p>Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.</p>
<p>A <code>case</code> label can contain several <code>case</code> constants, and matches the value of a selector expression if any one of its <code>case</code> constants matches.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">switch</span> (day) {</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="kw">case</span> SATURDAY, SUNDAY: </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">        <span class="co">// matches if it is a Saturday OR a Sunday</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;It&#39;s the weekend!&quot;</span>);</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">}</a></code></pre></div>
</div>
<h3 id="jep325-14.11.2">14.11.2 The Switch Block of a <code>switch</code> Statement</h3>
<p>Given a <code>switch</code> statement, all of the following must be true or a compile-time error occurs:</p>
<ul>
<li><p>the switch block must be compatible with the type of the selector expression.</p></li>
<li><p>No two of the <code>case</code> constants associated with the switch block may have the same value.</p></li>
<li><p>At most one <code>default</code> label is associated with the switch block.</p></li>
<li><p>If the switch block consists of switch labeled rules, then any switch labeled expression must be a statement expression (<a href="../../se10/html/jls-14.html#jls-14.8">14.8</a>).</p></li>
</ul>
<div class="editorial">
<p>Switch labeled rules in <code>switch</code> statements differ from those in <code>switch</code> expressions (<a href="switch-expressions.html#jep325-15.28">15.28</a>). In <code>switch</code> statements they must be switch labeled <em>statement</em> expressions, whereas in <code>switch</code> expressions they may be any switch labeled expression (<a href="switch-expressions.html#jep325-15.28.1">15.28.1</a>).</p>
</div>
<p>A <code>switch</code> statement is permitted to have an empty switch block.</p>
<div class="editorial">
<p>In this respect, <code>switch</code> statements differ from <code>switch</code> expressions (<a href="switch-expressions.html#jep325-15.28">15.28</a>) which are not permitted to have an empty switch block.</p>
</div>
<h3 id="jep325-14.11.3">14.11.3 Execution of a <code>switch</code> Statement</h3>
<p>When the <code>switch</code> statement is executed, first the selector expression is evaluated:</p>
<ol type="1">
<li><p>If evaluation of the selector expression completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason.</p></li>
<li><p>If the selector expression evaluates to <code>null</code>, then a <code>NullPointerException</code> is thrown and the entire <code>switch</code> statement completes abruptly for that reason.</p></li>
<li><p>Otherwise, execution continues by determining if a switch label associated with the switch block matches the value of the selector expression:</p>
<p>If no switch label matches, then the entire <code>switch</code> statement completes normally.</p>
<p>If a switch label matches, then one of the following applies:</p>
<ul>
<li>If it labels a statement expression, then the statement expression is evaluated. If the result of evaluation is a value, it is discarded. If the evaluation completes normally, then the <code>switch</code> statement completes normally.</li>
<li>If it labels a statement, then the statement is executed. If this statement completes normally, then the <code>switch</code> statement completes normally.</li>
<li>If it labels a statement group, then all the statements in the switch block that follow it are executed in order. If these statements complete normally, then the <code>switch</code> statement completes normally.</li>
<li>Otherwise, there are no statements that follow it in the switch block, and the <code>switch</code> statement completes normally.</li>
</ul></li>
</ol>
<p>If execution of any statement or expression completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If execution of a statement completes abruptly because of an empty <code>break</code> statement, no further action is taken and the <code>switch</code> statement completes normally.</p></li>
<li><p>If execution of a statement or expression completes abruptly for any other reason, the <code>switch</code> statement completes abruptly for the same reason.</p></li>
</ul>
<div class="editorial">
<p>The case of abrupt completion because of a value <code>break</code> statement is prohibited by (<a href="switch-expressions.html#jep325-14.15">14.15</a>).</p>
<p>The case of abrupt completion because of a labeled <code>break</code> statement is handled by the general rule for labeled statements (<a href="../../se10/html/jls-14.html#jls-14.7">14.7</a>).</p>
<p>When a selector expression matches a switch label within a switch labeled rule, only the labeled expression or statement is executed and nothing else. In the other case, <em>all</em> the block statements in the switch block that follow the switch label are executed, including those that appear after subsequent switch labels. The effect is that, as in C and C++, execution of statements can “fall through labels.”</p>
<p>For example, the program:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">class</span> TooMany {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howMany</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">            <span class="kw">case</span> <span class="dv">1</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="st">&quot;one &quot;</span>);</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">            <span class="kw">case</span> <span class="dv">2</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="st">&quot;too &quot;</span>);</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">            <span class="kw">case</span> <span class="dv">3</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args) {</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        <span class="fu">howMany</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        <span class="fu">howMany</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        <span class="fu">howMany</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">}</a></code></pre></div>
<p>contains a <code>switch</code> block in which the code for each <code>case</code> falls through into the code for the next <code>case</code>. As a result, the program prints:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" data-line-number="1">many</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">too many</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">one too many</a></code></pre></div>
<p>This fall through behaviour can be the cause of subtle bugs. If code is not to fall through <code>case</code> to <code>case</code> in this manner, switch labeled rules can be used, or empty <code>break</code> statements can be used to explicitly indicate where control should be transfered, as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> TwoMany {</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howManyRule</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">            <span class="kw">case</span> <span class="dv">1</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;one&quot;</span>);</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">            <span class="kw">case</span> <span class="dv">2</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;two&quot;</span>);</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">            <span class="kw">case</span> <span class="dv">3</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howManyGroup</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">            <span class="kw">case</span> <span class="dv">1</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;one&quot;</span>);</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">            <span class="kw">case</span> <span class="dv">2</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;two&quot;</span>);</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15">            <span class="kw">case</span> <span class="dv">3</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">                    <span class="kw">break</span>;  <span class="co">// not needed, but good style</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">        }</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args) {</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">        <span class="fu">howManyRule</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">        <span class="fu">howManyRule</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">        <span class="fu">howManyRule</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">        <span class="fu">howManyGroup</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">        <span class="fu">howManyGroup</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">        <span class="fu">howManyGroup</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb10-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb10-27" data-line-number="27">}</a></code></pre></div>
<p>This program prints:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" data-line-number="1">one</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">two</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">many</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">one</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">two</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">many</a></code></pre></div>
</div>
<h2 id="jep325-14.15">14.15. The <code>break</code> Statement</h2>
<p>A <code>break</code> statement transfers control out of an enclosing statement<strong>, or causes an enclosing <code>switch</code> expression to produce a specified value</strong>.</p>
<blockquote>
<p><em>BreakStatement</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><del><code>break</code> <em>[<strong>Identifier</strong>]</em> <code>;</code></del><br />
<code>break</code> <em>Identifier</em> <code>;</code><br />
<code>break</code> <em>Expression</em> <code>;</code><br />
<strong><code>break</code> <code>;</code></strong></p>
</blockquote>
</blockquote>
<p><strong>There are three kinds of <code>break</code> statement:</strong></p>
<ol type="1">
<li><strong>A <code>break</code> statement with label <em>Identifier</em>; or, more succinctly, a labeled <code>break</code> statement.</strong></li>
<li><strong>A <code>break</code> statement with value <em>Expression</em>; or, more succinctly, a value <code>break</code> statement.</strong></li>
<li><strong>A <code>break</code> statement with no label or value; or, more succinctly, an empty <code>break</code> statement.</strong></li>
</ol>
<p><del>A <code>break</code> statement with no label attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method or initializer; this statement, which is called the <em>break target</em>, then immediately completes normally.</del></p>
<p><del>To be precise, a <code>break</code> statement with no label always completes abruptly, the reason being a <code>break</code> with no label.</del></p>
<p><del>If no <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement in the immediately enclosing method, constructor, or initializer contains the <code>break</code> statement, a compile-time error occurs.</del></p>
<p><del>A <code>break</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se10/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; this statement, which is called the <em>break target</em>, then immediately completes normally. In this case, the break target need not be a <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement.</del></p>
<p><del>To be precise, a <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>break</code> with label <em>Identifier</em>.</del></p>
<p><del>A <code>break</code> statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body. There are no non-local jumps. If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, initializer, or lambda body contains the <code>break</code> statement, a compile-time error occurs.</del></p>
<p><strong>An empty <code>break</code> statement attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement; this statement, which is called the <em>break target</em>, then immediately completes normally.</strong></p>
<p><strong>A value <code>break</code> statement attempts to transfer control to the innermost enclosing <code>switch</code> expression; this expression, which is called the <em>break target</em>, then immediately completes normally and the value of the <em>Expression</em> becomes the value of the <code>switch</code> expression.</strong></p>
<p><strong>A labeled <code>break</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se10/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; this statement, which is called the <em>break target</em>, then immediately completes normally.</strong></p>
<p><strong>It is a compile-time error if a <code>break</code> statement has no break target, or if the break target contains any method, constructor, initializer, lambda expression, or <code>switch</code> expression that encloses the <code>break</code> statement.</strong></p>
<p><strong>It is a compile-time error if the break target of a value <code>break</code> statement contains any <code>switch</code>, <code>while</code>, <code>do</code> or <code>for</code> statement that encloses the value <code>break</code> statement.</strong></p>
<p><strong>It is a compile-time error if a value <code>break</code> statement is contained in a labeled statement, where <em>Expression</em> is a simple name (15.14.1) that is the same identifier as the label.</strong></p>
<p><strong>It is a compile-time error if the <em>Expression</em> of a value <code>break</code> statement is void (<a href="switch-expressions.html#jep325-15.1">15.1</a>).</strong></p>
<p><strong>Execution of an empty <code>break</code> statement always completes abruptly, the reason being a break with no label.</strong></p>
<p><strong>Execution of a value <code>break</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>break</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <em>V</em>, then the <code>break</code> statement completes abruptly, the reason being a break with value <em>V</em>.</strong></p>
<p><strong>Execution of a labeled <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a break with label <em>Identifier</em>.</strong></p>
<div class="editorial">
<p>It can be seen, then, that a <code>break</code> statement always completes abruptly.</p>
<p>The preceding descriptions say “attempts to transfer control” rather than just “transfers control” because if there are any <code>try</code> statements (<a href="../../se10/html/jls-14.html#jls-14.20">14.20</a>) within the break target whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>break</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>break</code> statement.</p>
<p>Example 14.15-1. The <code>break</code> Statement</p>
<p>In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes <code>P</code> and <code>Q</code>, where <code>Q</code> may be the same as <code>P</code>, there is at most one edge from <code>P</code> to <code>Q</code>.</p>
<p>Nodes are represented by integers, and there is an edge from node <code>i</code> to node <code>edges[i</code>][<code>j</code>]</code> for every <code>i</code> and <code>j</code> for which the array reference <code>edges[i</code>][<code>j</code>]</code> does not throw an <code>ArrayIndexOutOfBoundsException</code>.</p>
<p>The task of the method <code>loseEdges</code>, given integers <code>i</code> and <code>j</code>, is to construct a new graph by copying a given graph but omitting the edge from node <code>i</code> to node <code>j</code>, if any, and the edge from node <code>j</code> to node <code>i</code>, if any:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">class</span> Graph {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="dt">int</span> edges;</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="kw">public</span> <span class="fu">Graph</span>(<span class="dt">int</span> edges) { <span class="kw">this</span>.<span class="fu">edges</span> = edges; }</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="kw">public</span> Graph <span class="fu">loseEdges</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">        <span class="dt">int</span> n = edges.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">        <span class="dt">int</span> newedges = <span class="kw">new</span> <span class="dt">int</span>[n];</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">edgelist:</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">            <span class="dt">int</span> z;</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">search:</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            <span class="kw">if</span> (k == i) {</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">                    <span class="kw">if</span> (edges[k][z] == j) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb12-17" data-line-number="17">                }</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">            } <span class="kw">else</span> <span class="kw">if</span> (k == j) {</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">                    <span class="kw">if</span> (edges[k][z] == i) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">                }</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">            }</a>
<a class="sourceLine" id="cb12-23" data-line-number="23"></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">            <span class="co">// No edge to be deleted; share this list.</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25">            newedges[k] = edges[k];</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">            <span class="kw">break</span> edgelist;</a>
<a class="sourceLine" id="cb12-27" data-line-number="27">} <span class="co">//search</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28"></a>
<a class="sourceLine" id="cb12-29" data-line-number="29">            <span class="co">// Copy the list, omitting the edge at position z.</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30">            <span class="dt">int</span> m = edges[k].<span class="fu">length</span> - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb12-31" data-line-number="31">            <span class="dt">int</span> ne = <span class="kw">new</span> <span class="dt">int</span>[m];</a>
<a class="sourceLine" id="cb12-32" data-line-number="32">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], <span class="dv">0</span>, ne, <span class="dv">0</span>, z);</a>
<a class="sourceLine" id="cb12-33" data-line-number="33">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], z+<span class="dv">1</span>, ne, z, m-z);</a>
<a class="sourceLine" id="cb12-34" data-line-number="34">            newedges[k] = ne;</a>
<a class="sourceLine" id="cb12-35" data-line-number="35">} <span class="co">//edgelist</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36">        }</a>
<a class="sourceLine" id="cb12-37" data-line-number="37">        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Graph</span>(newedges);</a>
<a class="sourceLine" id="cb12-38" data-line-number="38">    }</a>
<a class="sourceLine" id="cb12-39" data-line-number="39">}</a></code></pre></div>
<p>Note the use of two statement labels, <code>edgelist</code> and <code>search</code>, and the use of <code>break</code> statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node <code>i</code> to node <code>j</code>, and the test for an edge from node <code>j</code> to node <code>i</code>.</p>
</div>
<h2 id="jep325-14.16">14.16. The <code>continue</code> Statement</h2>
<p>A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements of these three kinds are called <em>iteration statements</em>. Control passes to the loop-continuation point of an iteration statement.</p>
<blockquote>
<p><em>ContinueStatement</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><del><code>continue</code> <em>[<strong>Identifier</strong>]</em> <code>;</code></del><br />
<strong><code>continue</code> <em>Identifier</em> <code>;</code></strong><br />
<strong><code>continue</code> <code>;</code></strong></p>
</blockquote>
</blockquote>
<p><strong>There are two kinds of <code>continue</code> statement:</strong></p>
<ol type="1">
<li><strong>A <code>continue</code> statement with label <em>Identifier</em>; or, more succinctly, a labeled <code>continue</code> statement.</strong></li>
<li><strong>A <code>continue</code> statement with no label; or, more succinctly, an empty <code>continue</code> statement.</strong></li>
</ol>
<p><del>A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method, constructor, or initializer; this statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</del></p>
<p><del>To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label.</del></p>
<p><del>If no <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method, constructor, or initializer contains the <code>continue</code> statement, a compile-time error occurs.</del></p>
<p><del>A <code>continue</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se10/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; that statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</del></p>
<p><del>To be precise, a <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>continue</code> with label <em>Identifier</em>.</del></p>
<p><del>The continue target must be a <code>while</code>, <code>do</code>, or <code>for</code> statement, or a compile-time error occurs.</del></p>
<p><del>A <code>continue</code> statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body, . There are no non-local jumps. If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, initializer, or lambda body, contains the <code>continue</code> statement, a compile-time error occurs.</del></p>
<p><strong>An empty <code>continue</code> statement attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement; this statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</strong></p>
<p><strong>A labeled <code>continue</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se10/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; that statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</strong></p>
<p><strong>The continue target of a labeled continue must be a <code>while</code>, <code>do</code>, or <code>for</code> statement, or a compile-time error occurs.</strong></p>
<p><strong>It is a compile-time error if a <code>continue</code> statement has no continue target, or if the continue target contains any method, constructor, initializer, lambda expression, or <code>switch</code> expression that contains the <code>continue</code> statement.</strong></p>
<p><strong>Execution of an empty <code>continue</code> statement always completes abruptly, the reason being a continue with no label.</strong></p>
<p><strong>Execution of a labeled <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a continue with label <em>Identifier</em>.</strong></p>
<div class="editorial">
<p>It can be seen, then, that a <code>continue</code> statement always completes abruptly.</p>
<p>See the descriptions of the <code>while</code> statement (<a href="../../se10/html/jls-14.html#jls-14.12">14.12</a>), <code>do</code> statement (<a href="../../se10/html/jls-14.html#jls-14.13">14.13</a>), and <code>for</code> statement (<a href="../../se10/html/jls-14.html#jls-14.14">14.14</a>) for a discussion of the handling of abrupt termination because of <code>continue</code>.</p>
<p>The preceding descriptions say “attempts to transfer control” rather than just “transfers control” because if there are any <code>try</code> statements (<a href="../../se10/html/jls-14.html#jls-14.20">14.20</a>) within the continue target whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.</p>
<p><em>Example 14.16-1. The <code>continue</code> Statement</em></p>
<p>In the <code>Graph</code> class in (<a href="switch-expressions.html#jep325-14.15">14.15</a>), one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This break can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> Graph {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="dt">int</span> edges[][];</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">public</span> <span class="fu">Graph</span>(<span class="dt">int</span>[][] edges) { <span class="kw">this</span>.<span class="fu">edges</span> = edges; }</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="kw">public</span> Graph <span class="fu">loseEdges</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        <span class="dt">int</span> n = edges.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        <span class="dt">int</span>[][] newedges = <span class="kw">new</span> <span class="dt">int</span>[n][];</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">edgelists:</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">            <span class="dt">int</span> z;</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">search:</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">            <span class="kw">if</span> (k == i) {</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">                    <span class="kw">if</span> (edges[k][z] == j) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">                }</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">            } <span class="kw">else</span> <span class="kw">if</span> (k == j) {</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">                    <span class="kw">if</span> (edges[k][z] == i) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">                }</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">            }</a>
<a class="sourceLine" id="cb13-22" data-line-number="22"></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">            <span class="co">// No edge to be deleted; share this list.</span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24">            newedges[k] = edges[k];</a>
<a class="sourceLine" id="cb13-25" data-line-number="25">            <span class="kw">continue</span> edgelists;</a>
<a class="sourceLine" id="cb13-26" data-line-number="26">} <span class="co">//search</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">            <span class="co">// Copy the list, omitting the edge at position z.</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29">            <span class="dt">int</span> m = edges[k].<span class="fu">length</span> - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb13-30" data-line-number="30">            <span class="dt">int</span> ne[] = <span class="kw">new</span> <span class="dt">int</span>[m];</a>
<a class="sourceLine" id="cb13-31" data-line-number="31">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], <span class="dv">0</span>, ne, <span class="dv">0</span>, z);</a>
<a class="sourceLine" id="cb13-32" data-line-number="32">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], z+<span class="dv">1</span>, ne, z, m-z);</a>
<a class="sourceLine" id="cb13-33" data-line-number="33">            newedges[k] = ne;</a>
<a class="sourceLine" id="cb13-34" data-line-number="34">        } <span class="co">//edgelists</span></a>
<a class="sourceLine" id="cb13-35" data-line-number="35">        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Graph</span>(newedges);</a>
<a class="sourceLine" id="cb13-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb13-37" data-line-number="37">}</a></code></pre></div>
<p>Which to use, if either, is largely a matter of programming style.</p>
</div>
<h2 id="jep325-14.17">14.17. The <code>return</code> Statement</h2>
<p>A <code>return</code> statement returns control to the invoker of a method (<a href="../../se10/html/jls-8.html#jls-8.4">8.4</a>, <a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>), or constructor ([8.8], <a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>).</p>
<blockquote>
<p><em>ReturnStatement</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><del><code>return</code> <em>[<strong>Expression</strong>]</em> <code>;</code></del><br />
<strong><code>return</code> <em>Expression</em> <code>;</code></strong><br />
<strong><code>return</code> <code>;</code></strong></p>
</blockquote>
</blockquote>
<p><strong>There are two kinds of <code>return</code> statement:</strong></p>
<ol type="1">
<li><strong>A <code>return</code> statement with value <em>Expression</em>; or, more succinctly, a value <code>return</code> statement.</strong></li>
<li><strong>A <code>return</code> statement with no value; or, more succinctly, an empty <code>return</code> statement.</strong></li>
</ol>
<p><del>A <code>return</code> statement is <em>contained</em> in the innermost constructor, method, initializer, or lambda expression whose body encloses the <code>return</code> statement.</del></p>
<p><strong>A <code>return</code> statement attempts to transfer control to the invoker of the innermost enclosing constructor, method, intializer, or lambda expression; this declaration is called the <em>return target</em>. In the case of a value return statement, the value of the <em>Expression</em> becomes the value of the invocation.</strong></p>
<p><strong>It is a compile-time error if a <code>return</code> statement has no return target, or if the return target contains any enclosing method, constructor, initializer, lambda expression, or <code>switch</code> expression that contains the <code>return</code> statement.</strong></p>
<p>It is a compile-time error if <strong>the return target for</strong> a <code>return</code> statement is <del>contained in</del> an instance initializer or a static initializer ([8.6], [8.7]).</p>
<p><del>A <code>return</code> statement with no <em>Expression</em> must be contained in one of the following, or a compile-time error occurs:</del></p>
<ul>
<li><p><del>A method that is declared, using the keyword <code>void</code>, not to return a value ([8.4.5])</del></p></li>
<li><p><del>A constructor ([8.8.7])</del></p></li>
<li><p><del>A lambda expression (<a href="../../se10/html/jls-15.html#jls-15.27">15.27</a>)</del></p></li>
</ul>
<p><del>A <code>return</code> statement with no <em>Expression</em> attempts to transfer control to the invoker of the method, constructor, or lambda body that contains it. To be precise, a <code>return</code> statement with no <em>Expression</em> always completes abruptly, the reason being a return with no value.</del></p>
<p><del>A <code>return</code> statement with an <em>Expression</em> must be contained in one of the following, or a compile-time error occurs:</del></p>
<ul>
<li><p><del>A method that is declared to return a value</del></p></li>
<li><p><del>A lambda expression</del></p></li>
</ul>
<p><del>The <em>Expression</em> must denote a variable or a value, or a compile-time error occurs.</del></p>
<p><del>When a <code>return</code> statement with an <em>Expression</em> appears in a method declaration, the <em>Expression</em> must be assignable (<a href="../../se10/html/jls-5.html#jls-5.2">5.2</a>) to the declared return type of the method, or a compile-time error occurs.</del></p>
<p><del>A <code>return</code> statement with an <em>Expression</em> attempts to transfer control to the invoker of the method or lambda body that contains it; the value of the <em>Expression</em> becomes the value of the method invocation. More precisely, execution of such a <code>return</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <code class="varname">V</code>, then the <code>return</code> statement completes abruptly, the reason being a return with value <code class="varname">V</code>.</del></p>
<p><strong>It is a compile-time error if the return target of an empty <code>return</code> statement is a method, and that method is not declared ‘void’.</strong></p>
<p><strong>It is a compile-time error if the return target of a value <code>return</code> statement is a constructor or a method that is declared ‘void’; or if the return target is a method with declared return type <em>T</em>, and <em>Expression</em> is not assignable (<a href="../../se10/html/jls-5.html#jls-5.2">5.2</a>) to <em>T</em>.</strong></p>
<p><strong>Execution of an empty <code>return</code> statement always completes abruptly, the reason being a return with no value.</strong></p>
<p><strong>Execution of a value <code>return</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <em>V</em>, then the <code>return</code> statement completes abruptly, the reason being a return with value V.</strong></p>
<p>If the expression is of type <code>float</code> and is not FP-strict (<a href="../../se10/html/jls-15.html#jls-15.4">15.4</a>), then the value may be an element of either the float value set or the float-extended-exponent value set (<a href="../../se10/html/jls-4.html#jls-4.2.3">4.2.3</a>). If the expression is of type <code>double</code> and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.</p>
<div class="editorial">
<p>It can be seen, then, that a <code>return</code> statement always completes abruptly.</p>
<p>The preceding descriptions say “attempts to transfer control” rather than just “transfers control” because if there are any <code>try</code> statements (<a href="../../se10/html/jls-14.html#jls-14.20">14.20</a>) within the method or constructor whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>return</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>return</code> statement.</p>
</div>
<h2 id="jep325-14.21">14.21. Unreachable Statements</h2>
<p>It is a compile-time error if a statement cannot be executed because it is <em>unreachable</em>.</p>
<div class="editorial">
<p>This section is devoted to a precise explanation of the word “reachable.” The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of <code>while</code>, <code>do</code>, and <code>for</code> statements whose condition expression has the constant value <code>true</code>, the values of expressions are not taken into account in the flow analysis.</p>
<p>For example, a Java compiler will accept the code:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb14-1" data-line-number="1">{</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="dt">int</span> n = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="kw">while</span> (n &gt; <span class="dv">7</span>) k = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">}</a></code></pre></div>
<p>even though the value of <code>n</code> is known at compile time and in principle it can be known at compile time that the assignment to <code>k</code> can never be executed.</p>
</div>
<p>The rules in this section define two technical terms:</p>
<ul>
<li><p>whether a statement is <em>reachable</em></p></li>
<li><p>whether a statement <em>can complete normally</em></p></li>
</ul>
<p>The definitions here allow a statement to complete normally only if it is reachable.</p>
<p>To shorten the description of the rules, the customary abbreviation “iff” is used to mean “if and only if.”</p>
<p>A reachable <code>break</code> statement <em>exits a statement</em> if, within the break target, either there are no <code>try</code> statements whose <code>try</code> blocks contain the <code>break</code> statement, or there are <code>try</code> statements whose <code>try</code> blocks contain the <code>break</code> statement and all <code>finally</code> clauses of those <code>try</code> statements can complete normally.</p>
<div class="editorial">
<p>This definition is based on the logic around “attempts to transfer control” in <a href="switch-expressions.html#jep325-14.15">14.15</a>.</p>
</div>
<p>A <code>continue</code> statement <em>continues a <code>do</code> statement</em> if, within the <code>do</code> statement, either there are no <code>try</code> statements whose <code>try</code> blocks contain the <code>continue</code> statement, or there are <code>try</code> statements whose <code>try</code> blocks contain the <code>continue</code> statement and all <code>finally</code> clauses of those <code>try</code> statements can complete normally.</p>
<p>The rules are as follows:</p>
<ul>
<li><p>The block that is the body of a constructor, method, instance initializer, <del>or</del> static initializer<strong>, lambda expression, or <code>switch</code> expression</strong> is reachable.</p></li>
<li><p>An empty block that is not a switch block can complete normally iff it is reachable.</p>
<p>A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally.</p>
<p>The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.</p>
<p>Every other statement <code>S</code> in a non-empty block that is not a switch block is reachable iff the statement preceding <code>S</code> can complete normally.</p></li>
<li><p>A local class declaration statement can complete normally iff it is reachable.</p></li>
<li><p>A local variable declaration statement can complete normally iff it is reachable.</p></li>
<li><p>An empty statement can complete normally iff it is reachable.</p></li>
<li><p>A labeled statement can complete normally if at least one of the following is true:</p>
<ul>
<li><p>The contained statement can complete normally.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the labeled statement.</p></li>
</ul>
<p>The contained statement is reachable iff the labeled statement is reachable.</p></li>
<li><p>An expression statement can complete normally iff it is reachable.</p></li>
<li><p>An <code>if</code>-<code>then</code> statement can complete normally iff it is reachable.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable.</p>
<p>An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.</p>
<p>The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.</p>
<div class="editorial">
<p>This handling of an <code>if</code> statement, whether or not it has an <code>else</code> part, is rather unusual. The rationale is given at the end of this section.</p>
</div></li>
<li><p>An <code>assert</code> statement can complete normally iff it is reachable.</p></li>
<li><p><strong>A <code>switch</code> statement whose switch block is empty, or contains only switch labels, completes normally.</strong></p></li>
<li><p>A <code>switch</code> statement <strong>with a switch block that consists of switch labeled statement groups</strong> can complete normally iff at least one of the following is true:</p>
<ul>
<li><p><del>The switch block is empty or contains only switch labels.</del></p></li>
<li><p>The last statement in the switch block can complete normally.</p></li>
<li><p>There is at least one switch label after the last switch block statement group.</p></li>
<li><p>The switch block does not contain a <code>default</code> label.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>switch</code> statement.</p></li>
</ul></li>
<li><p><strong>A <code>switch</code> statement with a switch block that consists of switch labeled rules can complete normally iff at least one of the following is true:</strong></p>
<ul>
<li><p><strong>One of the switch labeled rules is a switch labeled expression (which is necessarily a statement expression).</strong></p></li>
<li><p><strong>One of the switch labeled rules is a switch labeled block that can complete normally.</strong></p></li>
<li><p><strong>One of the switch labeled rules is a switch labeled block that contains a reachable <code>break</code> statement that exits the <code>switch</code> statement.</strong></p></li>
</ul></li>
<li><p>A switch block is reachable iff its <code>switch</code> statement is reachable.</p></li>
<li><p>A statement in a switch block <strong>that consists of switch labeled statement groups</strong> is reachable iff <del>its</del> <del><code>switch</code></del> <del>statement</del> <strong>the switch block</strong> is reachable and at least one of the following is true:</p>
<ul>
<li><p>It bears a <code>case</code> or <code>default</code> label.</p></li>
<li><p>There is a statement preceding it in the switch block and that preceding statement can complete normally.</p></li>
</ul></li>
<li><p><strong>A switch labeled block in a switch block is reachable iff the switch block is reachable.</strong></p></li>
<li><p>A <code>while</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>while</code> statement is reachable and the condition expression is not a constant expression (<del>15.28</del><strong><a href="switch-expressions.html#jep325-15.29">15.29</a></strong>) with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>while</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>while</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>A <code>do</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The contained statement can complete normally and the condition expression is not a constant expression (<del>15.28</del><a href="switch-expressions.html#jep325-15.29">15.29</a>) with value <code>true</code>.</p></li>
<li><p>The <code>do</code> statement contains a reachable <code>continue</code> statement with no label, and the <code>do</code> statement is the innermost <code>while</code>, <code>do</code>, or <code>for</code> statement that contains that <code>continue</code> statement, and the <code>continue</code> statement continues that <code>do</code> statement, and the condition expression is not a constant expression with value <code>true</code>.</p></li>
<li><p>The <code>do</code> statement contains a reachable <code>continue</code> statement with a label <code>L</code>, and the <code>do</code> statement has label <code>L</code>, and the <code>continue</code> statement continues that <code>do</code> statement, and the condition expression is not a constant expression with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>do</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>do</code> statement is reachable.</p></li>
<li><p>A basic <code>for</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>for</code> statement is reachable, there is a condition expression, and the condition expression is not a constant expression (<del>15.28</del><strong><a href="switch-expressions.html#jep325-15.28">15.28</a></strong>) with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>for</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>for</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>An enhanced <code>for</code> statement can complete normally iff it is reachable.</p></li>
<li><p>A <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement cannot complete normally.</p></li>
<li><p>A <code>synchronized</code> statement can complete normally iff the contained statement can complete normally.</p>
<p>The contained statement is reachable iff the <code>synchronized</code> statement is reachable.</p></li>
<li><p>A <code>try</code> statement can complete normally iff both of the following are true:</p>
<ul>
<li><p>The <code>try</code> block can complete normally or any <code>catch</code> block can complete normally.</p></li>
<li><p>If the <code>try</code> statement has a <code>finally</code> block, then the <code>finally</code> block can complete normally.</p></li>
</ul></li>
<li><p>The <code>try</code> block is reachable iff the <code>try</code> statement is reachable.</p></li>
<li><p>A <code>catch</code> block <code>C</code> is reachable iff both of the following are true:</p>
<ul>
<li><p>Either the type of <code>C</code>’s parameter is an unchecked exception type or <code>Exception</code> or a superclass of <code>Exception</code>, or some expression or <code>throw</code> statement in the <code>try</code> block is reachable and can throw a checked exception whose type is assignable to the type of <code>C</code>’s parameter. (An expression is reachable iff the innermost statement containing it is reachable.)</p>
<div class="editorial">
<p>See <a href="switch-expressions.html#jep325-15.6">15.6</a> for normal and abrupt completion of expressions.</p>
</div></li>
<li><p>There is no earlier <code>catch</code> block <code>A</code> in the <code>try</code> statement such that the type of <code>C</code>’s parameter is the same as or a subclass of the type of <code>A</code>’s parameter.</p></li>
</ul></li>
<li><p>The <em>Block</em> of a <code>catch</code> block is reachable iff the <code>catch</code> block is reachable.</p></li>
<li><p>If a <code>finally</code> block is present, it is reachable iff the <code>try</code> statement is reachable.</p></li>
</ul>
<div class="editorial">
<p>One <em>might expect</em> the <code>if</code> statement to be handled in the following manner:</p>
<ul>
<li><p>An <code>if</code>-<code>then</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.</p></li>
<li><p>The <code>then</code>-statement can complete normally.</p></li>
</ul>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p>
<p>The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.</p></li>
</ul>
<p>This approach would be consistent with the treatment of other control structures. However, in order to allow the if statement to be used conveniently for “conditional compilation” purposes, the actual rules differ.</p>
<p>As an example, the following statement results in a compile-time error:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">while</span> (<span class="kw">false</span>) { x=<span class="dv">3</span>; }</a></code></pre></div>
<p>because the statement <code>x=3;</code> is not reachable; but the superficially similar case:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">if</span> (<span class="kw">false</span>) { x=<span class="dv">3</span>; }</a></code></pre></div>
<p>does not result in a compile-time error. An optimizing compiler may realize that the statement <code>x=3;</code> will never be executed and may choose to omit the code for that statement from the generated <code>class</code> file, but the statement <code>x=3;</code> is not regarded as “unreachable” in the technical sense specified here.</p>
<p>The rationale for this differing treatment is to allow programmers to define “flag variables” such as:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="dt">static</span> <span class="dt">final</span> <span class="dt">boolean</span> DEBUG = <span class="kw">false</span>;</a></code></pre></div>
<p>and then write code such as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">if</span> (DEBUG) { x=<span class="dv">3</span>; }</a></code></pre></div>
<p>The idea is that it should be possible to change the value of <code>DEBUG</code> from <code>false</code> to <code>true</code> or from <code>true</code> to <code>false</code> and then compile the code correctly with no other changes to the program text.</p>
<p>This ability to “conditionally compile” has no relationship to binary compatibility ([13 (<em>Binary Compatibility</em>)]). If a set of classes that use such a “flag” variable are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. The classes that use the flag will not see its new value, so their behavior may be surprising, but no <code>LinkageError</code> will occur. A change to the value of a flag is, therefore, binary compatible with pre-existing binaries, but not behaviorally compatible.</p>
</div>
<!---------------------- Chapter 15 -------------------------------->
<h2 id="jep325-15.1">15.1. Evaluation, Denotation, and Result</h2>
<p>When an expression in a program is <em>evaluated</em> (<em>executed</em>), the result denotes one of three things:</p>
<ul>
<li><p>A variable (<a href="../../se10/html/jls-4.html#jls-4.12">4.12</a>) (in C, this would be called an <em>lvalue</em>)</p></li>
<li><p>A value (<a href="../../se10/html/jls-4.html#jls-4.2">4.2</a>, <a href="../../se10/html/jls-4.html#jls-4.3">4.3</a>)</p></li>
<li><p>Nothing (the expression is said to be void)</p></li>
</ul>
<p>If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the <em>value</em> of the expression.</p>
<p>Value set conversion (<a href="../../se10/html/jls-5.html#jls-5.1.13">5.1.13</a>) is applied to the result of every expression that produces a value, including when the value of a variable of type <code>float</code> or <code>double</code> is used.</p>
<p>An expression denotes nothing if and only if it is a method invocation (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>) that invokes a method that does not return a value, that is, a method declared <code>void</code> (<a href="../../se10/html/jls-8.html#jls-8.4">8.4</a>). Such an expression can be used only as an expression statement (<a href="../../se10/html/jls-14.html#jls-14.8">14.8</a>) or as the single expression of a lambda body (<a href="../../se10/html/jls-15.html#jls-15.27.2">15.27.2</a>), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.</p>
<p>Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method or constructor invocations, <strong>as well as statements contained in <code>switch</code> expressions.</strong></p>
<p>An expression occurs in either:</p>
<ul>
<li><p>The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation.</p></li>
<li><p>An annotation on a package declaration or on a top level type declaration.</p></li>
</ul>
<h2 id="jep325-15.2">15.2. Forms of Expressions</h2>
<p>Expressions can be broadly categorized into one of the following syntactic forms:</p>
<ul>
<li><p>Expression names ([6.5.6])</p></li>
<li><p>Primary expressions ([15.8] - <a href="../../se10/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
<li><p>Unary operator expressions ([15.14] - <a href="../../se10/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>Binary operator expressions (<a href="../../se10/html/jls-15.html#jls-15.17">15.17</a> - <a href="../../se10/html/jls-15.html#jls-15.24">15.24</a>, and [15.26])</p></li>
<li><p>Ternary operator expressions (<a href="switch-expressions.html#jep325-15.25">15.25</a>)</p></li>
<li><p>Lambda expressions (<a href="../../se10/html/jls-15.html#jls-15.27">15.27</a>)</p></li>
</ul>
<p>Precedence among operators is managed by a hierarchy of grammar productions. The lowest precedence operator is the arrow of a lambda expression (<code class="literal">-&gt;</code>), followed by the assignment operators. Thus, all expressions are syntactically included in the <em>LambdaExpression</em> and <em>AssignmentExpression</em> nonterminals:</p>
<blockquote>
<p><em>Expression</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>LambdaExpression</em><br />
<em>AssignmentExpression</em></p>
</blockquote>
</blockquote>
<p>When some expressions appear in certain contexts, they are considered <em>poly expressions</em>. The following forms of expressions may be poly expressions:</p>
<ul>
<li><p>Parenthesized expressions (<a href="../../se10/html/jls-15.html#jls-15.8.5">15.8.5</a>)</p></li>
<li><p>Class instance creation expressions (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>)</p></li>
<li><p>Method invocation expressions (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>Method reference expressions (<a href="../../se10/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
<li><p>Conditional expressions (<a href="switch-expressions.html#jep325-15.25">15.25</a>)</p></li>
<li><p>Lambda expressions (<a href="../../se10/html/jls-15.html#jls-15.27">15.27</a>)</p></li>
<li><p><strong><code>switch</code> expressions (<a href="switch-expressions.html#jep325-15.28">15.28</a>)</strong></p></li>
</ul>
<p>The rules determining whether an expression of one of these forms is a poly expression are given in the individual sections that specify these forms of expressions.</p>
<p>Expressions that are not poly expressions are <em>standalone expressions</em>. Standalone expressions are expressions of the forms above when determined not to be poly expressions, as well as all expressions of all other forms. Expressions of all other forms are said to have a <em>standalone form</em>.</p>
<p>Some expressions have a value that can be determined at compile time. These are <em>constant expressions</em> (<del>15.28</del><strong><a href="switch-expressions.html#jep325-15.29">15.29</a></strong>).</p>
<h2 id="jep325-15.6">15.6. Normal and Abrupt Completion of Evaluation</h2>
<p>Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression.</p>
<p>If all the steps are carried out without an exception being thrown, the expression is said to <em>complete normally</em>.</p>
<p>If, however, evaluation of an expression throws an exception, then the expression is said to <em>complete abruptly</em>. An abrupt completion always has an associated reason, which is always a <code>throw</code> with a given value.</p>
<p>Run-time exceptions are thrown by the predefined operators as follows:</p>
<ul>
<li><p>A class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9.4">15.9.4</a>), array creation expression (<a href="../../se10/html/jls-15.html#jls-15.10.2">15.10.2</a>), method reference expression (<a href="../../se10/html/jls-15.html#jls-15.13.3">15.13.3</a>), array initializer expression (<a href="../../se10/html/jls-8.html#jls-10.6">10.6</a>), string concatenation operator expression (<a href="../../se10/html/jls-15.html#jls-15.18.1">15.18.1</a>), or lambda expression (<a href="../../se10/html/jls-15.html#jls-15.27.4">15.27.4</a>) throws an <code>OutOfMemoryError</code> if there is insufficient memory available.</p></li>
<li><p>An array creation expression (<a href="../../se10/html/jls-15.html#jls-15.10.2">15.10.2</a>) throws a <code>NegativeArraySizeException</code> if the value of any dimension expression is less than zero.</p></li>
<li><p>An array access expression (<a href="../../se10/html/jls-15.html#jls-15.10.4">15.10.4</a>) throws a <code>NullPointerException</code> if the value of the array reference expression is <code>null</code>.</p></li>
<li><p>An array access expression (<a href="../../se10/html/jls-15.html#jls-15.10.4">15.10.4</a>) throws an <code>ArrayIndexOutOfBoundsException</code> if the value of the array index expression is negative or greater than or equal to the <code>length</code> of the array.</p></li>
<li><p>A field access expression (<a href="../../se10/html/jls-15.html#jls-15.11">15.11</a>) throws a <code>NullPointerException</code> if the value of the object reference expression is <code>null</code>.</p></li>
<li><p>A method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>) that invokes an instance method throws a <code>NullPointerException</code> if the target reference is <code>null</code>.</p></li>
<li><p>A cast expression (<a href="../../se10/html/jls-15.html#jls-15.16">15.16</a>) throws a <code>ClassCastException</code> if a cast is found to be impermissible at run time.</p></li>
<li><p>An integer division (<a href="../../se10/html/jls-15.html#jls-15.17.2">15.17.2</a>) or integer remainder (<a href="../../se10/html/jls-15.html#jls-15.17.3">15.17.3</a>) operator throws an <code>ArithmeticException</code> if the value of the right-hand operand expression is zero.</p></li>
<li><p>An assignment to an array component of reference type (<a href="../../se10/html/jls-15.html#jls-15.26.1">15.26.1</a>), a method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>), or a prefix or postfix increment (<a href="../../se10/html/jls-15.html#jls-15.14.2">15.14.2</a>, <a href="../../se10/html/jls-15.html#jls-15.15.1">15.15.1</a>) or decrement operator (<a href="../../se10/html/jls-15.html#jls-15.14.3">15.14.3</a>, <a href="../../se10/html/jls-15.html#jls-15.15.2">15.15.2</a>) may all throw an <code>OutOfMemoryError</code> as a result of boxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.7">5.1.7</a>).</p></li>
<li><p>An assignment to an array component of reference type (<a href="../../se10/html/jls-15.html#jls-15.26.1">15.26.1</a>) throws an <code>ArrayStoreException</code> when the value to be assigned is not compatible with the component type of the array (<a href="../../se10/html/jls-8.html#jls-10.5">10.5</a>).</p></li>
<li><p><strong>A switch expression may throw an <code>IncompatibleClassChangeError</code> if no switch label matches the value of the selector expression.</strong></p></li>
</ul>
<p>A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly.</p>
<p>A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly.</p>
<p>Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle.</p>
<p>If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly.</p>
<p>If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.</p>
<p>The terms “complete normally” and “complete abruptly” are also applied to the execution of statements (<a href="switch-expressions.html#jep325-14.1">14.1</a>). A statement may complete abruptly for a variety of reasons, not just because an exception is thrown.</p>
<h4 id="jep325-15.12.2.1">15.12.2.1. Identify Potentially Applicable Methods</h4>
<p>The class or interface determined by compile-time step 1 (<a href="../../se10/html/jls-15.html#jls-15.12.1">15.12.1</a>) is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search.</p>
<p>In addition, if the form of the method invocation expression is <em>MethodName</em> - that is, a single <em>Identifier</em> - then the search for potentially applicable methods also examines all member methods that are imported by single-static-import declarations and static-import-on-demand declarations of the compilation unit where the method invocation occurs (<a href="../../se10/html/jls-7.html#jls-7.5.3">7.5.3</a>, <a href="../../se10/html/jls-7.html#jls-7.5.4">7.5.4</a>) and that are not shadowed at the point where the method invocation appears.</p>
<p>A member method is <em>potentially applicable</em> to a method invocation if and only if all of the following are true:</p>
<ul>
<li><p>The name of the member is identical to the name of the method in the method invocation.</p></li>
<li><p>The member is accessible ([6.6]) to the class or interface in which the method invocation appears.</p></li>
</ul>
<div class="editorial">
<p>Whether a member method is accessible at a method invocation depends on the access modifier (<code>public</code>, <code>protected</code>, no modifier (package access), or <code>private</code>) in the member’s declaration and on where the method invocation appears.</p>
</div>
<ul>
<li><p>If the member is a fixed arity method with arity <em>n</em>, the arity of the method invocation is equal to <em>n</em>, and for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>n</em>), the <em>i</em>’th argument of the method invocation is <em>potentially compatible</em>, as defined below, with the type of the <em>i</em>’th parameter of the method.</p></li>
<li><p>If the member is a variable arity method with arity <em>n</em>, then for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>n</em>-1), the <em>i</em>’th argument of the method invocation is <em>potentially compatible</em> with the type of the <em>i</em>’th parameter of the method; and, where the <em>n</em>th parameter of the method has type <code>T[]</code>, one of the following is true:</p>
<ul>
<li><p>The arity of the method invocation is equal to <em>n</em>-1.</p></li>
<li><p>The arity of the method invocation is equal to <em>n</em>, and the <em>n</em>th argument of the method invocation is potentially compatible with either <code>T</code> or <code>T[]</code>.</p></li>
<li><p>The arity of the method invocation is <em>m</em>, where <em>m</em> &gt; <em>n</em>, and for all <em>i</em> (<em>n</em> ≤ <em>i</em> ≤ <em>m</em>), the <em>i</em>’th argument of the method invocation is potentially compatible with <code>T</code>.</p></li>
</ul></li>
<li><p>If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.</p></li>
</ul>
<div class="editorial">
<p>This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments. Indeed, it may turn out to be applicable. In such a case, the type arguments will simply be ignored.</p>
<p>This rule stems from issues of compatibility and principles of substitutability. Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one. However, the overriding (non-generic) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments. Otherwise the subtype would not be substitutable for its generified supertype.</p>
</div>
<p>If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.</p>
<p>An expression is <em>potentially compatible</em> with a target type according to the following rules:</p>
<ul>
<li><p>A lambda expression (<a href="../../se10/html/jls-15.html#jls-15.27">15.27</a>) is potentially compatible with a functional interface type (<a href="../../se10/html/jls-9.html#jls-9.8">9.8</a>) if all of the following are true:</p>
<ul>
<li><p>The arity of the target type’s function type is the same as the arity of the lambda expression.</p></li>
<li><p>If the target type’s function type has a <code>void</code> return, then the lambda body is either a statement expression (<a href="../../se10/html/jls-14.html#jls-14.8">14.8</a>) or a void-compatible block (<a href="../../se10/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p></li>
<li><p>If the target type’s function type has a (non-<code>void</code>) return type, then the lambda body is either an expression or a value-compatible block (<a href="../../se10/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p></li>
</ul></li>
<li><p>A method reference expression (<a href="../../se10/html/jls-15.html#jls-15.13">15.13</a>) is potentially compatible with a functional interface type if, where the type’s function type arity is <em>n</em>, there exists at least one potentially applicable method for the method reference expression with arity <em>n</em> (<a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>), and one of the following is true:</p>
<ul>
<li><p>The method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> and at least one potentially applicable method is i) <code>static</code> and supports arity <em>n</em>, or ii) not <code>static</code> and supports arity <em>n</em>-1.</p></li>
<li><p>The method reference expression has some other form and at least one potentially applicable method is not <code>static</code>.</p></li>
</ul></li>
<li><p>A lambda expression or a method reference expression is potentially compatible with a type variable if the type variable is a type parameter of the candidate method.</p></li>
<li><p>A parenthesized expression (<a href="../../se10/html/jls-15.html#jls-15.8.5">15.8.5</a>) is potentially compatible with a type if its contained expression is potentially compatible with that type.</p></li>
<li><p>A conditional expression (<a href="switch-expressions.html#jep325-15.25">15.25</a>) is potentially compatible with a type if each of its second and third operand expressions are potentially compatible with that type.</p></li>
<li><p><strong>A <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) is potentially compatible with a type if all of its result expressions are potentially compatible with that type.</strong></p></li>
<li><p>A class instance creation expression, a method invocation expression, or an expression of a standalone form (<a href="switch-expressions.html#jep325-15.2">15.2</a>) is potentially compatible with any type.</p></li>
</ul>
<div class="editorial">
<p>The definition of potential applicability goes beyond a basic arity check to also take into account the presence and “shape” of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.</p>
</div>
<h4 id="jep325-15.12.2.5">15.12.2.5. Choosing the Most Specific Method</h4>
<p>If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the <em>most specific</em> method is chosen.</p>
<p>The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time error. In cases such as an explicitly typed lambda expression argument (<a href="../../se10/html/jls-15.html#jls-15.27.1">15.27.1</a>) or a variable arity invocation (<a href="../../se10/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>), some flexibility is allowed to adapt one signature to the other.</p>
<p>One applicable method <code>m1</code> is <em>more specific</em> than another applicable method <code>m2</code>, for an invocation with argument expressions <code>e1</code>, …, <code>ek</code>, if any of the following are true:</p>
<ul>
<li><p><code>m2</code> is generic, and <code>m1</code> is inferred to be more specific than <code>m2</code> for argument expressions <code>e1</code>, …, <code>ek</code> by <a href="switch-expressions.html#jep325-18.5.4">18.5.4</a>.</p></li>
<li><p><code>m2</code> is not generic, and <code>m1</code> and <code>m2</code> are applicable by strict or loose invocation, and where <code>m1</code> has formal parameter types S<sub>1</sub>, …, S<sub>n</sub> and <code>m2</code> has formal parameter types T<sub>1</sub>, …, T<sub>n</sub>, the type S<sub>i</sub> is <em>more specific</em> than T<sub>i</sub> for argument <code>ei</code> for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>n</em>, <em>n</em> = <em>k</em>).</p></li>
<li><p><code>m2</code> is not generic, and <code>m1</code> and <code>m2</code> are applicable by variable arity invocation, and where the first <em>k</em> variable arity parameter types of <code>m1</code> are S<sub>1</sub>, …, S<sub>k</sub> and the first <em>k</em> variable arity parameter types of <code>m2</code> are T<sub>1</sub>, …, T<sub>k</sub>, the type S<sub>i</sub> is <em>more specific</em> than T<sub>i</sub> for argument <code>ei</code> for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>k</em>). Additionally, if <code>m2</code> has <em>k</em>+1 parameters, then the <em>k+1</em>’th variable arity parameter type of <code>m1</code> is a subtype of the <em>k+1</em>’th variable arity parameter type of <code>m2</code>.</p></li>
</ul>
<p>The above conditions are the only circumstances under which one method may be more specific than another.</p>
<p>A type S is <em>more specific</em> than a type T for <em>any</em> expression if S <code>&lt;:</code> T (<a href="../../se10/html/jls-4.html#jls-4.10">4.10</a>).</p>
<p>A functional interface type S is <em>more specific</em> than a functional interface type T for an expression <code>e</code> if T is not a subtype of S and one of the following is true (where U<sub>1</sub> … U<sub>k</sub> and R<sub>1</sub> are the parameter types and return type of the function type of the capture of S, and V<sub>1</sub> … V<sub>k</sub> and R<sub>2</sub> are the parameter types and return type of the function type of T):</p>
<ul>
<li><p>If <code>e</code> is an explicitly typed lambda expression (<a href="../../se10/html/jls-15.html#jls-15.27.1">15.27.1</a>), then one of the following is true:</p>
<ul>
<li><p>R<sub>2</sub> is <code>void</code>.</p></li>
<li><p>R<sub>1</sub> <code>&lt;:</code> R<sub>2</sub>.</p></li>
<li><p>R<sub>1</sub> and R<sub>2</sub> are functional interface types, and there is at least one result expression, and R<sub>1</sub> is more specific than R<sub>2</sub> for each result expression of <code>e</code>.</p>
<p>(The result expression of a lambda expression with a block body is defined in <a href="../../se10/html/jls-15.html#jls-15.27.2">15.27.2</a>; the result expression of a lambda expression with an expression body is simply the body itself.)</p></li>
<li><p>R<sub>1</sub> is a primitive type, and R<sub>2</sub> is a reference type, and there is at least one result expression, and each result expression of <code>e</code> is a standalone expression (<a href="switch-expressions.html#jep325-15.2">15.2</a>) of a primitive type.</p></li>
<li><p>R<sub>1</sub> is a reference type, and R<sub>2</sub> is a primitive type, and there is at least one result expression, and each result expression of <code>e</code> is either a standalone expression of a reference type or a poly expression.</p></li>
</ul></li>
<li><p>If <code>e</code> is an exact method reference expression (<a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>), then i) for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>k</em>), U<sub>i</sub> is the same as V<sub>i</sub>, and ii) one of the following is true:</p>
<ul>
<li><p>R<sub>2</sub> is <code>void</code>.</p></li>
<li><p>R<sub>1</sub> <code>&lt;:</code> R<sub>2</sub>.</p></li>
<li><p>R<sub>1</sub> is a primitive type, R<sub>2</sub> is a reference type, and the compile-time declaration for the method reference has a return type which is a primitive type.</p></li>
<li><p>R<sub>1</sub> is a reference type, R<sub>2</sub> is a primitive type, and the compile-time declaration for the method reference has a return type which is a reference type.</p></li>
</ul></li>
<li><p>If <code>e</code> is a parenthesized expression, then one of these conditions applies recursively to the contained expression.</p></li>
<li><p>If <code>e</code> is a conditional expression, then for each of the second and third operands, one of these conditions applies recursively.</p></li>
<li><p><strong>If <code>e</code> is a <code>switch</code> expression, then for each of its result expressions, one of these conditions applies recursively.</strong></p></li>
</ul>
<p>A method <code>m1</code> is <em>strictly more specific</em> than another method <code>m2</code> if and only if <code>m1</code> is more specific than <code>m2</code> and <code>m2</code> is not more specific than <code>m1</code>.</p>
<p>A method is said to be <em>maximally specific</em> for a method invocation if it is accessible and applicable and there is no other method that is applicable and accessible that is strictly more specific.</p>
<p>If there is exactly one maximally specific method, then that method is in fact the <em>most specific method</em>; it is necessarily more specific than any other accessible method that is applicable. It is then subjected to some further compile-time checks as specified in <a href="../../se10/html/jls-15.html#jls-15.12.3">15.12.3</a>.</p>
<p>It is possible that no method is the most specific, because there are two or more methods that are maximally specific. In this case:</p>
<ul>
<li><p>If all the maximally specific methods have override-equivalent signatures (<a href="../../se10/html/jls-8.html#jls-8.4.2">8.4.2</a>), then:</p>
<ul>
<li><p>If exactly one of the maximally specific methods is concrete (that is, non-<code>abstract</code> or default), it is the most specific method.</p></li>
<li><p>Otherwise, if all the maximally specific methods are <code>abstract</code> or default, and the signatures of all of the maximally specific methods have the same erasure (<a href="../../se10/html/jls-4.html#jls-4.6">4.6</a>), then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that have the most specific return type.</p>
<p>In this case, the most specific method is considered to be <code>abstract</code>. Also, the most specific method is considered to throw a checked exception if and only if that exception or its erasure is declared in the <code>throws</code> clauses of each of the maximally specific methods.</p></li>
</ul></li>
<li><p>Otherwise, the method invocation is <em>ambiguous</em>, and a compile-time error occurs.</p></li>
</ul>
<h2 id="jep325-15.15">15.15 Unary <del>Operators</del> <strong>Expressions</strong></h2>
<p>The operators <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and the cast operator (<a href="../../se10/html/jls-15.html#jls-15.16">15.16</a>) are called the <em>unary operators</em><del>.</del><strong>, which are used to form unary expressions. In addition, the <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) is treated grammatically as a unary expression.</strong></p>
<blockquote>
<p><em>UnaryExpression</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>PreIncrementExpression</em><br />
<em>PreDecrementExpression</em><br />
<code>+</code> <em>UnaryExpression</em><br />
<code>-</code> <em>UnaryExpression</em><br />
<em>UnaryExpressionNotPlusMinus</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>PreIncrementExpression</em>:</p>
<blockquote>
<p><code>++</code> <em>UnaryExpression</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>PreDecrementExpression</em>:</p>
<blockquote>
<p><code>--</code> <em>UnaryExpression</em></p>
</blockquote>
</blockquote>
<blockquote>
<p><em>UnaryExpressionNotPlusMinus</em>:</p>
<blockquote>
<p><em>PostfixExpression</em><br />
<code>~</code> <em>UnaryExpression</em><br />
<code>!</code> <em>UnaryExpression</em><br />
<em>CastExpression</em><br />
<strong><em>SwitchExpression</em></strong></p>
</blockquote>
</blockquote>
<div class="editorial">
<p>The following production from (<a href="../../se10/html/jls-15.html#jls-15.16">15.16</a>) is shown here for convenience:</p>
<blockquote>
<p><em>CastExpression</em>:</p>
<blockquote>
<p><code>(</code> <em>PrimitiveType</em> <code>)</code> <em>UnaryExpression</em><br />
<code>(</code> <em>ReferenceType</em> <em>{</em> <em>AdditionalBound</em> <em>}</em> <code>)</code> <em>UnaryExpressionNotPlusMinus</em><br />
<code>(</code> <em>ReferenceType</em> <em>{</em> <em>AdditionalBound</em> <em>}</em> <code>)</code> <em>LambdaExpression</em></p>
</blockquote>
</blockquote>
</div>
Expressions with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.
<div class="editorial">
<p>This portion of the grammar contains some tricks to avoid two potential syntactic ambiguities.</p>
<p>The first potential ambiguity would arise in expressions such as <code>(p)+q</code>, which looks, to a C or C++ programmer, as though it could be either a cast to type <code>p</code> of a unary <code>+</code> operating on <code>q</code>, or a binary addition of two quantities <code>p</code> and <code>q</code>. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether <code>p</code> is the name of a type or the name of a variable.</p>
<p>Java takes a different approach. The result of the <code>+</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a cast of a unary expression. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a binary arithmetic operation. Similar remarks apply to the <code>-</code> operator. The grammar shown above splits <em>CastExpression</em> into two cases to make this distinction. The nonterminal <em>UnaryExpression</em> includes all unary operators, but the nonterminal <em>UnaryExpressionNotPlusMinus</em> excludes uses of all unary operators that could also be binary operators, which in Java are <code>+</code> and <code>-</code>.</p>
<p>The second potential ambiguity is that the expression <code>(p)++</code> could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in <code>(p)++q</code>. As before, parsers for C and C++ know whether <code>p</code> is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when <code>++</code> is the lookahead token, whether <code>(p)</code> should be considered a <em>Primary</em> expression or left alone for later consideration as part of a <em>CastExpression</em>.</p>
<p>In Java, the result of the <code>++</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a cast of a prefix increment expression, and there had better be an operand such as <code>q</code> following the <code>++</code>. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a postfix increment of <code>p</code>. Similar remarks apply to the <code>--</code> operator. The nonterminal <em>UnaryExpressionNotPlusMinus</em> therefore also excludes uses of the prefix operators <code>++</code> and <code>--</code>.</p>
</div>
<h2 id="jep325-15.25">15.25. Conditional Operator <code>? :</code></h2>
<p>The conditional operator <code>? :</code> uses the boolean value of one expression to decide which of two other expressions should be evaluated.</p>
<blockquote>
<p><em>ConditionalExpression</em>:</p>
</blockquote>
<blockquote>
<blockquote>
<p><em>ConditionalOrExpression</em><br />
<em>ConditionalOrExpression</em> <code>?</code> <em>Expression</em> <code>:</code> <em>ConditionalExpression</em><br />
<em>ConditionalOrExpression</em> <code>?</code> <em>Expression</em> <code>:</code> <em>LambdaExpression</em></p>
</blockquote>
</blockquote>
<p>The conditional operator is syntactically right-associative (it groups right-to-left). Thus, <code>a?b:c?d:e?f:g</code> means the same as <code>a?b:(c?d:(e?f:g))</code>.</p>
<p>The conditional operator has three operand expressions. <code>?</code> appears between the first and second expressions, and <code>:</code> appears between the second and third expressions.</p>
<p>The first expression must be of type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.</p>
<p>It is a compile-time error for either the second or the third operand expression to be an invocation of a <code>void</code> method.</p>
<div style="editorial">
<p>In fact, by the grammar of expression statements (<a href="../../se10/html/jls-14.html#jls-14.8">14.8</a>), it is not permitted for a conditional expression to appear in any context where an invocation of a <code>void</code> method could appear.</p>
</div>
<p>There are three kinds of conditional expressions, classified according to the second and third operand expressions: <em>boolean conditional expressions</em>, <em>numeric conditional expressions</em>, and <em>reference conditional expressions</em>. The classification rules are as follows:</p>
<ul>
<li><p>If both the second and the third operand expressions are <em>boolean expressions</em>, the conditional expression is a boolean conditional expression.</p>
<p>For the purpose of classifying a conditional, the following expressions are boolean expressions:</p>
<ul>
<li><p>An expression of a standalone form (<a href="switch-expressions.html#jep325-15.2">15.2</a>) that has type <code>boolean</code> or <code>Boolean</code>.</p></li>
<li><p>A parenthesized <code>boolean</code> expression (<a href="../../se10/html/jls-15.html#jls-15.8.5">15.8.5</a>).</p></li>
<li><p>A class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>) for class <code>Boolean</code>.</p></li>
<li><p>A method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>) for which the chosen most specific method (<a href="switch-expressions.html#jep325-15.12.2.5">15.12.2.5</a>) has return type <code>boolean</code> or <code>Boolean</code>.</p>
<div class="editorial">
<p>Note that, for a generic method, this is the type <em>before</em> instantiating the method’s type arguments.</p>
</div></li>
<li><p>A <code>boolean</code> conditional expression.</p></li>
<li><p><strong>A <code>switch</code> expression whose result expressions all have type <code>boolean</code> or <code>Boolean</code>.</strong></p></li>
</ul></li>
<li><p>If both the second and the third operand expressions are <em>numeric expressions</em>, the conditional expression is a numeric conditional expression.</p>
<p>For the purpose of classifying a conditional, the following expressions are numeric expressions:</p>
<ul>
<li><p>An expression of a standalone form (<a href="switch-expressions.html#jep325-15.2">15.2</a>) with a type that is convertible to a numeric type (<a href="../../se10/html/jls-4.html#jls-4.2">4.2</a>, <a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p></li>
<li><p>A parenthesized numeric expression (<a href="../../se10/html/jls-15.html#jls-15.8.5">15.8.5</a>).</p></li>
<li><p>A class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>) for a class that is convertible to a numeric type.</p></li>
<li><p>A method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>) for which the chosen most specific method (<a href="switch-expressions.html#jep325-15.12.2.5">15.12.2.5</a>) has a return type that is convertible to a numeric type.</p></li>
<li><p>A numeric conditional expression.</p></li>
<li><p><strong>A <code>switch</code> expression whose result expressions all have types that are convertible to a numeric type.</strong></p></li>
</ul></li>
<li><p>Otherwise, the conditional expression is a reference conditional expression.</p></li>
</ul>
<p>The process for determining the type of a conditional expression depends on the kind of conditional expression, as outlined in the following sections.</p>
<p>The following tables summarize the rules above by giving the type of a conditional expression for all possible types of its second and third operands. bnp(..) means to apply binary numeric promotion. The form “<span class="type">T | bnp(..)” is used where one operand is a constant expression of type <code>int</code> and may be representable in type <span class="type">T, where binary numeric promotion is used if the operand is not representable in type <span class="type">T. The operand type <code>Object</code> means any reference type other than the <code>null</code> type and the eight wrapper classes <code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>.</p>
<div class="editorial">
<p>[Editorial note: Tables 15.25.A-E will appear here unchanged in the final spec. Not reproduced in this document for brevity.]</p>
</div>
<p>At run time, the first operand expression of the conditional expression is evaluated first. If necessary, unboxing conversion is performed on the result.</p>
<p>The resulting <code>boolean</code> value is then used to choose either the second or the third operand expression:</p>
<ul>
<li><p>If the value of the first operand is <code>true</code>, then the second operand expression is chosen.</p></li>
<li><p>If the value of the first operand is <code>false</code>, then the third operand expression is chosen.</p></li>
</ul>
<p>The chosen operand expression is then evaluated and the resulting value is converted to the type of the conditional expression as determined by the rules stated below.</p>
<p>This conversion may include boxing or unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.7">5.1.7</a>, <a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p>
<p>The operand expression not chosen is not evaluated for that particular evaluation of the conditional expression.</p>
<h2 id="jep325-15.28">15.28. <code>switch</code> Expressions</h2>
<div class="editorial">
<p>[Editorial note: This is a new section. The existing section 15.28 on constant expressions is renumbered as 15.29.]</p>
</div>
<p>A <code>switch</code> expression is the expression analogue of the <code>switch</code> statement (<a href="switch-expressions.html#jep325-14.11">14.11</a>). It consists of a <em>selector expression</em> and a <em>switch block</em> (<a href="switch-expressions.html#jep325-14.11.1">14.11.1</a>). A <code>switch</code> expression matches the value of the selector expression against the switch labels associated with the switch block to determine which code contained in the switch block to execute to return a value. In contrast to a <code>switch</code> statement, the switch block is checked to ensure that the <code>switch</code> expression either completes normally with a value or completes abruptly.</p>
<blockquote>
<p><em>SwitchExpression</em>:</p>
<blockquote>
<p><code>switch</code> <code>(</code> <em>Expression</em> <code>)</code> <em>SwitchBlock</em></p>
</blockquote>
</blockquote>
<p>The type of the selector expression must be <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>Character</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>String</code>, or an enum type (<a href="../../se10/html/jls-8.html#jls-8.9">8.9</a>), or a compile-time error occurs.</p>
<h3 id="jep325-15.28.1">15.28.1 The Switch Block of a <code>switch</code> Expression</h3>
<p>Given a <code>switch</code> expression, all of the following must be true or a compile-time error occurs:</p>
<ul>
<li><p>The switch block must not be empty.</p></li>
<li><p>The switch block must be compatible with the type of the selector expression.</p></li>
<li><p>No two of the <code>case</code> constants associated with the switch block may have the same value.</p></li>
<li><p>Either there is a <code>default</code> label associated with the switch block; or if the type of the selector expression is an enum type, then the set of all the <code>case</code> constants associated with the switch block must contain all the enum constants of that enum type.</p></li>
<li><p>If the switch block consists of switch labeled rules, then any switch labeled block (<a href="switch-expressions.html#jep325-14.11.1">14.11.1</a>) must complete abruptly.</p></li>
<li><p>If the switch block consists of switch labeled statement groups, then the last statement in the switch block must complete abruptly, and the switch block must not have any switch labels after the last switch labeled statement group.</p></li>
</ul>
<div class="editorial">
<p>Switch labeled rules in <code>switch</code> expressions differ from those in <code>switch</code> statements (<a href="switch-expressions.html#jep325-14.11.2">14.11.2</a>). In <code>switch</code> expressions they may be any switch labeled expression, whereas in <code>switch</code> statements they must be switch labeled <em>statement</em> expressions (<a href="../../se10/html/jls-14.html#jls-14.8">14.8</a>).</p>
</div>
<!---Typing --->
<p>The <em>result expressions</em> of a <code>switch</code> expression are determined as follows:</p>
<ul>
<li>If the switch block consists of switch labeled rules, then each is considered in turn:
<ul>
<li>if it is a switch labeled expression, then this expression is a result expression of the <code>switch</code> expression.</li>
<li>if it is a switch labeled block, then every expression immediately contained in a value <code>break</code> statement in the block whose break target is the given <code>switch</code> expression is a result expression of the <code>switch</code> expression</li>
</ul></li>
<li>If the switch block consists of switch labeled statement groups, then every expression immediately contained in a value <code>break</code> statement in the block whose break target is the given <code>switch</code> expression is a result expression of the <code>switch</code> expression.</li>
</ul>
<p>It is a compile-time error if a <code>switch</code> expression has no result expressions.</p>
<p>A <code>switch</code> expression is a poly expression if it appears in an assignment context or an invocation context (<a href="../../se10/html/jls-5.html#jls-5.2">5.2</a>, <a href="../../se10/html/jls-5.html#jls-5.3">5.3</a>). Otherwise, it is a standalone expression.</p>
<p>Where a poly <code>switch</code> expression appears in a context of a particular kind with target type <em>T</em>, its result expressions similarly appear in a context of the same kind with target type <em>T</em>.</p>
<p>A poly <code>switch</code> expression is compatible with a target type <em>T</em> if each of its result expressions is compatible with <em>T</em>.</p>
<p>The type of a poly <code>switch</code> expression is the same as its target type.</p>
<p>The type of a standalone <code>switch</code> expression is determined as follows:</p>
<ul>
<li><p>If the result expressions all have the same type (which may be the <code>null</code> type), then that is the type of the <code>switch</code> expression.</p></li>
<li><p>Otherwise, if the type of each result expression is <code>boolean</code> or <code>Boolean</code>, an unboxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>) is applied to each result expression of type <code>Boolean</code>, and the <code>switch</code> expression has type <code>boolean</code>.</p></li>
<li><p>Otherwise, if the type of each result expression is convertible to a numeric type (<a href="../../se10/html/jls-5.html#jls-5.1.8">5.1.8</a>), the type of the <code>switch</code> expression is given by numeric promotion (<a href="switch-expressions.html#jep325-5.6.3">5.6.3</a>) applied to the result expressions.</p></li>
<li><p>Otherwise, boxing conversion (<a href="../../se10/html/jls-5.html#jls-5.1.7">5.1.7</a>) is applied to each result expression that has a primitive type, after which the type of the <code>switch</code> expression is the result of applying capture conversion (<a href="../../se10/html/jls-5.html#jls-5.1.10">5.1.10</a>) to the least upper bound (<a href="../../se10/html/jls-4.html#jls-4.10.4">4.10.4</a>) of the types of the result expressions.</p></li>
</ul>
<h3 id="jep325-15.28.2">15.28.2 Execution of a <code>switch</code> Expression</h3>
<p>When the <code>switch</code> expression is executed, first the selector expression is evaluated; exactly one of three outcomes are possible.</p>
<ol type="1">
<li><p>If evaluation of the selector expression completes abruptly for some reason, the <code>switch</code> expression completes abruptly for the same reason.</p></li>
<li><p>If the selector expression evaluates to <code>null</code>, then a <code>NullPointerException</code> is thrown and the entire <code>switch</code> expression completes abruptly for that reason.</p></li>
<li><p>Otherwise, execution continues by determining if a switch label associated with the switch block matches the value of the selector expression.</p>
<p>If no switch label matches, then an <code>IncompatibleClassChangeError</code> is thrown and the entire <code>switch</code> expression completes abruptly for that reason.</p>
<p>If a switch label matches, then one of the following applies:</p>
<ul>
<li>If it labels an expression, then this expression is evaluated. If the result of evaluation is a value, then the <code>switch</code> expression completes normally with the same value.</li>
<li>If it labels a statement, then the statement is executed.</li>
<li>Otherwise, all the statements in the switch block after the matching switch label are executed in order.</li>
</ul></li>
</ol>
<p>If execution of any statement or expression completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If execution of a expression completes abruptly for a reason, then the <code>switch</code> expression completes abruptly for the same reason.</p></li>
<li><p>If execution of a statement completes abruptly for the reason of a <code>break</code> with value <em>V</em>, then the <code>switch</code> expression completes normally and the value of the <code>switch</code> expression is <em>V</em>.</p></li>
<li><p>If execution of a statement completes abruptly for any reason other than a <code>break</code> with value, then the <code>switch</code> expression completes abruptly for the same reason.</p></li>
</ul>
<h2 id="jep325-15.29"><del>15.28</del><strong>15.29</strong>. Constant Expressions</h2>
<div class="editorial">
<p>[Editorial note: This section is the current 15.28 renumbered as 15.29.]</p>
</div>
<blockquote>
<p><del><em>ConstantExpression</em>:</del></p>
</blockquote>
<blockquote>
<blockquote>
<p><del><em>Expression</em></del></p>
</blockquote>
</blockquote>
<p>A <em>constant expression</em> is an expression denoting a value of primitive type or a <code>String</code> that does not complete abruptly and is composed using only the following:</p>
<ul>
<li><p>Literals of primitive type and literals of type <code>String</code> (<a href="../../se10/html/jls-3.html#jls-3.10.1">3.10.1</a>, <a href="../../se10/html/jls-3.html#jls-3.10.2">3.10.2</a>, <a href="../../se10/html/jls-3.html#jls-3.10.3">3.10.3</a>, <a href="../../se10/html/jls-3.html#jls-3.10.4">3.10.4</a>, <a href="../../se10/html/jls-3.html#jls-3.10.5">3.10.5</a>)</p></li>
<li><p>Casts to primitive types and casts to type <code>String</code> (<a href="../../se10/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The unary operators <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code> (but not <code>++</code> or <code>--</code>) (<a href="../../se10/html/jls-15.html#jls-15.15.3">15.15.3</a>, <a href="../../se10/html/jls-15.html#jls-15.15.4">15.15.4</a>, <a href="../../se10/html/jls-15.html#jls-15.15.5">15.15.5</a>, <a href="../../se10/html/jls-15.html#jls-15.15.6">15.15.6</a>)</p></li>
<li><p>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> (<a href="../../se10/html/jls-15.html#jls-15.17">15.17</a>)</p></li>
<li><p>The additive operators <code>+</code> and <code>-</code> (<a href="../../se10/html/jls-15.html#jls-15.18">15.18</a>)</p></li>
<li><p>The shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> (<a href="../../se10/html/jls-15.html#jls-15.19">15.19</a>)</p></li>
<li><p>The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (but not <code>instanceof</code>) (<a href="../../se10/html/jls-15.html#jls-15.20">15.20</a>)</p></li>
<li><p>The equality operators <code>==</code> and <code>!=</code> (<a href="../../se10/html/jls-15.html#jls-15.21">15.21</a>)</p></li>
<li><p>The bitwise and logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> (<a href="../../se10/html/jls-15.html#jls-15.22">15.22</a>)</p></li>
<li><p>The conditional-and operator <code>&amp;&amp;</code> and the conditional-or operator <code>||</code> (<a href="../../se10/html/jls-15.html#jls-15.23">15.23</a>, <a href="../../se10/html/jls-15.html#jls-15.24">15.24</a>)</p></li>
<li><p>The ternary conditional operator <code>? :</code> (<a href="switch-expressions.html#jep325-15.25">15.25</a>)</p></li>
</ul>
<!--
 Not for now
-   **The `switch` expression ([15.28])**
-->
<ul>
<li><p>Parenthesized expressions (<a href="../../se10/html/jls-15.html#jls-15.8.5">15.8.5</a>) whose contained expression is a constant expression.</p></li>
<li><p>Simple names (<a href="../../se10/html/jls-6.html#jls-6.5.6.1">6.5.6.1</a>) that refer to constant variables (<a href="../../se10/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p></li>
<li><p>Qualified names (<a href="../../se10/html/jls-6.html#jls-6.5.6.2">6.5.6.2</a>) of the form <em>TypeName</em> <code>.</code> <em>Identifier</em> that refer to constant variables (<a href="../../se10/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p></li>
</ul>
<p>Constant expressions of type <code>String</code> are always “interned” so as to share unique instances, using the method <code>String.intern</code>.</p>
<p>A constant expression is always treated as FP-strict (<a href="../../se10/html/jls-15.html#jls-15.4">15.4</a>), even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.</p>
<div class="editorial">
<p>Constant expressions are used as <code>case</code> labels in <code>switch</code> statements <strong>and <code>switch</code> expressions</strong> (<a href="switch-expressions.html#jep325-14.11">14.11</a>, <strong><a href="switch-expressions.html#jep325-15.28">15.28</a></strong>) and have a special significance for assignment conversion (<a href="../../se10/html/jls-5.html#jls-5.2">5.2</a>) and initialization of a class or interface (<a href="../../se10/html/jls-14.html#jls-12.4.2">12.4.2</a>). They may also govern the ability of a <code>while</code>, <code>do</code>, or <code>for</code> statement to complete normally (<a href="switch-expressions.html#jep325-14.21">14.21</a>), and the type of a conditional operator <code>? :</code> with numeric operands.</p>
<p><em>Example <del>15.28-1</del><strong>15.29-1</strong>. Constant Expressions</em></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="kw">true</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">(<span class="dt">short</span>)(<span class="dv">1</span>*<span class="dv">2</span>*<span class="dv">3</span>*<span class="dv">4</span>*<span class="dv">5</span>*<span class="dv">6</span>)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="bu">Integer</span>.<span class="fu">MAX_VALUE</span> / <span class="dv">2</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="fl">2.0</span> * <span class="bu">Math</span>.<span class="fu">PI</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="st">&quot;The integer &quot;</span> + <span class="bu">Long</span>.<span class="fu">MAX_VALUE</span> + <span class="st">&quot; is mighty big.&quot;</span></a></code></pre></div>
</div>
<!---------------------- Chapter 16 -------------------------------->
<div class="editorial">
<p>[Editorial note: Existing section 16.1.7 renumbered to 16.1.9, 16.1.8 renumbered to 16.1.10, 16.1.9 renumbered to 16.1.11, and 16.1.10 renumbered to 16.1.12.]</p>
</div>
<h3 id="jep325-16.1.7">16.1.7. <code>switch</code> Expression</h3>
<div class="editorial">
<p>[Editorial note: This is a new subsection.]</p>
</div>
<p><strong>Suppose that the switch expression has result expressions <code>e1</code>, …, <code>en</code>, all of which are boolean-valued.</strong></p>
<p><strong>The following rules apply only if the switch block of a <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) consists of switch labeled statement groups:</strong></p>
<ul>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression when true iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, <code>V</code> is definitely assigned after <code>e</code> when true.</strong></p></li>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression when false iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, <code>V</code> is definitely assigned after <code>e</code> when false.</strong></p></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression when true iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code> when true.</strong></p></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression when false iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code> when false.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the selector expression iff <code>V</code> is [un]assigned before the <code>switch</code> statement.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the first statement of the first switch labeled statement group in the switch block iff <code>V</code> is [un]assigned after the selector expression.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the first statement of any switch labeled statement group other than the first iff <code>V</code> is [un]assigned after the selector expression and <code>V</code> is [un]assigned after the preceding statement.</strong></p></li>
</ul>
<p><strong>The following rules apply only if the switch block of a <code>switch</code> expression consists of switch labeled rules:</strong></p>
<ul>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression when true iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely assigned after <code>e</code> when true.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, <code>V</code> is definitely assigned after <code>e</code> when true.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression when false iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely assigned after <code>e</code> when false.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, <code>V</code> is definitely assigned after <code>e</code> when false.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression when true iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely unassigned after <code>e</code> when true .</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code> when true.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression when false iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely unassigned after <code>e</code> when false.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code> when false.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is [un]assigned before any switch labeled expression or statement in the switch block iff <code>V</code> is [un]assigned after the selector expression.</strong></p></li>
</ul>
<h3 id="jep325-16.1.8">16.1.8 <code>switch</code> Expression</h3>
<div class="editorial">
<p>[Editorial note: This is a new subsection.]</p>
</div>
<p><strong>Suppose that the switch expression has result expressions <code>e1</code>, …, <code>en</code>, not all of which are boolean-valued.</strong></p>
<p><strong>The following rules apply only if the switch block of a <code>switch</code> expression (<a href="switch-expressions.html#jep325-15.28">15.28</a>) consists of switch labeled statement groups:</strong></p>
<ul>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, either <code>V</code> is definitely assigned before the value <code>break</code> statement or <code>V</code> is definitely assigned after <code>e</code>.</strong></p></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression iff for every value break statement with expression <code>e</code> in the switch block that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code>.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the selector expression iff <code>V</code> is [un]assigned before the <code>switch</code> statement.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the first statement of the first switch labeled statement group in the switch block iff <code>V</code> is [un]assigned after the selector expression.</strong></p></li>
<li><p><strong><code>V</code> is [un]assigned before the first statement of any switch labeled statement group other than the first iff <code>V</code> is [un]assigned after the selector expression and <code>V</code> is [un]assigned after the preceding statement.</strong></p></li>
</ul>
<p><strong>The following rules apply only if the switch block of a <code>switch</code> expression consists of switch labeled rules:</strong></p>
<ul>
<li><p><strong><code>V</code> is definitely assigned after a <code>switch</code> expression iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely assigned after <code>e</code>.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, either <code>V</code> is definitely assigned before the value <code>break</code> statement or <code>V</code> is definitely assigned after <code>e</code>.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is definitely unassigned after a <code>switch</code> expression iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and <code>V</code> is definitely unassigned after <code>e</code>.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and for every value <code>break</code> statement expression <code>e</code> contained in <code>b</code> that may exit the <code>switch</code> expression, <code>V</code> is definitely unassigned before the value <code>break</code> statement and <code>V</code> is definitely unassigned after <code>e</code>.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is [un]assigned before any switch labeled expression or statement in the switch block iff <code>V</code> is [un]assigned after the selector expression.</strong></p></li>
</ul>
<h3 id="jep325-16.2.9">16.2.9. <code>switch</code> Statements</h3>
<p><strong>The following rules apply only if the switch block of a <code>switch</code> statement (<a href="switch-expressions.html#jep325-14.11">14.11</a>) is empty, consists of just switch labels, or consists of switch labeled statement groups:</strong></p>
<ul>
<li><p><code>V</code> is [un]assigned after a <code>switch</code> statement <del>(<a href="switch-expressions.html#jep325-14.11">14.11</a>)</del> iff all of the following are true:</p>
<ul>
<li><p>Either there is a <code>default</code> label in the switch block or <code>V</code> is [un]assigned after the <del>switch</del> <strong>selector</strong> expression.</p></li>
<li><p>Either there are no switch labels in the switch block that do not begin a <del>block-statement-group</del> <strong>switch labeled statement group</strong> (that is, there are no switch labels immediately before the “<code>}</code>” that ends the switch block) or <code>V</code> is [un]assigned after the <del>switch</del> <strong>selector</strong> expression.</p></li>
<li><p>Either the switch block contains no <del>block-statement-groups</del> <strong>switch labeled statement groups</strong> or <code>V</code> is [un]assigned after the last <del>block-statement</del> <strong>block statement</strong> of the last <del>block-statement-group</del> <strong>switch labeled statement group</strong>.</p></li>
<li><p><code>V</code> is [un]assigned before every <code>break</code> statement that may exit the <code>switch</code> statement.</p></li>
</ul></li>
<li><p><code>V</code> is [un]assigned before the <del>switch</del> <strong>selector</strong> expression iff <code>V</code> is [un]assigned before the <code>switch</code> statement.</p></li>
</ul>
<p>If a switch block contains at least one <del>block-statement-group</del> <strong>switch labeled statement group</strong>, then the following rules also apply:</p>
<ul>
<li><p><code>V</code> is [un]assigned before the first <del>block-statement</del> <strong>block statement</strong> of the first <del>block-statement-group</del> <strong>switch labeled statement group</strong> in the switch block iff <code>V</code> is [un]assigned after the <del>switch</del> <strong>selector</strong> expression.</p></li>
<li><p><code>V</code> is [un]assigned before the first <del>block-statement</del> <strong>block statement</strong> of any <del>block-statement-group</del> <strong>switch labeled statement group</strong> other than the first iff <code>V</code> is [un]assigned after the <del>switch</del> <strong>selector</strong> expression and <code>V</code> is [un]assigned after the preceding <del>block-statement</del> <strong>block statement</strong>.</p></li>
</ul>
<p><strong>The following rules apply only if the switch block of the <code>switch</code> statement consists of switch labeled rules:</strong></p>
<ul>
<li><p><strong><code>V</code> is [un]assigned after a <code>switch</code> statement iff for every switch labeled rule one of the following is true:</strong></p>
<ul>
<li><p><strong>It is a switch labeled expression <code>e</code> and either <code>V</code> is [un]assigned after <code>e</code> or after the selector expression.</strong></p></li>
<li><p><strong>It is a switch labeled block <code>b</code> and either <code>V</code> is [un]assigned after <code>e</code> or <code>V</code> is [un]assigned before every <code>break</code> statement contained in <code>b</code> that may exit the <code>switch</code> statement.</strong></p></li>
<li><p><strong>It is a switch labeled <code>throw</code> statement.</strong></p></li>
</ul></li>
<li><p><strong><code>V</code> is [un]assigned before any switch labeled expression or statement in the switch block iff <code>V</code> is [un]assigned after the selector expression.</strong></p></li>
</ul>
<h3 id="jep325-16.2.13">16.2.13. <code>break</code>, <code>continue</code>, <code>return</code>, and <code>throw</code> Statements</h3>
<ul>
<li>By convention, we say that <code>V</code> is [un]assigned after any <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement (<a href="switch-expressions.html#jep325-14.15">14.15</a>, <a href="switch-expressions.html#jep325-14.16">14.16</a>, <a href="switch-expressions.html#jep325-14.17">14.17</a>, <a href="../../se10/html/jls-14.html#jls-14.18">14.18</a>).</li>
</ul>
<div class="editorial">
<p>The notion that a variable is “[un]assigned after” a statement or expression really means “is [un]assigned after the statement or expression completes normally”. Because a <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement never completes normally, it vacuously satisfies this notion.</p>
</div>
<ul>
<li>In a <strong>value</strong> <code>return</code> statement with <del>an</del> expression <code>e</code>, <del>or</del> a <strong>value</strong> <code>throw</code> statement with <del>an</del> expression <code>e</code>, <strong>or a value <code>break</code> statement with expression <code>e</code>,</strong> <code>V</code> is [un]assigned before <code>e</code> iff <code>V</code> is [un]assigned before the <strong>value</strong> <code>return</code><strong>,</strong> <del>or</del> <code>throw</code><strong>, or <code>break</code></strong> statement.</li>
</ul>
<!---------------------- Chapter 18 -------------------------------->
<h3 id="jep325-18.2.1">18.2.1. Expression Compatibility Constraints</h3>
<p>A constraint formula of the form ‹<em>Expression</em> → T› is reduced as follows:</p>
<ul>
<li><p>If T is a proper type, the constraint reduces to <em>true</em> if the expression is compatible in a loose invocation context with T (<a href="../../se10/html/jls-5.html#jls-5.3">5.3</a>), and <em>false</em> otherwise.</p></li>
<li><p>Otherwise, if the expression is a standalone expression (<a href="switch-expressions.html#jep325-15.2">15.2</a>) of type S, the constraint reduces to ‹S → T›.</p></li>
<li><p>Otherwise, the expression is a poly expression (<a href="switch-expressions.html#jep325-15.2">15.2</a>). The result depends on the form of the expression:</p>
<ul>
<li><p>If the expression is a parenthesized expression of the form <code>(</code> <em>Expression</em>’ <code>)</code>, the constraint reduces to ‹<em>Expression</em>’ → T›.</p></li>
<li><p>If the expression is a class instance creation expression or a method invocation expression, the constraint reduces to the bound set B<sub>3</sub> which would be used to determine the expression’s invocation type when targeting T, as defined in <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>. (For a class instance creation expression, the corresponding “method” used for inference is defined in <a href="../../se10/html/jls-15.html#jls-15.9.3">15.9.3</a>).</p>
<p>This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in T.</p></li>
<li><p>If the expression is a conditional expression of the form <code>e1</code> <code>?</code> <code>e2</code> <code>:</code> <code>e3</code>, the constraint reduces to two constraint formulas, ‹<code>e2</code> → T› and ‹<code>e3</code> → T›.</p></li>
<li><p><strong>If the expression is a <code>switch</code> expression with a set of result expressions <code>e1</code>, …, <code>en</code>, the constraint reduces to <code>n</code> constraint formulas, ‹<code>e1</code> → T›, …, ‹<code>en</code> → T›.</strong></p></li>
<li><p>If the expression is a lambda expression or a method reference expression, the result is specified below.</p></li>
</ul>
<div class="editorial">
<p>By treating nested generic method invocations as poly expressions, we improve the behavior of inference for nested invocations. For example, the following is illegal in Java SE 7 but legal in Java SE 8:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="bu">ProcessBuilder</span> b = <span class="kw">new</span> <span class="bu">ProcessBuilder</span>(<span class="bu">Collections</span>.<span class="fu">emptyList</span>());</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="co">// ProcessBuilder&#39;s constructor expects a List&lt;String&gt;</span></a></code></pre></div>
<p>When <em>both</em> the outer and the nested invocation require inference, the problem is more difficult. For example:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="bu">List</span>&lt;<span class="bu">String</span>&gt; ls = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;(<span class="bu">Collections</span>.<span class="fu">emptyList</span>());</a></code></pre></div>
<p>Our approach is to “lift” the bounds inferred for the nested invocation (simply { α <code>&lt;:</code> <code>Object</code> } in the case of <code>emptyList</code>) into the outer inference process (in this case, trying to infer β where the constructor is for type <code>ArrayList``&lt;</code>β<code>&gt;</code>). We also infer dependencies between the nested inference variables and the outer inference variables (the constraint ‹<code>List``&lt;</code>α<code>&gt;</code> → <code>Collection``&lt;</code>β<code>&gt;</code>› would reduce to the dependency α = β). In this way, resolution of the inference variables in the nested invocation can wait until additional information can be inferred from the outer invocation (based on the assignment target, β = <code>String</code>).</p>
</div></li>
</ul>
<p>A constraint formula of the form ‹<em>LambdaExpression</em> → T›, where T mentions at least one inference variable, is reduced as follows:</p>
<ul>
<li><p>If T is not a functional interface type (<a href="../../se10/html/jls-9.html#jls-9.8">9.8</a>), the constraint reduces to <em>false</em>.</p></li>
<li><p>Otherwise, let T’ be the ground target type derived from T, as specified in <a href="../../se10/html/jls-15.html#jls-15.27.3">15.27.3</a>. If <a href="../../se10/html/jls-18.html#jls-18.5.3">18.5.3</a> is used to derive a functional interface type which is parameterized, then the test that F<code>&lt;</code>A’<sub>1</sub>, …, A’<sub>m</sub><code>&gt;</code> is a subtype of F<code>&lt;</code>A<sub>1</sub>, …, A<sub>m</sub><code>&gt;</code> is not performed (instead, it is asserted with a constraint formula below). Let the target function type for the lambda expression be the function type of T’. Then:</p>
<ul>
<li><p>If no valid function type can be found, the constraint reduces to <em>false</em>.</p></li>
<li><p>Otherwise, the congruence of <em>LambdaExpression</em> with the target function type is asserted as follows:</p>
<ul>
<li><p>If the number of lambda parameters differs from the number of parameter types of the function type, the constraint reduces to <em>false</em>.</p></li>
<li><p>If the lambda expression is implicitly typed and one or more of the function type’s parameter types is not a proper type, the constraint reduces to <em>false</em>.</p>
<p>This condition never arises in practice, due to the handling of implicitly typed lambda expressions in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a> and the substitution applied to the target type in <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>.</p></li>
<li><p>If the function type’s result is <code>void</code> and the lambda body is neither a statement expression nor a void-compatible block, the constraint reduces to <em>false</em>.</p></li>
<li><p>If the function type’s result is not <code>void</code> and the lambda body is a block that is not value-compatible, the constraint reduces to <em>false</em>.</p></li>
<li><p>Otherwise, the constraint reduces to all of the following constraint formulas:</p>
<ul>
<li><p>If the lambda parameters have explicitly declared types F<sub>1</sub>, …, F<sub>n</sub> and the function type has parameter types G<sub>1</sub>, …, G<sub>n</sub>, then i) for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>n</em>), ‹F<sub>i</sub> = G<sub>i</sub>›, and ii) ‹T’ <code>&lt;:</code> T›.</p></li>
<li><p>If the function type’s return type is a (non-<code>void</code>) type R, assume the lambda’s parameter types are the same as the function type’s parameter types. Then:</p>
<ul>
<li><p>If R is a proper type, and if the lambda body or some result expression in the lambda body is not compatible in an assignment context with R, then <em>false</em>.</p></li>
<li><p>Otherwise, if R is not a proper type, then where the lambda body has the form <em>Expression</em>, the constraint ‹<em>Expression</em> → R›; or where the lambda body is a block with result expressions <code>e1</code>, …, <code>em</code>, for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>m</em>), ‹<code>ei</code> → R›.</p></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<div class="editorial">
<p>The key piece of information to derive from a compatibility constraint involving a lambda expression is the set of bounds on inference variables appearing in the target function type’s return type. This is crucial, because functional interfaces are often generic, and many methods operating on these types are generic, too.</p>
<p>In the simplest case, a lambda expression may simply provide a lower bound for an inference variable:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb22-1" data-line-number="1">&lt;T&gt; <span class="bu">List</span>&lt;T&gt; <span class="fu">makeThree</span>(Factory&lt;T&gt; factory) { <span class="kw">... </span>}</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="bu">String</span> s = <span class="fu">makeThree</span>(() -&gt; <span class="st">&quot;abc&quot;</span>).<span class="fu">get</span>(<span class="dv">2</span>);</a></code></pre></div>
<p>In more complex cases, a result expression may be a poly expression - perhaps even another lambda expression - and so the inference variable might be passed through multiple constraint formulas with different target types before a bound is produced.</p>
<p>Most of the work described in this section precedes assertions about the result expressions; its purpose is to derive the lambda expression’s function type, and to check for expressions that are clearly disqualified from compatibility.</p>
<p>We do <em>not</em> attempt to produce bounds on inference variables that appear in the target function type’s <code>throws</code> clause. This is because exception containment is not part of compatibility (<a href="../../se10/html/jls-15.html#jls-15.27.3">15.27.3</a>) - in particular, it must not influence method applicability (<a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a>). However, we <em>do</em> get bounds on these variables later, because invocation type inference (<a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>) produces exception containment constraint formulas ([18.2.5]).</p>
<p>Note that if the target type is an inference variable, or if the target type’s parameter types contain inference variables, we produce <em>false</em>. During invocation type inference (<a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>), extra substitutions are performed in order to instantiate these inference variables, thus avoiding this scenario. (In other words, reduction will, in practice, never be “invoked” with a target type of one of these forms.)</p>
<p>Finally, note that the result expressions of a lambda expression are required by <a href="../../se10/html/jls-15.html#jls-15.27.3">15.27.3</a> to be compatible in an assignment context with the target type’s return type, R. If R is a proper type, such as <code>Byte</code> derived from <code>Function&lt;</code>α,<code>Byte``&gt;</code>, then assignability is easy enough to test, and reduction does so above. If R is not a proper type, such as α derived from <code>Function&lt;</code>String,α<code>&gt;</code>, then we make the simplifying assumption above that loose invocation compatibility will be sufficient. The difference between assignment compatibility and loose invocation compatibility is that only assignment allows narrowing of constant expressions, such as <code>Byte b = 100;</code>. Consequently, our simplifying assumption is not completeness-preserving: given target return type α and an integer literal result expression <code>100</code>, it is conceivable that α could be instantiated to <code>Byte</code>, but reduction will not in fact produce such a bound.</p>
</div>
<p>A constraint formula of the form ‹<em>MethodReference</em> → T›, where T mentions at least one inference variable, is reduced as follows:</p>
<ul>
<li><p>If T is not a functional interface type, or if T is a functional interface type that does not have a function type (<a href="../../se10/html/jls-9.html#jls-9.9">9.9</a>), the constraint reduces to <em>false</em>.</p></li>
<li><p>Otherwise, if there does not exist a potentially applicable method for the method reference when targeting T, the constraint reduces to <em>false</em>.</p></li>
<li><p>Otherwise, if the method reference is exact (<a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>), then let P<sub>1</sub>, …, P<sub>n</sub> be the parameter types of the function type of T, and let F<sub>1</sub>, …, F<sub>k</sub> be the parameter types of the potentially applicable method. The constraint reduces to a new set of constraints, as follows:</p>
<ul>
<li><p>In the special case where <em>n</em> = <em>k</em>+1, the parameter of type P<sub>1</sub> is to act as the target reference of the invocation. The method reference expression necessarily has the form <em>ReferenceType <code>::</code> [TypeArguments] Identifier</em>. The constraint reduces to ‹P<sub>1</sub> <code>&lt;:</code> <em>ReferenceType</em>› and, for all <em>i</em> (2 ≤ <em>i</em> ≤ <em>n</em>), ‹P<sub>i</sub> → F<sub>i-1</sub>›.</p>
<p>In all other cases, <em>n</em> = <em>k</em>, and the constraint reduces to, for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>n</em>), ‹P<sub>i</sub> → F<sub>i</sub>›.</p></li>
<li><p>If the function type’s result is not <code>void</code>, let R be its return type. Then, if the result of the potentially applicable compile-time declaration is <code>void</code>, the constraint reduces to <em>false</em>. Otherwise, the constraint reduces to ‹R’ → R›, where R’ is the result of applying capture conversion (<a href="../../se10/html/jls-5.html#jls-5.1.10">5.1.10</a>) to the return type of the potentially applicable compile-time declaration.</p></li>
</ul></li>
<li><p>Otherwise, the method reference is inexact, and:</p>
<ul>
<li><p>If one or more of the function type’s parameter types is not a proper type, the constraint reduces to <em>false</em>.</p>
<p>This condition never arises in practice, due to the handling of inexact method references in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a> and the substitution applied to the target type in <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>.</p></li>
<li><p>Otherwise, a search for a compile-time declaration is performed, as specified in <a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>. If there is no compile-time declaration for the method reference, the constraint reduces to <em>false</em>. Otherwise, there is a compile-time declaration, and:</p>
<ul>
<li><p>If the result of the function type is <code>void</code>, the constraint reduces to <em>true</em>.</p></li>
<li>Otherwise, if the method reference expression elides <em>TypeArguments</em>, and the compile-time declaration is a generic method, and the return type of the compile-time declaration mentions at least one of the method’s type parameters, then the constraint reduces to the bound set B<sub>3</sub> which would be used to determine the method reference’s invocation type when targeting the return type of the function type, as defined in <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a>. B<sub>3</sub> may contain new inference variables, as well as dependencies between these new variables and the inference variables in
<ol start="20" type="A">
<li></li>
</ol></li>
<li><p>Otherwise, let R be the return type of the function type, and let R’ be the result of applying capture conversion (<a href="../../se10/html/jls-5.html#jls-5.1.10">5.1.10</a>) to the return type of the invocation type (<a href="../../se10/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>) of the compile-time declaration. If R’ is <code>void</code>, the constraint reduces to <em>false</em>; otherwise, the constraint reduces to ‹R’ → R›.</p></li>
</ul>
<div class="editorial">
<p>The strategy used to determine a return type for a generic referenced method follows the same pattern as for generic method invocations (<a href="switch-expressions.html#jep325-18.2.1">18.2.1</a>). This may involve “lifting” bounds into the outer context and inferring dependencies between the two sets of inference variables.</p>
</div></li>
</ul></li>
</ul>
<h3 id="jep325-18.5.2">18.5.2. Invocation Type Inference</h3>
<p>Given a method invocation that provides no explicit type arguments, and a corresponding most specific applicable generic method <code>m</code>, the process to infer the invocation type (<a href="../../se10/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>) of the chosen method is as follows:</p>
<ul>
<li><p>Let θ be the substitution <code>[</code>P<sub>1</sub>:=α<sub>1</sub>, …, P<sub>p</sub>:=α<sub>p</sub><code>]</code> defined in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a> to replace the type parameters of <code>m</code> with inference variables.</p></li>
<li><p>Let B<sub>2</sub> be the bound set produced by reduction in order to demonstrate that <code>m</code> is applicable in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a>. (While it was necessary in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a> to demonstrate that the inference variables in B<sub>2</sub> could be resolved, in order to establish applicability, the instantiations produced by this resolution step are <em>not</em> considered part of B<sub>2</sub>.)</p></li>
<li><p>If the invocation is not a poly expression, let the bound set B<sub>3</sub> be the same as B<sub>2</sub>.</p>
<p>If the invocation is a poly expression, let the bound set B<sub>3</sub> be derived from B<sub>2</sub> as follows. Let R be the return type of <code>m</code>, let T be the invocation’s target type, and then:</p>
<ul>
<li><p>If unchecked conversion was necessary for the method to be applicable during constraint set reduction in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a>, the constraint formula ‹|R| → T› is reduced and incorporated with B<sub>2</sub>.</p></li>
<li><p>Otherwise, if R θ is a parameterized type, G<code>&lt;</code>A<sub>1</sub>, …, A<sub>n</sub><code>&gt;</code>, and one of A<sub>1</sub>, …, A<sub>n</sub> is a wildcard, then, for fresh inference variables β<sub>1</sub>, …, β<sub>n</sub>, the constraint formula ‹G<code>&lt;</code>β<sub>1</sub>, …, β<sub>n</sub><code>&gt;</code> → T› is reduced and incorporated, along with the bound G<code>&lt;</code>β<sub>1</sub>, …, β<sub>n</sub><code>&gt;</code> = capture(G<code>&lt;</code>A<sub>1</sub>, …, A<sub>n</sub><code>&gt;</code>), with B<sub>2</sub>.</p></li>
<li><p>Otherwise, if R θ is an inference variable α, and one of the following is true:</p>
<ul>
<li><p>T is a reference type, but is not a wildcard-parameterized type, and either i) B<sub>2</sub> contains a bound of one of the forms α = S or S <code>&lt;:</code> α, where S is a wildcard-parameterized type, or ii) B<sub>2</sub> contains two bounds of the forms S<sub>1</sub> <code>&lt;:</code> α and S<sub>2</sub> <code>&lt;:</code> α, where S<sub>1</sub> and S<sub>2</sub> have supertypes that are two different parameterizations of the same generic class or interface.</p></li>
<li><p>T is a parameterization of a generic class or interface, G, and B<sub>2</sub> contains a bound of one of the forms α = S or S <code>&lt;:</code> α, where there exists no type of the form G<code>&lt;</code>…<code>&gt;</code> that is a supertype of S, but the raw type |G<code>&lt;</code>…<code>&gt;</code>| is a supertype of S.</p></li>
<li><p>T is a primitive type, and one of the primitive wrapper classes mentioned in <a href="../../se10/html/jls-5.html#jls-5.1.7">5.1.7</a> is an instantiation, upper bound, or lower bound for α in B<sub>2</sub>.</p></li>
</ul>
<p>then α is resolved in B<sub>2</sub>, and where the capture of the resulting instantiation of α is U, the constraint formula ‹U → T› is reduced and incorporated with B<sub>2</sub>.</p></li>
<li><p>Otherwise, the constraint formula ‹R θ → T› is reduced and incorporated with B<sub>2</sub>.</p></li>
</ul></li>
<li><p>A set of constraint formulas, C, is constructed as follows.</p>
<p>Let <code>e1</code>, …, <code>ek</code> be the actual argument expressions of the invocation. If <code>m</code> is applicable by strict or loose invocation, let F<sub>1</sub>, …, F<sub>k</sub> be the formal parameter types of <code>m</code>; if <code>m</code> is applicable by variable arity invocation, let F<sub>1</sub>, …, F<sub>k</sub> the first <em>k</em> variable arity parameter types of <code>m</code> (<a href="../../se10/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>). Then:</p>
<ul>
<li><p>For all <em>i</em> (1 ≤ <em>i</em> ≤ <em>k</em>), if <code>ei</code> is not pertinent to applicability, C contains ‹<code>ei</code> → F<sub>i</sub> θ›.</p></li>
<li><p>For all <em>i</em> (1 ≤ <em>i</em> ≤ <em>k</em>), additional constraints may be included, depending on the form of <code>ei</code>:</p>
<ul>
<li><p>If <code>ei</code> is a <em>LambdaExpression</em>, C contains ‹<em>LambdaExpression</em> →<sub><em>throws</em></sub> F<sub>i</sub> θ›.</p>
<p>In addition, the lambda body is searched for additional constraints:</p>
<ul>
<li><p>For a block lambda body, the search is applied recursively to each result expression.</p></li>
<li><p>For a poly class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>) or a poly method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>), C contains all the constraint formulas that would appear in the set C generated by <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a> when inferring the poly expression’s invocation type.</p></li>
<li><p>For a parenthesized expression, the search is applied recursively to the contained expression.</p></li>
<li><p>For a conditional expression, the search is applied recursively to the second and third operands.</p></li>
<li><p><strong>For a <code>switch</code> expression, the search is applied recursively to each of its result expressions.</strong></p></li>
<li><p>For a lambda expression, the search is applied recursively to the lambda body.</p></li>
</ul></li>
<li><p>If <code>ei</code> is a <em>MethodReference</em>, C contains ‹<em>MethodReference</em> →<sub><em>throws</em></sub> F<sub>i</sub> θ›.</p></li>
<li><p>If <code>ei</code> is a poly class instance creation expression (<a href="../../se10/html/jls-15.html#jls-15.9">15.9</a>) or a poly method invocation expression (<a href="../../se10/html/jls-15.html#jls-15.12">15.12</a>), C contains all the constraint formulas that would appear in the set C generated by <a href="switch-expressions.html#jep325-18.5.2">18.5.2</a> when inferring the poly expression’s invocation type.</p></li>
<li><p>If <code>ei</code> is a parenthesized expression, these rules are applied recursively to the contained expression.</p></li>
<li><p>If <code>ei</code> is a conditional expression, these rules are applied recursively to the second and third operands.</p></li>
<li><p><strong>If <code>ei</code> is a <code>switch</code> expression, these rules are applied recursively to each of its result expressions.</strong></p></li>
</ul></li>
</ul></li>
<li><p>While C is not empty, the following process is repeated, starting with the bound set B<sub>3</sub> and accumulating new bounds into a “current” bound set, ultimately producing a new bound set, B<sub>4</sub>:</p>
<ol type="1">
<li><p>A subset of constraints is selected in C, satisfying the property that, for each constraint, no input variable can influence an output variable of another constraint in C. The terms <em>input variable</em> and <em>output variable</em> are defined below. An inference variable α <em>can influence</em> an inference variable β if α depends on the resolution of β (<a href="../../se10/html/jls-18.html#jls-18.4">18.4</a>), or vice versa; or if there exists a third inference variable γ such that α can influence γ and γ can influence β.</p>
<p>If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints. In this case, all constraints are considered that participate in a dependency cycle (or cycles) and do not depend on any constraints outside of the cycle (or cycles). A single constraint is selected from the considered constraints, as follows:</p>
<ul>
<li><p>If any of the considered constraints have the form ‹<em>Expression</em> → T›, then the selected constraint is the considered constraint of this form that contains the expression to the left (<a href="../../se10/html/jls-3.html#jls-3.5">3.5</a>) of the expression of every other considered constraint of this form.</p></li>
<li><p>If no considered constraint has the form ‹<em>Expression</em> → T›, then the selected constraint is the considered constraint that contains the expression to the left of the expression of every other considered constraint.</p></li>
</ul></li>
<li><p>The selected constraint(s) are removed from C.</p></li>
<li><p>The input variables α<sub>1</sub>, …, α<sub>m</sub> of all the selected constraint(s) are resolved.</p></li>
<li><p>Where T<sub>1</sub>, …, T<sub>m</sub> are the instantiations of α<sub>1</sub>, …, α<sub>m</sub>, the substitution <code>[</code>α<sub>1</sub>:=T<sub>1</sub>, …, α<sub>m</sub>:=T<sub>m</sub><code>]</code> is applied to every constraint.</p></li>
<li><p>The constraint(s) resulting from substitution are reduced and incorporated with the current bound set.</p></li>
</ol></li>
<li><p>Finally, if B<sub>4</sub> does not contain the bound <em>false</em>, the inference variables in B<sub>4</sub> are resolved.</p>
<p>If resolution succeeds with instantiations T<sub>1</sub>, …, T<sub>p</sub> for inference variables α<sub>1</sub>, …, α<sub>p</sub>, let θ’ be the substitution <code>[</code>P<sub>1</sub>:=T<sub>1</sub>, …, P<sub>p</sub>:=T<sub>p</sub><code>]</code>. Then:</p>
<ul>
<li><p>If unchecked conversion was necessary for the method to be applicable during constraint set reduction in <a href="../../se10/html/jls-18.html#jls-18.5.1">18.5.1</a>, then the parameter types of the invocation type of <code>m</code> are obtained by applying θ’ to the parameter types of <code>m</code>’s type, and the return type and thrown types of the invocation type of <code>m</code> are given by the erasure of the return type and thrown types of <code>m</code>’s type.</p></li>
<li><p>If unchecked conversion was not necessary for the method to be applicable, then the invocation type of <code>m</code> is obtained by applying θ’ to the type of <code>m</code>.</p></li>
</ul>
<p>If B<sub>4</sub> contains the bound <em>false</em>, or if resolution fails, then a compile-time error occurs.</p></li>
</ul>
<p>Invocation type inference may require carefully sequencing the reduction of constraint formulas of the forms ‹<em>Expression</em> → T›, ‹<em>LambdaExpression</em> →<sub><em>throws</em></sub> T›, and ‹<em>MethodReference</em> →<sub><em>throws</em></sub> T›. To facilitate this sequencing, the <em>input variables</em> of these constraints are defined as follows:</p>
<ul>
<li><p>For ‹<em>LambdaExpression</em> → T›:</p>
<ul>
<li><p>If T is an inference variable, it is the (only) input variable.</p></li>
<li><p>If T is a functional interface type, and a function type can be derived from T (<a href="../../se10/html/jls-15.html#jls-15.27.3">15.27.3</a>), then the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type’s parameter types; and ii) if the function type’s return type, R, is not <code>void</code>, then for each result expression <code>e</code> in the lambda body (or for the body itself if it is an expression), the input variables of ‹<code>e</code> → R›.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>LambdaExpression</em> →<sub><em>throws</em></sub> T›:</p>
<ul>
<li><p>If T is an inference variable, it is the (only) input variable.</p></li>
<li><p>If T is a functional interface type, and a function type can be derived, as described in <a href="../../se10/html/jls-15.html#jls-15.27.3">15.27.3</a>, the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type’s parameter types; and ii) the inference variables mentioned by the function type’s return type.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>MethodReference</em> → T›:</p>
<ul>
<li><p>If T is an inference variable, it is the (only) input variable.</p></li>
<li><p>If T is a functional interface type with a function type, and if the method reference is inexact (<a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>), the input variables are the inference variables mentioned by the function type’s parameter types.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>MethodReference</em> →<sub><em>throws</em></sub> T›:</p>
<ul>
<li><p>If T is an inference variable, it is the (only) input variable.</p></li>
<li><p>If T is a functional interface type with a function type, and if the method reference is inexact (<a href="../../se10/html/jls-15.html#jls-15.13.1">15.13.1</a>), the input variables are the inference variables mentioned by the function type’s parameter types and the function type’s return type.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>Expression</em> → T›, if <em>Expression</em> is a parenthesized expression:</p>
<p>Where the contained expression of <em>Expression</em> is <em>Expression</em>’, the input variables are the input variables of ‹<em>Expression</em>’ → T›.</p></li>
<li><p>For ‹<em>ConditionalExpression</em> → T›:</p>
<p>Where the conditional expression has the form <code>e1</code> <code>?</code> <code>e2</code> <code>:</code> <code>e3</code>, the input variables are the input variables of ‹<code>e2</code> → T› and ‹<code>e3</code> → T›.</p></li>
<li><p><strong>For ‹<em>SwitchExpression</em> → T›:</strong></p>
<p><strong>The input variables are the input variables of ‹<code>ei</code> → T›, where <code>ei</code> are the result expressions of the <code>switch</code> expression..</strong></p></li>
<li><p>For all other constraint formulas, there are no input variables.</p></li>
</ul>
<p>The <em>output variables</em> of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, T, that are not input variables.</p>
<div class="editorial">
<p>It is important to note that two “rounds” of inference are involved in finding the type of a method invocation. This is necessary to allow a target type to influence the type of the invocation without allowing it to influence the choice of an applicable method. The first round produces a bound set and tests that a resolution exists, but does not commit to that resolution. The second round reduces additional constraints and then performs a second resolution, this time “for real”.</p>
<p>Consider the example from the previous section:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="bu">List</span>&lt;<span class="bu">Number</span>&gt; ln = <span class="bu">Arrays</span>.<span class="fu">asList</span>(<span class="dv">1</span>, <span class="fl">2.0</span>);</a></code></pre></div>
<p>The most specific applicable method was identified as:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; <span class="bu">List</span>&lt;T&gt; <span class="fu">asList</span>(T<span class="kw">... </span>a)</a></code></pre></div>
<p>In order to complete type-checking of the method invocation, we must determine whether it is compatible with its target type, <code>List&lt;</code>Number<code>&gt;</code></code>.</p>
<p>The bound set used to demonstrate applicability in the previous section, B<sub>2</sub>, was:</p>
<p>{ α <code>&lt;:</code> <code>Object</code>, <code>Integer</code> <code>&lt;:</code> α, <code>Double</code> <code>&lt;:</code> α }</p>
<p>The new constraint formula set is as follows:</p>
<p>{ ‹<code>List&lt;</code>α<code>&gt;</code></code> → <code>List&lt;</code>Number<code>&gt;</code></code>› }</p>
<p>This compatibility constraint produces an equality bound for α, which is included in the new bound set, B<sub>3</sub>:</p>
<p>{ α <code>&lt;:</code> <code>Object</code>, <code>Integer</code> <code>&lt;:</code> α, <code>Double</code> <code>&lt;:</code> α, α = <code>Number</code> }</p>
<p>These bounds are trivially resolved:</p>
<p>α = <code>Number</code></p>
<p>Finally, we perform a substitution on the declared return type of <code>asList</code> to determine that the method invocation has type <code>List&lt;</code>Number<code>&gt;</code></code>; clearly, this is compatible with the target type.</p>
<p>This inference strategy is different than the Java SE 7 Edition of <em>The Java® Language Specification</em>, which would have instantiated α based on its lower bounds (before even considering the invocation’s target type), as we did in the previous section. This would result in a type error, since the resulting type is not a subtype of <code>List&lt;</code>Number<code>&gt;</code></code>.</p>
<p>Under various special circumstances, based on the bounds appearing in B<sub>2</sub>, we eagerly resolve an inference variable that appears as the return type of the invocation. This is to avoid unfortunate situations in which the usual constraint, ‹R θ → T›, is not completeness-preserving. It is, unfortunately, possible that by eagerly resolving the variable, we are unable to make use of bounds that would be inferred later. It is also possible that, in some cases, bounds that will later be inferred from the invocation arguments (such as implicitly typed lambda expressions) would have caused a different outcome if they had been present in B<sub>2</sub>. Despite these limitations, the strategy allows for reasonable outcomes in typical use cases, and is backwards compatible with the algorithm in the Java SE 7 Edition of <em>The Java® Language Specification</em>.</p>
</div>
<h3 id="jep325-18.5.4">18.5.4. More Specific Method Inference</h3>
<p>When testing that one applicable method is <em>more specific</em> than another (<a href="switch-expressions.html#jep325-15.12.2.5">15.12.2.5</a>), where the second method is generic, it is necessary to test whether some instantiation of the second method’s type parameters can be inferred to make the first method more specific than the second.</p>
<p>Let <code>m1</code> be the first method and <code>m2</code> be the second method. Where <code>m2</code> has type parameters P<sub>1</sub>, …, P<sub>p</sub>, let α<sub>1</sub>, …, α<sub>p</sub> be inference variables, and let θ be the substitution <code>[</code>P<sub>1</sub>:=α<sub>1</sub>, …, P<sub>p</sub>:=α<sub>p</sub><code>]</code>.</p>
<p>Let <code>e1</code>, …, <code>ek</code> be the argument expressions of the corresponding invocation. Then:</p>
<ul>
<li><p>If <code>m1</code> and <code>m2</code> are applicable by strict or loose invocation (<a href="../../se10/html/jls-15.html#jls-15.12.2.2">15.12.2.2</a>, <a href="../../se10/html/jls-15.html#jls-15.12.2.3">15.12.2.3</a>), then let S<sub>1</sub>, …, S<sub>k</sub> be the formal parameter types of <code>m1</code>, and let T<sub>1</sub>, …, T<sub>k</sub> be the result of θ applied to the formal parameter types of <code>m2</code>.</p></li>
<li><p>If <code>m1</code> and <code>m2</code> are applicable by variable arity invocation (<a href="../../se10/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>), then let S<sub>1</sub>, …, S<sub>k</sub> be the first <em>k</em> variable arity parameter types of <code>m1</code>, and let T<sub>1</sub>, …, T<sub>k</sub> be the result of θ applied to the first <em>k</em> variable arity parameter types of <code>m2</code>.</p></li>
</ul>
<p>Note that no substitution is applied to S<sub>1</sub>, …, S<sub>k</sub>; even if <code>m1</code> is generic, the type parameters of <code>m1</code> are treated as type variables, not inference variables.</p>
<p>The process to determine if <code>m1</code> is more specific than <code>m2</code> is as follows:</p>
<ul>
<li><p>First, an initial bound set, B, is constructed from the declared bounds of P<sub>1</sub>, …, P<sub>p</sub>, as specified in <a href="../../se10/html/jls-18.html#jls-18.1.3">18.1.3</a>.</p></li>
<li><p>Second, for all <em>i</em> (1 ≤ <em>i</em> ≤ <em>k</em>), a set of constraint formulas or bounds is generated.</p>
<p>If T<sub>i</sub> is a proper type, the result is <em>true</em> if S<sub>i</sub> is more specific than T<sub>i</sub> for <code>ei</code> (<a href="switch-expressions.html#jep325-15.12.2.5">15.12.2.5</a>), and <em>false</em> otherwise. (Note that S<sub>i</sub> is always a proper type.)</p>
<p>Otherwise, if T<sub>i</sub> is not a functional interface type, the constraint formula ‹S<sub>i</sub> <code>&lt;:</code> T<sub>i</sub>› is generated.</p>
<p>Otherwise, T<sub>i</sub> is a parameterization of a functional interface, I. It must be determined whether S<sub>i</sub> satisfies the following five conditions:</p>
<ul>
<li><p>S<sub>i</sub> is a functional interface type.</p></li>
<li><p>S<sub>i</sub> is not a superinterface of I, nor a parameterization of a superinterface of I.</p></li>
<li><p>S<sub>i</sub> is not a subinterface of I, nor a parameterization of a subinterface of I.</p></li>
<li><p>If S<sub>i</sub> is an intersection type, at least one element of the intersection is not a superinterface of I, nor a parameterization of a superinterface of I.</p></li>
<li><p>If S<sub>i</sub> is an intersection type, no element of the intersection is a subinterface of I, nor a parameterization of a subinterface of I.</p></li>
</ul>
<p>If all five conditions are true, then the following constraint formulas or bounds are generated (where U<sub>1</sub> … U<sub>k</sub> and R<sub>1</sub> are the parameter types and return type of the function type of the capture of S<sub>i</sub>, and V<sub>1</sub> … V<sub>k</sub> and R<sub>2</sub> are the parameter types and return type of the function type of T<sub>i</sub>):</p>
<ul>
<li><p>If <code>ei</code> is an explicitly typed lambda expression:</p>
<ul>
<li><p>For all <em>j</em> (1 ≤ <em>j</em> ≤ <em>k</em>), ‹U<sub>j</sub> = V<sub>j</sub>›.</p></li>
<li><p>If R<sub>2</sub> is <code>void</code>, <em>true</em>.</p></li>
<li><p>Otherwise, if R<sub>1</sub> and R<sub>2</sub> are functional interface types, and neither interface is a subinterface of the other, and <code>ei</code> has at least one result expression, then these rules are applied recursively to R<sub>1</sub> and R<sub>2</sub>, for each result expression in <code>ei</code>.</p></li>
<li><p>Otherwise, if R<sub>1</sub> is a primitive type and R<sub>2</sub> is not, and <code>ei</code> has at least one result expression, and each result expression of <code>ei</code> is a standalone expression (<a href="switch-expressions.html#jep325-15.2">15.2</a>) of a primitive type, <em>true</em>.</p></li>
<li><p>Otherwise, if R<sub>2</sub> is a primitive type and R<sub>1</sub> is not, and <code>ei</code> has at least one result expression, and each result expression of <code>ei</code> is either a standalone expression of a reference type or a poly expression, <em>true</em>.</p></li>
<li><p>Otherwise, ‹R<sub>1</sub> <code>&lt;:</code> R<sub>2</sub>›.</p></li>
</ul></li>
<li><p>If <code>ei</code> is an exact method reference:</p>
<ul>
<li><p>For all <em>j</em> (1 ≤ <em>j</em> ≤ <em>k</em>), ‹U<sub>j</sub> = V<sub>j</sub>›.</p></li>
<li><p>If R<sub>2</sub> is <code>void</code>, <em>true</em>.</p></li>
<li><p>Otherwise, if R<sub>1</sub> is a primitive type and R<sub>2</sub> is not, and the compile-time declaration for <code>ei</code> has a primitive return type, <em>true</em>.</p></li>
<li><p>Otherwise if R<sub>2</sub> is a primitive type and R<sub>1</sub> is not, and the compile-time declaration for <code>ei</code> has a reference return type, <em>true</em>.</p></li>
<li><p>Otherwise, ‹R<sub>1</sub> <code>&lt;:</code> R<sub>2</sub>›.</p></li>
</ul></li>
<li><p>If <code>ei</code> is a parenthesized expression, these rules are applied recursively to the contained expression.</p></li>
<li><p>If <code>ei</code> is a conditional expression, these rules are applied recursively to each of the second and third operands.</p></li>
<li><p><strong>If <code>ei</code> is a <code>switch</code> expression, these rules are applied recursively to each of its result expressions.</strong></p></li>
<li><p>Otherwise, <em>false</em>.</p></li>
</ul>
<p>If the five constraints on S<sub>i</sub> are not satisfied, the constraint formula ‹S<sub>i</sub> <code>&lt;:</code> T<sub>i</sub>› is generated instead.</p></li>
<li><p>Third, if <code>m2</code> is applicable by variable arity invocation and has <em>k</em>+1 parameters, then where S<sub>k+1</sub> is the <em>k</em>+1’th variable arity parameter type of <code>m1</code> and T<sub>k+1</sub> is the result of θ applied to the <em>k</em>+1’th variable arity parameter type of <code>m2</code>, the constraint ‹S<sub>k+1</sub> <code>&lt;:</code> T<sub>k+1</sub>› is generated.</p></li>
<li><p>Fourth, the generated bounds and constraint formulas are reduced and incorporated with B to produce a bound set B’.</p>
<p>If B’ does not contain the bound <em>false</em>, and resolution of all the inference variables in B’ succeeds, then <code>m1</code> is more specific than <code>m2</code>.</p>
<p>Otherwise, <code>m1</code> is not more specific than <code>m2</code>.</p></li>
</ul>
<h2 id="jep325-legal">Legal Notice</h2>
<div class="legal">
<p>Copyright © 2018 Oracle America, Inc. 4150 Network Circle, Santa Clara, California 95054, U.S.A. All rights reserved.</p>
<h3 id="notice">Notice</h3>
<p>The Specification is protected by copyright and the information described therein may be protected by one or more U.S. patents, foreign patents, or pending applications. Except as provided under the following license, no part of the Specification may be reproduced in any form by any means without the prior written authorization of Oracle America, Inc. (“Oracle”) and its licensors, if any. Any use of the Specification and the information described therein will be governed by the terms and conditions of this Agreement.</p>
<p>Subject to the terms and conditions of this license, including your compliance with Paragraphs 1 and 2 below, Oracle hereby grants you a fully-paid, non-exclusive, non-transferable, limited license (without the right to sublicense) under Oracle’s intellectual property rights to:</p>
<ol type="1">
<li><p>Review the Specification for the purposes of evaluation. This includes: (i) developing implementations of the Specification for your internal, non-commercial use; (ii) discussing the Specification with any third party; and (iii) excerpting brief portions of the Specification in oral or written communications which discuss the Specification provided that such excerpts do not in the aggregate constitute a significant portion of the Technology.</p></li>
<li><p>Distribute implementations of the Specification to third parties for their testing and evaluation use, provided that any such implementation:</p>
<ol type="i">
<li><p>does not modify, subset, superset or otherwise extend the Licensor Name Space, or include any public or protected packages, classes, Java interfaces, fields or methods within the Licensor Name Space other than those required/authorized by the Specification or Specifications being implemented;</p></li>
<li><p>is clearly and prominently marked with the word “UNTESTED” or “EARLY ACCESS” or “INCOMPATIBLE” or “UNSTABLE” or “BETA” in any list of available builds and in proximity to every link initiating its download, where the list or link is under Licensee’s control; and</p></li>
<li><p>includes the following notice: “This is an implementation of an early-draft specification developed under the Java Community Process (JCP) and is made available for testing and evaluation purposes only. The code is not compatible with any specification of the JCP.”</p></li>
</ol></li>
</ol>
<p>The grant set forth above concerning your distribution of implementations of the specification is contingent upon your agreement to terminate development and distribution of your “early draft” implementation as soon as feasible following final completion of the specification. If you fail to do so, the foregoing grant shall be considered null and void.</p>
<p>No provision of this Agreement shall be understood to restrict your ability to make and distribute to third parties applications written to the Specification.</p>
<p>Other than this limited license, you acquire no right, title or interest in or to the Specification or any other Oracle intellectual property, and the Specification may only be used in accordance with the license terms set forth herein. This license will expire on the earlier of: (a) two (2) years from the date of Release listed above; (b) the date on which the final version of the Specification is publicly released; or (c) the date on which the Java Specification Request (JSR) to which the Specification corresponds is withdrawn. In addition, this license will terminate immediately without notice from Oracle if you fail to comply with any provision of this license. Upon termination, you must cease use of or destroy the Specification.</p>
<p>“Licensor Name Space” means the public class or interface declarations whose names begin with “java”, “javax”, “com.oracle” or their equivalents in any subsequent naming convention adopted by Oracle through the Java Community Process, or any recognized successors or replacements thereof.</p>
<h3 id="trademarks">Trademarks</h3>
<p>No right, title, or interest in or to any trademarks, service marks, or trade names of Oracle or Oracle’s licensors is granted hereunder. Oracle, the Oracle logo, Java are trademarks or registered trademarks of Oracle USA, Inc. in the U.S. and other countries.</p>
<h3 id="disclaimer-of-warranties">Disclaimer of Warranties</h3>
<p>THE SPECIFICATION IS PROVIDED “AS IS” AND IS EXPERIMENTAL AND MAY CONTAIN DEFECTS OR DEFICIENCIES WHICH CANNOT OR WILL NOT BE CORRECTED BY ORACLE. ORACLE MAKES NO REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTS OF THE SPECIFICATION ARE SUITABLE FOR ANY PURPOSE OR THAT ANY PRACTICE OR IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADE SECRETS OR OTHER RIGHTS. This document does not represent any commitment to release or implement any portion of the Specification in any product.</p>
<p>THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIES OR TYPOGRAPHICAL ERRORS. CHANGES ARE PERIODICALLY ADDED TO THE INFORMATION THEREIN; THESE CHANGES WILL BE INCORPORATED INTO NEW VERSIONS OF THE SPECIFICATION, IF ANY. ORACLE MAY MAKE IMPROVEMENTS AND/OR CHANGES TO THE PRODUCT(S) AND/OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANY TIME. Any use of such changes in the Specification will be governed by the then-current license for the applicable version of the Specification.</p>
<h3 id="limitation-of-liability">Limitation of Liability</h3>
<p>TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ORACLE OR ITS LICENSORS BE LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITS OR DATA, OR FOR SPECIAL, INDIRECT, CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT OF OR RELATED TO ANY FURNISHING, PRACTICING, MODIFYING OR ANY USE OF THE SPECIFICATION, EVEN IF ORACLE AND/OR ITS LICENSORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
<p>You will hold Oracle (and its licensors) harmless from any claims based on your use of the Specification for any purposes other than the limited right of evaluation as described above, and from any claims that later versions or releases of any Specification furnished to you are incompatible with the Specification provided to you under this license.</p>
<h3 id="restricted-rights-legend">Restricted Rights Legend</h3>
<p>If this Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at any tier), then the Government’s rights in the Software and accompanying documentation shall be only as set forth in this license; this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).</p>
<h3 id="report">Report</h3>
<p>You may wish to report any ambiguities, inconsistencies or inaccuracies you may find in connection with your evaluation of the Specification (“Feedback”). To the extent that you provide Oracle with any Feedback, you hereby: (i) agree that such Feedback is provided on a non-proprietary and non-confidential basis, and (ii) grant Oracle a perpetual, non-exclusive, worldwide, fully paid-up, irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof.</p>
<h3 id="general-terms">General Terms</h3>
<p>Any action related to this Agreement will be governed by California law and controlling U.S. federal law. The U.N. Convention for the International Sale of Goods and the choice of law rules of any jurisdiction will not apply.</p>
<p>The Specification is subject to U.S. export control laws and may be subject to export or import regulations in other countries. Licensee agrees to comply strictly with all such laws and regulations and acknowledges that it has the responsibility to obtain such licenses to export, re-export or import as may be required after delivery to Licensee.</p>
<p>This Agreement is the parties’ entire agreement relating to its subject matter. It supersedes all prior or contemporaneous oral or written communications, proposals, conditions, representations and warranties and prevails over any conflicting or additional terms of any quote, order, acknowledgment, or other communication between the parties relating to its subject matter during the term of this Agreement. No modification to this Agreement will be binding, unless in writing and signed by an authorized representative of each party.</p>
</div>
</body>
</html>
