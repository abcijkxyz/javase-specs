<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Consistent Class and Interface Terminology</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../resources/spec-changes.css" />
<script>window.ohcglobal || document.write('<script src="https://docs.oracle.com/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<header id="title-block-header">
<h1 class="title">Consistent Class and Interface Terminology</h1>
<p class="subtitle">Changes to the Java® Language Specification • Version 15+36</p>
</header>
<nav id="TOC" title="Table Of Contents">
<ul>
<li><a href="class-terminology-jls.html#jls-1">Chapter 1: Introduction</a><ul>
<li><a href="class-terminology-jls.html#jls-1.1">1.1 Organization of the Specification</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-6">Chapter 6: Names</a><ul>
<li><a href="class-terminology-jls.html#jls-6.1">6.1 Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-6.3">6.3 Scope of a Declaration</a></li>
<li><a href="class-terminology-jls.html#jls-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="class-terminology-jls.html#jls-6.5.4">6.5.4 Meaning of <em>PackageOrTypeNames</em></a><ul>
<li><a href="class-terminology-jls.html#jls-6.5.4.1">6.5.4.1 Simple <em>PackageOrTypeNames</em></a></li>
<li><a href="class-terminology-jls.html#jls-6.5.4.2">6.5.4.2 Qualified <em>PackageOrTypeNames</em></a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-6.5.5">6.5.5 Meaning of Type Names</a><ul>
<li><a href="class-terminology-jls.html#jls-6.5.5.1">6.5.5.1 Simple Type Names</a></li>
<li><a href="class-terminology-jls.html#jls-6.5.5.2">6.5.5.2 Qualified Type Names</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-7">Chapter 7: Packages and Modules</a><ul>
<li><a href="class-terminology-jls.html#jls-7.3">7.3 Compilation Units</a></li>
<li><a href="class-terminology-jls.html#jls-7.5">7.5 Import Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-7.5.1">7.5.1 Single-Type-Import Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-7.5.3">7.5.3 Single-Static-Import Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-7.6">7.6 Top Level <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-7.7">7.7 Module Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-7.7.4">7.7.4 Service Provision</a></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-8">Chapter 8: Classes</a><ul>
<li><a href="class-terminology-jls.html#jls-8.1">8.1 Class Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-8.1.1">8.1.1 Class Modifiers</a><ul>
<li><a href="class-terminology-jls.html#jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</a></li>
<li><a href="class-terminology-jls.html#jls-8.1.6">8.1.6 Class Body and Member Declarations</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-8.5">8.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-8.5.1">8.5.1 Static Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-8.8">8.8 Constructor Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-8.8.7">8.8.7 Constructor Body</a><ul>
<li><a href="class-terminology-jls.html#jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</a></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-8.9">8.9 Enum <del>Types</del> <strong>Classes</strong></a><ul>
<li><a href="class-terminology-jls.html#jls-8.9.1">8.9.1 Enum Constants</a></li>
<li><a href="class-terminology-jls.html#jls-8.9.2">8.9.2 Enum Body Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-8.9.3">8.9.3 Enum Members</a></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-9">Chapter 9: Interfaces</a><ul>
<li><a href="class-terminology-jls.html#jls-9.1">9.1 Interface Declarations</a><ul>
<li><a href="class-terminology-jls.html#jls-9.1.4">9.1.4 Interface Body and Member Declarations</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-9.5">9.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</a></li>
<li><a href="class-terminology-jls.html#jls-9.6">9.6 Annotation <del>Types</del> <strong>Interfaces</strong></a><ul>
<li><a href="class-terminology-jls.html#jls-9.6.1">9.6.1 Annotation <del>Type</del> Elements</a></li>
<li><a href="class-terminology-jls.html#jls-9.6.2">9.6.2 Defaults for Annotation <del>Type</del> Elements</a></li>
<li><a href="class-terminology-jls.html#jls-9.6.3">9.6.3 Repeatable Annotation <del>Types</del> <strong>Interfaces</strong></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4">9.6.4 Predefined Annotation <del>Types</del> <strong>Interfaces</strong></a><ul>
<li><a href="class-terminology-jls.html#jls-9.6.4.1">9.6.4.1 <code>@Target</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.2">9.6.4.2 <code>@Retention</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.3">9.6.4.3 <code>@Inherited</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.4">9.6.4.4 <code>@Override</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.5">9.6.4.5 <code>@SuppressWarnings</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.6">9.6.4.6 <code>@Deprecated</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.7">9.6.4.7 <code>@SafeVarargs</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.8">9.6.4.8 <code>@Repeatable</code></a></li>
<li><a href="class-terminology-jls.html#jls-9.6.4.9">9.6.4.9 <code>@FunctionalInterface</code></a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-13">Chapter 13: Binary Compatibility</a><ul>
<li><a href="class-terminology-jls.html#jls-13.1">13.1 The Form of a Binary</a></li>
<li><a href="class-terminology-jls.html#jls-13.4">13.4 Evolution of Classes</a><ul>
<li><a href="class-terminology-jls.html#jls-13.4.26">13.4.26 Evolution of <del>Enums</del> <strong>Enum Classes</strong></a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-13.5">13.5 Evolution of Interfaces</a><ul>
<li><a href="class-terminology-jls.html#jls-13.5.7">13.5.7 Evolution of Annotation <del>Types</del> <strong>Interfaces</strong></a></li>
</ul></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-15">Chapter 15: Expressions</a><ul>
<li><a href="class-terminology-jls.html#jls-15.8">15.8 Primary Expressions</a><ul>
<li><a href="class-terminology-jls.html#jls-15.8.4">15.8.4 Qualified <code>this</code></a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-15.9">15.9 Class Instance Creation Expressions</a><ul>
<li><a href="class-terminology-jls.html#jls-15.9.2">15.9.2 Determining Enclosing Instances</a></li>
</ul></li>
<li><a href="class-terminology-jls.html#jls-15.12">15.12 Method Invocation Expressions</a><ul>
<li><a href="class-terminology-jls.html#jls-15.12.1">15.12.1 Compile-Time Step 1: Determine Class or Interface to Search</a></li>
<li><a href="class-terminology-jls.html#jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se15/html">Java Language Specification</a> to clarify the usage of terms related to <em>classes</em> and <em>interfaces</em>, and more clearly distinguish them from <em>types</em>.</p>
<p>The following terminology is preferred: a <em>class or interface declaration</em> is a syntactic structure that introduces a <em>class</em> or an <em>interface</em>. Various class and interface declarations have different syntactic forms, and can appear in different contexts, per the grammar. A <em>class type</em> or an <em>interface type</em> is variable or expression type, derived from a class or an interface; these terms should be avoided when talking about the declaration. An <em>enum declaration</em> is a kind of class declaration that introduces a special kind of class, an <em>enum class</em>. An <em>annotation declaration</em> is a kind of interface declaration that introduces a special kind of interface, an <em>annotation interface</em>.</p>
<p>Changes are described with respect to existing sections of the Java Language Specification. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<h2 id="jls-1">Chapter 1: Introduction</h2>
<h3 id="jls-1.1">1.1 Organization of the Specification</h3>
<p>Chapter 2 describes grammars and the notation used to present the lexical and syntactic grammars for the language.</p>
<p>Chapter 3 describes the lexical structure of the Java programming language, which is based on C and C++. The language is written in the Unicode character set. It supports the writing of Unicode characters on systems that support only ASCII.</p>
<p>Chapter 4 describes types, values, and variables. Types are subdivided into primitive types and reference types.</p>
<p>The primitive types are defined to be the same on all machines and in all implementations, and are various sizes of two's-complement integers, single- and double-precision IEEE 754 standard floating-point numbers, a <code>boolean</code> type, and a Unicode character <code>char</code> type. Values of the primitive types do not share state.</p>
<p>Reference types are the class types, the interface types, and the array types. The reference types are implemented by dynamically created objects that are either instances of classes or arrays. Many references to each object can exist. All objects (including arrays) support the methods of the class <code>Object</code>, which is the (single) root of the class hierarchy. A predefined <code>String</code> class supports Unicode character strings. Classes exist for wrapping primitive values inside of objects. In many cases, wrapping and unwrapping is performed automatically by the compiler (in which case, wrapping is called boxing, and unwrapping is called unboxing). Class and interface declarations may be generic, that is, they may be parameterized by other reference types. Such declarations may then be invoked with specific type arguments.</p>
<p>Variables are typed storage locations. A variable of a primitive type holds a value of that exact primitive type. A variable of a class type can hold a null reference or a reference to an object whose type is that class type or any subclass of that class type. A variable of an interface type can hold a null reference or a reference to an instance of any class that implements the interface. A variable of an array type can hold a null reference or a reference to an array. A variable of class type <code>Object</code> can hold a null reference or a reference to any object, whether class instance or array.</p>
<p>Chapter 5 describes conversions and numeric promotions. Conversions change the compile-time type and, sometimes, the value of an expression. These conversions include the boxing and unboxing conversions between primitive types and reference types. Numeric promotions are used to convert the operands of a numeric operator to a common type where an operation can be performed. There are no loopholes in the language; casts on reference types are checked at run time to ensure type safety.</p>
<p>Chapter 6 describes declarations and names, and how to determine what names mean (that is, which declaration a name denotes). The Java programming language does not require classes and interfaces, or their members, to be declared before they are used. Declaration order is significant only for local variables, local classes, and the order of field initializers in a class or interface. Recommended naming conventions that make for more readable programs are described here.</p>
<p>Chapter 7 describes the structure of a program, which is organized into packages. The members of a package are classes, interfaces, and subpackages. Packages, and consequently their members, have names in a hierarchical name space; the Internet domain name system can usually be used to form unique package names. Compilation units contain declarations of the classes and interfaces that are members of a given package, and may import classes and interfaces from other packages to give them short names.</p>
<p>Packages may be grouped into modules that serve as building blocks in the construction of very large programs. The declaration of a module specifies which other modules (and thus packages, and thus classes and interfaces) are required in order to compile and run code in its own packages.</p>
<p>The Java programming language supports limitations on external access to the members of packages, classes, and interfaces. The members of a package may be accessible solely by other members in the same package, or by members in other packages of the same module, or by members of packages in different modules. Similar constraints apply to the members of classes and interfaces.</p>
<p>Chapter 8 describes classes. The members of classes are classes, interfaces, fields (variables) and methods. Class variables exist once per class. Class methods operate without reference to a specific object. Instance variables are dynamically created in objects that are instances of classes. Instance methods are invoked on instances of classes; such instances become the current object <code>this</code> during their execution, supporting the object-oriented programming style.</p>
<p>Classes support single inheritance, in which each class has a single superclass. Each class inherits members from its superclass, and ultimately from the class <code>Object</code>. Variables of a class type can reference an instance of that class or of any subclass of that class, allowing new types to be used with existing methods, polymorphically.</p>
<p>Classes support concurrent programming with <code>synchronized</code> methods. Methods declare the checked exceptions that can arise from their execution, which allows compile-time checking to ensure that exceptional conditions are handled. Objects can declare a <code>finalize</code> method that will be invoked before the objects are discarded by the garbage collector, allowing the objects to clean up their state.</p>
<p>For simplicity, the language has neither declaration &quot;headers&quot; separate from the implementation of a class nor separate type and class hierarchies.</p>
<p>A special form of classes, <del>enums</del> <strong>enum classes</strong>, support the definition of small sets of values and their manipulation in a type safe manner. Unlike enumerations in other languages, <del>enums</del> <strong>enum constants</strong> are objects and may have their own methods.</p>
<p>Chapter 9 describes interfaces. The members of interfaces are classes, interfaces, constant fields, and methods. Classes that are otherwise unrelated can implement the same interface. A variable of an interface type can contain a reference to any object that implements the interface.</p>
<p>Classes and interfaces support multiple inheritance from interfaces. A class that implements one or more interfaces may inherit instance methods from both its superclass and its superinterfaces.</p>
<p>Annotation <del>types</del> <strong>interfaces</strong> are specialized interfaces used to annotate declarations. Such annotations are not permitted to affect the semantics of programs in the Java programming language in any way. However, they provide useful input to various tools.</p>
<p>Chapter 10 describes arrays. Array accesses include bounds checking. Arrays are dynamically created objects and may be assigned to variables of type <code>Object</code>. The language supports arrays of arrays, rather than multidimensional arrays.</p>
<p>Chapter 11 describes exceptions, which are nonresuming and fully integrated with the language semantics and concurrency mechanisms. There are three kinds of exceptions: checked exceptions, run-time exceptions, and errors. The compiler ensures that checked exceptions are properly handled by requiring that a method or constructor can result in a checked exception only if the method or constructor declares it. This provides compile-time checking that exception handlers exist, and aids programming in the large. Most user-defined exceptions should be checked exceptions. Invalid operations in the program detected by the Java Virtual Machine result in run-time exceptions, such as <code>NullPointerException</code>. Errors result from failures detected by the Java Virtual Machine, such as <code>OutOfMemoryError</code>. Most simple programs do not try to handle errors.</p>
<p>Chapter 12 describes activities that occur during execution of a program. A program is normally stored as binary files representing compiled classes and interfaces. These binary files can be loaded into a Java Virtual Machine, linked to other classes and interfaces, and initialized.</p>
<p>After initialization, class methods and class variables may be used. Some classes may be instantiated to create new objects of the class type. Objects that are class instances also contain an instance of each superclass of the class, and object creation involves recursive creation of these superclass instances.</p>
<p>When an object is no longer referenced, it may be reclaimed by the garbage collector. If an object declares a finalizer, the finalizer is executed before the object is reclaimed to give the object a last chance to clean up resources that would not otherwise be released. When a class is no longer needed, it may be unloaded.</p>
<p>Chapter 13 describes binary compatibility, specifying the impact of changes to types on other types that use the changed types but have not been recompiled. These considerations are of interest to developers of types that are to be widely distributed, in a continuing series of versions, often through the Internet. Good program development environments automatically recompile dependent code whenever a type is changed, so most programmers need not be concerned about these details.</p>
<p>Chapter 14 describes blocks and statements, which are based on C and C++. The language has no <code>goto</code> statement, but includes labeled <code>break</code> and <code>continue</code> statements. Unlike C, the Java programming language requires <code>boolean</code> (or <code>Boolean</code>) expressions in control-flow statements, and does not convert types to <code>boolean</code> implicitly (except through unboxing), in the hope of catching more errors at compile time. A <code>synchronized</code> statement provides basic object-level monitor locking. A <code>try</code> statement can include <code>catch</code> and <code>finally</code> clauses to protect against non-local control transfers.</p>
<p>Chapter 15 describes expressions. This document fully specifies the (apparent) order of evaluation of expressions, for increased determinism and portability. Overloaded methods and constructors are resolved at compile time by picking the most specific method or constructor from those which are applicable.</p>
<p>Chapter 16 describes the precise way in which the language ensures that local variables are definitely set before use. While all other variables are automatically initialized to a default value, the Java programming language does not automatically initialize local variables in order to avoid masking programming errors.</p>
<p>Chapter 17 describes the semantics of threads and locks, which are based on the monitor-based concurrency originally introduced with the Mesa programming language. The Java programming language specifies a memory model for shared-memory multiprocessors that supports high-performance implementations.</p>
<p>Chapter 18 describes a variety of type inference algorithms used to test applicability of generic methods and to infer types in a generic method invocation.</p>
<p>Chapter 19 presents a syntactic grammar for the language.</p>
<h2 id="jls-6">Chapter 6: Names</h2>
<p>Names are used to refer to entities declared in a program.</p>
<p>A declared entity (<a href="class-terminology-jls.html#jls-6.1">6.1</a>) is a package, class <del>type (normal or enum)</del>, interface <del>type (normal or annotation type)</del>, member (class, interface, field, or method) of a reference type, type parameter <del>(of a class, interface, method or constructor)</del>, <del>parameter (to a method, constructor, or exception handler)</del> <strong>formal parameter, exception parameter</strong>, or local variable.</p>
<div class="editorial">
<p>There's a whole section coming up (<a href="class-terminology-jls.html#jls-6.1">6.1</a>) dedicated to enumerating all the cases. The introductory sentence for the chapter shouldn't be trying to repeat that entire enumeration. E.g., we can describe the different kinds of class declarations later.</p>
</div>
<p>Names in programs are either <em>simple</em>, consisting of a single identifier, or <em>qualified</em>, consisting of a sequence of identifiers separated by &quot;<code>.</code>&quot; tokens (<a href="../../../se14/html/jls-6.html#jls-6.2">6.2</a>).</p>
<p>Every declaration that introduces a name has a <em>scope</em> (<a href="class-terminology-jls.html#jls-6.3">6.3</a>), which is the part of the program text within which the declared entity can be referred to by a simple name.</p>
<p>A qualified name <em>N.x</em> may be used to refer to a <em>member</em> of a package or reference type, where <em>N</em> is a simple or qualified name and <em>x</em> is an identifier. If <em>N</em> names a package, then <em>x</em> is a member of that package, which is either a class or interface type or a subpackage. If <em>N</em> names a reference type or a variable of a reference type, then <em>x</em> names a member of that type, which is either a class, an interface, a field, or a method.</p>
<p>In determining the meaning of a name (<a href="../../../se14/html/jls-6.html#jls-6.5">6.5</a>), the context of the occurrence is used to disambiguate among packages, types, variables, and methods with the same name.</p>
<p>Access control (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>) can be specified in a class, interface, method, or field declaration to control when <em>access</em> to a member is allowed. Access is a different concept from scope. Access specifies the part of the program text within which the declared entity can be referred to by a qualified name. Access to a declared entity is also relevant in a field access expression (<a href="../../../se14/html/jls-15.html#jls-15.11">15.11</a>), a method invocation expression in which the method is not specified by a simple name (<a href="../../../se14/html/jls-15.html#jls-15.12">15.12</a>), a method reference expression (<a href="../../../se14/html/jls-15.html#jls-15.13">15.13</a>), or a qualified class instance creation expression (<a href="../../../se14/html/jls-15.html#jls-15.9">15.9</a>). In the absence of an access modifier, most declarations have package access, allowing access anywhere within the package that contains its declaration; other possibilities are <code>public</code>, <code>protected</code>, and <code>private</code>.</p>
<p>Fully qualified and canonical names (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>) are also discussed in this chapter.</p>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and includes an identifier (<a href="../../../se14/html/jls-3.html#jls-3.8">3.8</a>) that can be used in a name to refer to this entity. The identifier is constrained to be a type identifier when the entity being introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a href="../../../se14/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a href="../../../se14/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported <del>type</del> <strong>class or interface</strong>, declared in a single-type-import declaration or a type-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.1">7.5.1</a>, <a href="class-terminology-jls.html#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a single-static-import declaration or a static-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.3">7.5.3</a>, <a href="class-terminology-jls.html#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared in a class <del>type</del> declaration (<a href="class-terminology-jls.html#jls-8.1">8.1</a>) <strong>or an enum declaration (<a href="class-terminology-jls.html#jls-8.9">8.9</a>)</strong></p></li>
<li><p>An interface, declared in an interface <del>type</del> declaration (<a href="class-terminology-jls.html#jls-9.1">9.1</a>) <strong>or an annotation declaration (<a href="class-terminology-jls.html#jls-9.6">9.6</a>)</strong></p></li>
<li><p>A type parameter, declared as part of the declaration of a generic class, interface, method, or constructor (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="../../../se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="../../../se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="../../../se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a href="../../../se14/html/jls-8.html#jls-8.2">8.2</a>, <a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a>, <a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>, <a href="class-terminology-jls.html#jls-9.6">9.6</a>, <a href="../../../se14/html/jls-10.html#jls-10.7">10.7</a>), one of the following:</p>
<ul>
<li><p>A member class (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>)</p></li>
<li><p><del>An enum constant (<a href="class-terminology-jls.html#jls-8.9">8.9</a>)</del></p>
<div class="editorial">
<p>Enum constants are not members—they introduce implicit fields, which are members.</p>
</div></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class <del>type or enum type</del> (<a href="../../../se14/html/jls-8.html#jls-8.3">8.3</a><del>, <a href="class-terminology-jls.html#jls-8.9.2">8.9.2</a></del>)</p></li>
<li><p>A field declared in an interface <del>type or annotation type</del> (<a href="../../../se14/html/jls-9.html#jls-9.3">9.3</a><del>, <a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a></del>)</p></li>
<li><p>The field <code>length</code>, which is implicitly a member of every array type (<a href="../../../se14/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class <del>type or enum type</del> (<a href="../../../se14/html/jls-8.html#jls-8.4">8.4</a><del>, <a href="class-terminology-jls.html#jls-8.9.2">8.9.2</a></del>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an interface <del>type or annotation type</del> (<a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a><del>, <a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a></del>)</p></li>
</ul></li>
</ul></li>
<li><p><strong>An enum constant (<a href="class-terminology-jls.html#jls-8.9.1">8.9.1</a>)</strong></p></li>
<li><p><del>A parameter, one of the following:</del></p>
<ul>
<li><p><del>A formal parameter of a method or constructor of a class type or enum type (<a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="../../../se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="class-terminology-jls.html#jls-8.9.2">8.9.2</a>), or of a lambda expression (<a href="../../../se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</del></p></li>
<li><p><del>A formal parameter of an <code>abstract</code> method of an interface type or annotation type (<a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a>)</del></p></li>
<li><p><del>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.20">14.20</a>)</del></p></li>
</ul></li>
<li><p><strong>A formal parameter of a method of a class or interface (<a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>), a constructor of a class (<a href="../../../se14/html/jls-8.html#jls-8.8.1">8.8.1</a>), or a lambda expression (<a href="../../../se14/html/jls-15.html#jls-15.27.1">15.27.1</a>)</strong></p></li>
<li><p><strong>An exception parameter of an exception handler declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.20">14.20</a>)</strong></p></li>
</ul>
<div class="editorial">
<p>Formal parameters and exception parameters are typically treated as two distinct entities. Formal parameters of class methods and interface methods, on the other hand, are specified in exactly one place, and don't need to be treated as distinct things.</p>
</div>
<ul>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared in a block (<a href="../../../se14/html/jls-14.html#jls-14.4">14.4</a>)</p></li>
<li><p>A local variable declared in a <code>for</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.14">14.14</a>)</p></li>
</ul></li>
<li><p><strong>A local class (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>)</strong></p></li>
</ul>
<p>Constructors (<a href="../../../se14/html/jls-8.html#jls-8.8">8.8</a>) are also introduced by declarations, but use the name of the class in which they are declared rather than introducing a new name.</p>
<p>...</p>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p>The <em>scope</em> of a declaration is the region of the program within which the entity declared by the declaration can be referred to using a simple name, provided it is not shadowed (<a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>).</p>
<p>A declaration is said to be <em>in scope</em> at a particular point in a program if and only if the declaration's scope includes that point.</p>
<p>The scope of the declaration of an observable top level package (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>) is all observable compilation units associated with modules to which the package is uniquely visible (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<p>The declaration of a package that is not observable is never in scope.</p>
<p>The declaration of a subpackage is never in scope.</p>
<p>The package <code>java</code> is always in scope.</p>
<p>The scope of a <del>type</del> <strong>class or interface</strong> imported by a single-type-import declaration (<a href="class-terminology-jls.html#jls-7.5.1">7.5.1</a>) or a type-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.2">7.5.2</a>) is the module declaration (<a href="../../../se14/html/jls-7.html#jls-7.7">7.7</a>) and all the class and interface <del>type</del> declarations (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a member imported by a single-static-import declaration (<a href="class-terminology-jls.html#jls-7.5.3">7.5.3</a>) or a static-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.4">7.5.4</a>) is the module declaration and all the class and interface <del>type</del> declarations of the compilation unit in which the <code>import</code> declaration appears, as well as any annotations on the module declaration or package declaration of the compilation unit.</p>
<p>The scope of a top level <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) is all <del>type</del> <strong>class and interface</strong> declarations in the package in which the top level <del>type</del> <strong>class or interface</strong> is declared.</p>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by a class <del>type</del> <strong>or interface</strong> <em>C</em> (<del><a href="class-terminology-jls.html#jls-8.1.6">8.1.6</a></del> <strong><a href="../../../se14/html/jls-8.html#jls-8.2">8.2</a>, <a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a></strong>) is the entire body of <em>C</em>, including any nested <del>type</del> <strong>class or interface</strong> declarations.</p>
<p><del>The scope of a declaration of a member <em>m</em> declared in or inherited by an interface type <em>I</em> (<a href="class-terminology-jls.html#jls-9.1.4">9.1.4</a>) is the entire body of <em>I</em>, including any nested type declarations.</del></p>
<p><del>The scope of an enum constant <em>C</em> declared in an enum type <em>T</em> is the body of <em>T</em>, and any <code>case</code> label of a <code>switch</code> statement whose expression is of enum type <em>T</em> (<a href="../../../se14/html/jls-14.html#jls-14.11">14.11</a>).</del></p>
<div class="editorial">
<p>Names do not resolve to enum constants, they resolve to implicit fields of enum types. Switch statements require some special treatment, but don't rely on the normal scoping/name resolution mechanisms.</p>
</div>
<p>The scope of a formal parameter of a method (<a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>), constructor (<a href="../../../se14/html/jls-8.html#jls-8.8.1">8.8.1</a>), or lambda expression (<a href="../../../se14/html/jls-15.html#jls-15.27">15.27</a>) is the entire body of the method, constructor, or lambda expression.</p>
<p>The scope of a class's type parameter (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>) is the type parameter section of the class declaration, the type parameter section of any superclass or superinterface of the class declaration, and the class body.</p>
<p>The scope of an interface's type parameter (<a href="../../../se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the type parameter section of the interface declaration, the type parameter section of any superinterface of the interface declaration, and the interface body.</p>
<p>The scope of a method's type parameter (<a href="../../../se14/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the entire declaration of the method, including the type parameter section, but excluding the method modifiers.</p>
<p>The scope of a constructor's type parameter (<a href="../../../se14/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the entire declaration of the constructor, including the type parameter section, but excluding the constructor modifiers.</p>
<p>The scope of a local class declaration immediately enclosed by a block (<a href="../../../se14/html/jls-14.html#jls-14.2">14.2</a>) is the rest of the immediately enclosing block, including its own class declaration.</p>
<p>The scope of a local class declaration immediately enclosed by a switch block statement group (<a href="../../../se14/html/jls-14.html#jls-14.11">14.11</a>) is the rest of the immediately enclosing switch block statement group, including its own class declaration.</p>
<p>The scope of a local variable declaration in a block (<a href="../../../se14/html/jls-14.html#jls-14.4">14.4</a>) is the rest of the block in which the declaration appears, starting with its own initializer and including any further declarators to the right in the local variable declaration statement.</p>
<p>The scope of a local variable declared in the <em>ForInit</em> part of a basic <code>for</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.14.1">14.14.1</a>) includes all of the following:</p>
<ul>
<li><p>Its own initializer</p></li>
<li><p>Any further declarators to the right in the <em>ForInit</em> part of the <code>for</code> statement</p></li>
<li><p>The <em>Expression</em> and <em>ForUpdate</em> parts of the <code>for</code> statement</p></li>
<li><p>The contained <em>Statement</em></p></li>
</ul>
<p>The scope of a local variable declared in the <em>FormalParameter</em> part of an enhanced <code>for</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.14.2">14.14.2</a>) is the contained <em>Statement</em>.</p>
<p>The scope of a parameter of an exception handler that is declared in a <code>catch</code> clause of a <code>try</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.20">14.20</a>) is the entire block associated with the <code>catch</code>.</p>
<p>The scope of a variable declared in the <em>ResourceSpecification</em> of a <code>try</code>-with-resources statement (<a href="../../../se14/html/jls-14.html#jls-14.20.3">14.20.3</a>) is from the declaration rightward over the remainder of the <em>ResourceSpecification</em> and the entire <code>try</code> block associated with the <code>try</code>-with-resources statement.</p>
<blockquote>
<p>The translation of a <code>try</code>-with-resources statement implies the rule above.</p>
</blockquote>
<div class="example">
<p>Example 6.3-1. Scope of <del>Type</del> <strong>Class</strong> Declarations</p>
<p>These rules imply that declarations of class and interface types need not appear before uses of the types. In the following program, the use of <code>PointList</code> in class <code>Point</code> is valid, because the scope of the class declaration <code>PointList</code> includes both class <code>Point</code> and class <code>PointList</code>, as well as any other <del>type</del> <strong>class or interface</strong> declarations in other compilation units of package <code>points</code>.</p>
<pre><code>package points;
class Point {
    int x, y;
    PointList list;
    Point next;
}

class PointList {
    Point first;
}</code></pre>
</div>
<div class="example">
<p>Example 6.3-2. Scope of Local Variable Declarations</p>
<p>The following program causes a compile-time error because the initialization of local variable <code>x</code> is within the scope of the declaration of local variable <code>x</code>, but the local variable <code>x</code> does not yet have a value and cannot be used. The field <code>x</code> has a value of <code>0</code> (assigned when <code>Test1</code> was initialized) but is a red herring since it is shadowed (<a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) by the local variable <code>x</code>.</p>
<pre><code>class Test1 {
    static int x;
    public static void main(String[] args) {
        int x = x;
    }
}</code></pre>
<p>The following program does compile:</p>
<pre><code>class Test2 {
    static int x;
    public static void main(String[] args) {
        int x = (x=2)*2;
        System.out.println(x);
    }
}</code></pre>
<p>because the local variable <code>x</code> is definitely assigned (<a href="../../../se14/html/jls-16.html">16</a>) before it is used. It prints:</p>
<pre><code>4</code></pre>
<p>In the following program, the initializer for <code>three</code> can correctly refer to the variable <code>two</code> declared in an earlier declarator, and the method invocation in the next line can correctly refer to the variable <code>three</code> declared earlier in the block.</p>
<pre><code>class Test3 {
    public static void main(String[] args) {
        System.out.print(&quot;2+1=&quot;);
        int two = 2, three = two + 1;
        System.out.println(three);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>2+1=3</code></pre>
</div>
<h3 id="jls-6.5">6.5 Determining the Meaning of a Name</h3>
<h4 id="jls-6.5.4">6.5.4 Meaning of <em>PackageOrTypeNames</em></h4>
<h5 id="jls-6.5.4.1">6.5.4.1 Simple <em>PackageOrTypeNames</em></h5>
<p>If the <em>PackageOrTypeName</em>, <em>Q</em>, is a valid <em>TypeIdentifier</em> and occurs in the scope of a <del>type</del> <strong>class, interface, or type parameter</strong> named <em>Q</em>, then the <em>PackageOrTypeName</em> is reclassified as a <em>TypeName</em>.</p>
<p>Otherwise, the <em>PackageOrTypeName</em> is reclassified as a <em>PackageName</em>. The meaning of the <em>PackageOrTypeName</em> is the meaning of the reclassified name.</p>
<h5 id="jls-6.5.4.2">6.5.4.2 Qualified <em>PackageOrTypeNames</em></h5>
<p>Given a qualified <em>PackageOrTypeName</em> of the form <em>Q.Id</em>, if <em>Id</em> is a valid <em>TypeIdentifier</em> and the <del>type</del> <strong>class, interface, type parameter,</strong> or package denoted by <em>Q</em> has a member <del>type</del> <strong>class or interface</strong> named <em>Id</em>, then the qualified <em>PackageOrTypeName</em> name is reclassified as a <em>TypeName</em>.</p>
<p>Otherwise, it is reclassified as a <em>PackageName</em>. The meaning of the qualified <em>PackageOrTypeName</em> is the meaning of the reclassified name.</p>
<h4 id="jls-6.5.5">6.5.5 Meaning of Type Names</h4>
<p>The meaning of a name classified as a <em>TypeName</em> is determined as follows.</p>
<h5 id="jls-6.5.5.1">6.5.5.1 Simple Type Names</h5>
<p>If a type name consists of a single <em>Identifier</em>, then the identifier must occur in the scope of exactly one declaration of a <del>type</del> <strong>class, interface, or type parameter</strong> with this name (<a href="class-terminology-jls.html#jls-6.3">6.3</a>), or a compile-time error occurs.</p>
<p>The meaning of the type name is that <del>type</del> <strong>class, interface, or type parameter</strong>.</p>
<h5 id="jls-6.5.5.2">6.5.5.2 Qualified Type Names</h5>
<p>If a type name is of the form <em>Q.Id</em>, then <em>Q</em> must be either the name of a <del>type</del> <strong>class, interface, or type parameter</strong> in a package uniquely visible to the current module, or the name of a package uniquely visible to the current module (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<div class="editorial">
<p>To do: this doesn't seem right—e.g., a local class or a type parameter isn't a member of a package at all. Shouldn't any external package be handled by checking an import statement?</p>
</div>
<p>If <em>Id</em> names exactly one accessible <del>type</del> <strong>class or interface</strong> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>) that is a member of the <del>type</del> <strong>class, interface, type parameter,</strong> or package denoted by <em>Q</em>, then the qualified type name denotes that <del>type</del> <strong>class or interface</strong>.</p>
<p>If <em>Id</em> does not name a member <del>type</del> <strong>class or interface</strong> within <em>Q</em> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>), or the member <del>type</del> <strong>class or interface</strong> named <em>Id</em> within <em>Q</em> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>), or <em>Id</em> names more than one member <del>type</del> <strong>class or interface</strong> within <em>Q</em>, then a compile-time error occurs.</p>
<div class="example">
<p>Example 6.5.5.2-1. Qualified Type Names</p>
<pre><code>class Test {
    public static void main(String[] args) {
        java.util.Date date =
            new java.util.Date(System.currentTimeMillis());
        System.out.println(date.toLocaleString());
    }
}</code></pre>
<p>This program produced the following output the first time it was run:</p>
<pre><code>Sun Jan 21 22:56:29 1996</code></pre>
<p>In this example, the name <code>java.util.Date</code> must denote a type, so we first use the procedure recursively to determine if <code>java.util</code> is an accessible <del>type</del> <strong>class, interface, or type parameter,</strong> or a package, which it is, and then look to see if the type <code>Date</code> is accessible in this package.</p>
</div>
<h2 id="jls-7">Chapter 7: Packages and Modules</h2>
<h3 id="jls-7.3">7.3 Compilation Units</h3>
<p><em>CompilationUnit</em> is the goal symbol (<a href="../../../se14/html/jls-2.html#jls-2.1">2.1</a>) for the syntactic grammar (<a href="../../../se14/html/jls-2.html#jls-2.3">2.3</a>) of Java programs. It is defined by the following production:</p>
<dl>
<dt><em>CompilationUnit:</em></dt>
<dd><em>OrdinaryCompilationUnit</em>
</dd>
<dd><em>ModularCompilationUnit</em>
</dd>
<dt><em>OrdinaryCompilationUnit:</em></dt>
<dd>[<em>PackageDeclaration</em>] {<em>ImportDeclaration</em>} {<del><em>TypeDeclaration</em></del> <strong><em>TopLevelClassOrInterfaceDeclaration</em></strong>}
</dd>
<dt><em>ModularCompilationUnit:</em></dt>
<dd>{<em>ImportDeclaration</em>} <em>ModuleDeclaration</em>
</dd>
</dl>
<p>An <em>ordinary compilation unit</em> consists of three parts, each of which is optional:</p>
<ul>
<li><p>A <code>package</code> declaration (<a href="../../../se14/html/jls-7.html#jls-7.4">7.4</a>), giving the fully qualified name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>) of the package to which the compilation unit belongs.</p>
<p>A compilation unit that has no <code>package</code> declaration is part of an unnamed package (<a href="../../../se14/html/jls-7.html#jls-7.4.2">7.4.2</a>).</p></li>
<li><p><code>import</code> declarations (<a href="class-terminology-jls.html#jls-7.5">7.5</a>) that allow <del>types</del> <strong>classes and interfaces</strong> from other packages and <code>static</code> members of <del>types</del> <strong>classes and interfaces</strong> to be referred to using their simple names.</p></li>
<li><p>Top level <del>type</del> declarations <del>(<a href="class-terminology-jls.html#jls-7.6">7.6</a>)</del> of <del>class and interface types</del> <strong>classes and interfaces (<a href="class-terminology-jls.html#jls-7.6">7.6</a>)</strong>.</p></li>
</ul>
<p>A <em>modular compilation unit</em> consists of a <code>module</code> declaration (<a href="../../../se14/html/jls-7.html#jls-7.7">7.7</a>), optionally preceded by <code>import</code> declarations. The <code>import</code> declarations allow <del>types</del> <strong>classes and interfaces</strong> from packages in this module and other modules, as well as <code>static</code> members of <del>types</del> <strong>classes and interfaces</strong>, to be referred to using their simple names within the <code>module</code> declaration.</p>
<p>Every compilation unit implicitly imports every <code>public</code> <del>type</del> <strong>class or interface</strong> name declared in the predefined package <code>java.lang</code>, as if the declaration <code>import java.lang.*;</code> appeared at the beginning of each compilation unit immediately after any <code>package</code> declaration. As a result, the names of all those <del>types</del> <strong>classes and interfaces</strong> are available as simple names in every compilation unit.</p>
<p>The host system determines which compilation units are <em>observable</em>, except for the compilation units in the predefined package <code>java</code> and its subpackages <code>lang</code> and <code>io</code>, which are all always observable.</p>
<p>Each observable compilation unit may be <em>associated</em> with a module, as follows:</p>
<ul>
<li><p>The host system may determine that an observable ordinary compilation unit is associated with a module chosen by the host system, except for (i) the ordinary compilation units in the predefined package <code>java</code> and its subpackages <code>lang</code> and <code>io</code>, which are all associated with the <code>java.base</code> module, and (ii) any ordinary compilation unit in an unnamed package, which is associated with a module as specified in <a href="../../../se14/html/jls-7.html#jls-7.4.2">7.4.2</a>.</p></li>
<li><p>The host system must determine that an observable modular compilation unit is associated with the module declared by the modular compilation unit.</p></li>
</ul>
<blockquote>
<p>The observability of a compilation unit influences the observability of its package (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), while the association of an observable compilation unit with a module influences the observability of that module (<a href="../../../se14/html/jls-7.html#jls-7.7.6">7.7.6</a>).</p>
</blockquote>
<p>When compiling the modular and ordinary compilation units associated with a module <em>M</em>, the host system must respect the dependences specified in <em>M</em>'s declaration. Specifically, the host system must limit the ordinary compilation units that would otherwise be observable, to only those that are <em>visible to M</em>. The ordinary compilation units that are visible to <em>M</em> are the observable ordinary compilation units associated with the modules that are <em>read by M</em>. The modules read by <em>M</em> are given by the result of <em>resolution</em>, as described in the <code>java.lang.module</code> package specification, with <em>M</em> as the only root module. The host system must perform resolution to determine the modules read by <em>M</em>; it is a compile-time error if resolution fails for any of the reasons described in the <code>java.lang.module</code> package specification.</p>
<blockquote>
<p>The readability relation is reflexive, so <em>M</em> reads itself, and thus all of the modular and ordinary compilation units associated with <em>M</em> are visible to <em>M</em>.</p>
</blockquote>
<blockquote>
<p>The modules read by <em>M</em> drive the packages that are uniquely visible to <em>M</em> (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), which in turn drives both the top level packages in scope and the meaning of package names for code in the modular and ordinary compilation units associated with <em>M</em> (<a href="class-terminology-jls.html#jls-6.3">6.3</a>, <a href="../../../se14/html/jls-6.html#jls-6.5.3">6.5.3</a>, <a href="class-terminology-jls.html#jls-6.5.5">6.5.5</a>).</p>
</blockquote>
<blockquote>
<p>The rules above ensure that <del>package/type</del> names used in annotations in a modular compilation unit (in particular, annotations applied to the module declaration) are interpreted as if they appeared in an ordinary compilation unit associated with the module.</p>
</blockquote>
<p><del>Types</del> <strong>Classes and interfaces</strong> declared in different ordinary compilation units can refer to each other, circularly. A Java compiler must arrange to compile all such <del>types</del> <strong>classes and interfaces</strong> at the same time.</p>
<h3 id="jls-7.5">7.5 Import Declarations</h3>
<p>An <em>import declaration</em> allows a named <del>type or a</del> <strong>class, interface, or</strong> <code>static</code> member to be referred to by a simple name (<a href="../../../se14/html/jls-6.html#jls-6.2">6.2</a>) that consists of a single identifier.</p>
<p>Without the use of an appropriate import declaration, <del>the only way to refer to a type declared in another package, or a <code>static</code> member of another type, is to use a fully qualified name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>)</del> <strong>a reference to a class or interface declared in another package, or a <code>static</code> member of another class or interface, would typically need to use a qualified name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>)</strong>.</p>
<div class="editorial">
<p>Problems with the original claim:</p>
<ul>
<li><p>A member class could be accessed with a <em>partially</em> qualified name by importing its declaring class.</p></li>
<li><p>Members of a superclass are in scope via inheritance, without any need to import them.</p></li>
</ul>
</div>
<dl>
<dt><em>ImportDeclaration:</em></dt>
<dd><em>SingleTypeImportDeclaration</em>
</dd>
<dd><em>TypeImportOnDemandDeclaration</em>
</dd>
<dd><em>SingleStaticImportDeclaration</em>
</dd>
<dd><em>StaticImportOnDemandDeclaration</em>
</dd>
</dl>
<ul>
<li>A single-type-import declaration (<a href="class-terminology-jls.html#jls-7.5.1">7.5.1</a>) imports a single named <del>type</del></li>
<li><p><strong>class or interface</strong>, by mentioning its canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>A type-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.2">7.5.2</a>) imports all the accessible <del>types</del> <strong>classes and interfaces</strong> of a named <del>type or named</del> package<strong>, class, or interface</strong> as needed, by mentioning the canonical name of a <del>type or</del> package<strong>, class, or interface</strong>.</p></li>
<li><p>A single-static-import declaration (<a href="class-terminology-jls.html#jls-7.5.3">7.5.3</a>) imports all accessible <code>static</code> members with a given name from a <del>type</del> <strong>class or interface</strong>, by giving its canonical name.</p></li>
<li><p>A static-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.4">7.5.4</a>) imports all accessible <code>static</code> members of a named <del>type</del> <strong>class or interface</strong> as needed, by mentioning the canonical name of a <del>type</del> <strong>class or interface</strong>.</p></li>
</ul>
<p>The scope and shadowing of a <del>type</del> <strong>class, interface,</strong> or member imported by these declarations is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<blockquote>
<p>An <code>import</code> declaration makes <del>types</del> <strong>classes, interfaces,</strong> or members available by their simple names only within the compilation unit that actually contains the <code>import</code> declaration. The scope of the <del>type(s)</del> <strong>class(es), interface(s),</strong> or member(s) introduced by an <code>import</code> declaration specifically does not include other compilation units in the same package, other <code>import</code> declarations in the current compilation unit, or a <code>package</code> declaration in the current compilation unit (except for the annotations of a <code>package</code> declaration).</p>
</blockquote>
<h4 id="jls-7.5.1">7.5.1 Single-Type-Import Declarations</h4>
<p>A <em>single-type-import declaration</em> imports a single <del>type</del> <strong>class or interface</strong> by giving its canonical name, making it available under a simple name in the module, class, and interface declarations of the compilation unit in which the single-type-import declaration appears.</p>
<dl>
<dt><em>SingleTypeImportDeclaration:</em></dt>
<dd><code>import</code> <em>TypeName</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong> (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>).</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>If two single-type-import declarations in the same compilation unit attempt to import <del>types</del> <strong>classes or interfaces</strong> with the same simple name, then a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<p>If the <del>type</del> <strong>class or interface</strong> imported by the single-type-import declaration is declared in the compilation unit that contains the <code>import</code> declaration, the <code>import</code> declaration is ignored.</p>
<p>If a single-type-import declaration imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and the compilation unit also declares a top level <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-type-import declaration that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and a single-static-import declaration (<a href="class-terminology-jls.html#jls-7.5.3">7.5.3</a>) that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<div class="example">
<p>Example 7.5.1-1. Single-Type-Import</p>
<pre><code>import java.util.Vector;</code></pre>
<p>causes the simple name <code>Vector</code> to be available within the class and interface declarations in a compilation unit. Thus, the simple name <code>Vector</code> refers to the <del>type</del> <strong>class</strong> declaration <code>Vector</code> in the package <code>java.util</code> in all places where it is not shadowed (<a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="../../../se14/html/jls-6.html#jls-6.4.2">6.4.2</a>) by a declaration of a field, parameter, local variable, or nested <del>type</del> <strong>class or interface</strong> declaration with the same name.</p>
<p>Note that the actual declaration of <code>java.util.Vector</code> is generic (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>). Once imported, the name <code>Vector</code> can be used without qualification in a parameterized type such as <code>Vector&lt;String&gt;</code>, or as the raw type <code>Vector</code>. A related limitation of the <code>import</code> declaration is that a <del>nested type</del> <strong>member class or interface</strong> declared inside a generic <del>type</del> <strong>class or interface</strong> declaration can be imported, but its outer type is always erased.</p>
</div>
<div class="example">
<p>Example 7.5.1-2. Duplicate <del>Type</del> <strong>Class or Interface</strong> Declarations</p>
<p>This program:</p>
<pre><code>import java.util.Vector;
class Vector { Object[] vec; }</code></pre>
<p>causes a compile-time error because of the duplicate declaration of <code>Vector</code>, as does:</p>
<pre><code>import java.util.Vector;
import myVector.Vector;</code></pre>
<p>where <code>myVector</code> is a package containing the compilation unit:</p>
<pre><code>package myVector;
public class Vector { Object[] vec; }</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-3. No Import of a Subpackage</p>
<p>Note that an <code>import</code> declaration cannot import a subpackage, only a <del>type</del> <strong>class or interface</strong>.</p>
<p>For example, it does not work to try to import <code>java.util</code> and then use the name <code>util.Random</code> to refer to the type <code>java.util.Random</code>:</p>
<pre><code>import java.util;
class Test { util.Random generator; }
  // incorrect: compile-time error</code></pre>
</div>
<div class="example">
<p>Example 7.5.1-4. Importing a Type Name that is also a Package Name</p>
<p>Package names and type names are usually different under the naming conventions described in <a href="class-terminology-jls.html#jls-6.1">6.1</a>. Nevertheless, in a contrived example where there is an unconventionally-named package <code>Vector</code>, which declares a public class whose name is <code>Mosquito</code>:</p>
<pre><code>package Vector;
public class Mosquito { int capacity; }</code></pre>
<p>and then the compilation unit:</p>
<pre><code>package strange;
import java.util.Vector;
import Vector.Mosquito;
class Test {
    public static void main(String[] args) {
        System.out.println(new Vector().getClass());
        System.out.println(new Mosquito().getClass());
    }
}</code></pre>
<p>the single-type-import declaration importing class <code>Vector</code> from package <code>java.util</code> does not prevent the package name <code>Vector</code> from appearing and being correctly recognized in subsequent <code>import</code> declarations. The example compiles and produces the output:</p>
<pre><code>class java.util.Vector
class Vector.Mosquito</code></pre>
</div>
<h4 id="jls-7.5.2">7.5.2 Type-Import-on-Demand Declarations</h4>
<p>A <em>type-import-on-demand declaration</em> allows all accessible <del>types</del> <strong>classes and interfaces</strong> of a named package<strong>, class, or interface</strong> <del>or type</del> to be imported as needed.</p>
<dl>
<dt><em>TypeImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <em>PackageOrTypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>PackageOrTypeName</em> must be the canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>) of a package, a class <del>type</del>, <strong>or</strong> an interface <del>type, an enum type, or an annotation type</del>.</p>
<p>If the <em>PackageOrTypeName</em> denotes a <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-6.5.4">6.5.4</a>), then the <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named package is not uniquely visible to the current module (<a href="../../../se14/html/jls-7.html#jls-7.4.3">7.4.3</a>), or if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>It is not a compile-time error to name either <code>java.lang</code> or the named package of the current compilation unit in a type-import-on-demand declaration. The type-import-on-demand declaration is ignored in such cases.</p>
<p>Two or more type-import-on-demand declarations in the same compilation unit may name the same <del>type or</del> package<strong>, class, or interface</strong>. All but one of these declarations are considered redundant; the effect is as if that type was imported only once.</p>
<p>If a compilation unit contains both a type-import-on-demand declaration and a static-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.4">7.5.4</a>) that name the same <del>type</del> <strong>class or interface</strong>, the effect is as if the <code>static</code> member <del>types</del> <strong>classes and interfaces</strong> of that <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>) were imported only once.</p>
<div class="example">
<p>Example 7.5.2-1. Type-Import-on-Demand</p>
<pre><code>import java.util.*;</code></pre>
<p>causes the simple names of all <code>public</code> <del>types</del> <strong>classes and interfaces</strong> declared in the package <code>java.util</code> to be available within the class and interface declarations of the compilation unit. Thus, the simple name <code>Vector</code> refers to the <del>type</del> <strong>class</strong> <code>Vector</code> <del>in</del> <strong>of</strong> the package <code>java.util</code> in all places in the compilation unit where that <del>type</del> <strong>class</strong> declaration is not shadowed (<a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) or obscured (<a href="../../../se14/html/jls-6.html#jls-6.4.2">6.4.2</a>).</p>
<p>The declaration might be shadowed by a single-type-import declaration of a <del>type</del> <strong>class or interface</strong> whose simple name is <code>Vector</code>; by a <del>type</del> <strong>class or interface</strong> named <code>Vector</code> and declared in the package to which the compilation unit belongs; or any nested classes or interfaces.</p>
<p>The declaration might be obscured by a declaration of a field, parameter, or local variable named <code>Vector</code>.</p>
<p>(It would be unusual for any of these conditions to occur.)</p>
</div>
<h4 id="jls-7.5.3">7.5.3 Single-Static-Import Declarations</h4>
<p>A <em>single-static-import declaration</em> imports all accessible <code>static</code> members with a given simple name from a <del>type</del> <strong>class or interface</strong>. This makes these <code>static</code> members available under their simple name in the module, class, and interface declarations of the compilation unit in which the single-static-import declaration appears.</p>
<dl>
<dt><em>SingleStaticImportDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <em>Identifier</em> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>) of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong>.</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>The <em>Identifier</em> must name at least one <code>static</code> member of the named <del>type</del> <strong>class or interface</strong>. It is a compile-time error if there is no <code>static</code> member of that name, or if all of the named members are not accessible.</p>
<p>It is permissible for one single-static-import declaration to import several fields<strong>, classes, or interfaces</strong> <del>or types</del> with the same name, or several methods with the same name and signature. This occurs when the named <del>type</del> <strong>class or interface</strong> inherits multiple fields, member <del>types</del> <strong>classes, member interfaces</strong>, or methods, all with the same name, from its own supertypes.</p>
<p>If two single-static-import declarations in the same compilation unit attempt to import <del>types</del> <strong>classes or interfaces</strong> with the same simple name, then a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<p>If a single-static-import declaration imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and the compilation unit also declares a top level <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) whose simple name is <em>n</em>, a compile-time error occurs.</p>
<p>If a compilation unit contains both a single-static-import declaration that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, and a single-type-import declaration (<a href="class-terminology-jls.html#jls-7.5.1">7.5.1</a>) that imports a <del>type</del> <strong>class or interface</strong> whose simple name is <em>n</em>, a compile-time error occurs, unless the two <del>types</del> <strong>classes or interfaces</strong> are the same <del>type</del>, in which case the duplicate declaration is ignored.</p>
<h4 id="jls-7.5.4">7.5.4 Static-Import-on-Demand Declarations</h4>
<p>A <em>static-import-on-demand declaration</em> allows all accessible <code>static</code> members of a named <del>type</del> <strong>class or interface</strong> to be imported as needed.</p>
<dl>
<dt><em>StaticImportOnDemandDeclaration:</em></dt>
<dd><code>import</code> <code>static</code> <em>TypeName</em> <code>.</code> <code>*</code> <code>;</code>
</dd>
</dl>
<p>The <em>TypeName</em> must be the canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>) of a class <del>type, interface type, enum type, or annotation type</del> <strong>or interface</strong>.</p>
<p>The <del>type</del> <strong>class or interface</strong> must be either a member of a named package, or a member of a <del>type</del> <strong>class or interface</strong> whose outermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) is a member of a named package, or a compile-time error occurs.</p>
<p>It is a compile-time error if the named <del>type</del> <strong>class or interface</strong> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same <del>type</del> <strong>class or interface</strong>; the effect is as if there was exactly one such declaration.</p>
<p>Two or more static-import-on-demand declarations in the same compilation unit may name the same member; the effect is as if the member was imported exactly once.</p>
<p>It is permissible for one static-import-on-demand declaration to import several fields<strong>, classes, or interfaces</strong> <del>or types</del> with the same name, or several methods with the same name and signature. This occurs when the named <del>type</del> <strong>class or interface</strong> inherits multiple fields, member <del>types</del> <strong>classes, member interfaces</strong>, or methods, all with the same name, from its own supertypes.</p>
<p>If a compilation unit contains both a static-import-on-demand declaration and a type-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.2">7.5.2</a>) that name the same <del>type</del> <strong>class or interface</strong>, the effect is as if the <code>static</code> member <del>types</del> <strong>classes and interfaces</strong> of that <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>) were imported only once.</p>
<h3 id="jls-7.6">7.6 Top Level <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>A <em>top level <del>type</del> <strong>class or interface</strong> declaration</em> declares a top level class <del>type</del> (<del><a href="class-terminology-jls.html#jls-8">8</a></del> <strong><a href="class-terminology-jls.html#jls-8.1">8.1</a></strong>)<strong>, which may be an enum class (<a href="class-terminology-jls.html#jls-8.9">8.9</a>),</strong> or a top level interface <del>type</del> (<del><a href="class-terminology-jls.html#jls-9">9</a></del> <strong><a href="class-terminology-jls.html#jls-9.1">9.1</a></strong>)<strong>, which may be an annotation interface (<a href="class-terminology-jls.html#jls-9.6">9.6</a>)</strong>.</p>
<dl>
<dt><del><em>TypeDeclaration:</em></del> <strong><em>TopLevelClassOrInterfaceDeclaration:</em></strong></dt>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><del><em>InterfaceDeclaration</em></del>
</dd>
<dd><strong><em>ClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><code>;</code>
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>ClassOrInterfaceDeclaration:</em></dt>
<dd><em>ClassDeclaration</em>
</dd>
<dd><em>EnumDeclaration</em>
</dd>
<dd><em>InterfaceDeclaration</em>
</dd>
<dd><em>AnnotationDeclaration</em>
</dd>
</dl>
</div>
<blockquote>
<p>Extra &quot;<code>;</code>&quot; tokens appearing at the level of <del>type</del> <strong>class or interface</strong> declarations in a compilation unit have no effect on the meaning of the compilation unit. Stray semicolons are permitted in the Java programming language solely as a concession to C++ programmers who are used to placing &quot;<code>;</code>&quot; after a class declaration. They should not be used in new Java code.</p>
</blockquote>
<p>In the absence of an access modifier, a top level <del>type</del> <strong>class or interface</strong> has package access: it is accessible only within ordinary compilation units of the package in which it is declared (<a href="../../../se14/html/jls-6.html#jls-6.6.1">6.6.1</a>). A <del>type</del> <strong>class or interface</strong> may be declared <code>public</code> to grant access to the <del>type</del> <strong>class or interface</strong> from code in other packages of the same module, and potentially from code in packages of other modules.</p>
<p>It is a compile-time error if a top level <del>type</del> <strong>class or interface</strong> declaration contains any one of the following access modifiers: <code>protected</code>, <code>private</code>, or <code>static</code>.</p>
<p>It is a compile-time error if the name of a top level <del>type</del> <strong>class or interface</strong> appears as the name of any other top level class or interface <del>type</del> declared in the same package.</p>
<p>The scope and shadowing of a top level <del>type</del> <strong>class or interface</strong> is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>The fully qualified name of a top level <del>type</del> <strong>class or interface</strong> is specified in <a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>.</p>
<div class="example">
<p>Example 7.6-1. Conflicting Top Level <del>Type</del> <strong>Class or Interface</strong> Declarations</p>
<pre><code>package test;
import java.util.Vector;
class Point {
    int x, y;
}
interface Point {  // compile-time error #1
    int getR();
    int getTheta();
}
class Vector { Point[] pts; }  // compile-time error #2</code></pre>
<p>Here, the first compile-time error is caused by the duplicate declaration of the name <code>Point</code> as both a class and an interface in the same package. A second compile-time error is the attempt to declare the name <code>Vector</code> both by a class <del>type</del> declaration and by a single-type-import declaration.</p>
<p>Note, however, that it is not an error for the name of a class to also name a <del>type</del> <strong>class or interface</strong> that otherwise might be imported by a type-import-on-demand declaration (<a href="class-terminology-jls.html#jls-7.5.2">7.5.2</a>) in the compilation unit (<a href="class-terminology-jls.html#jls-7.3">7.3</a>) containing the class declaration. Thus, in this program:</p>
<pre><code>package test;
import java.util.*;
class Vector {}  // not a compile-time error</code></pre>
<p>the declaration of the class <code>Vector</code> is permitted even though there is also a class <code>java.util.Vector</code>. Within this compilation unit, the simple name <code>Vector</code> refers to the class <code>test.Vector</code>, not to <code>java.util.Vector</code> (which can still be referred to by code within the compilation unit, but only by its fully qualified name).</p>
</div>
<div class="example">
<p>Example 7.6-2. Scope of Top Level <del>Types</del> <strong>Classes and Interfaces</strong></p>
<pre><code>package points;
class Point {
    int x, y;           // coordinates
    PointColor color;   // color of this point
    Point next;         // next point with this color
    static int nPoints;
}
class PointColor {
    Point first;        // first point with this color
    PointColor(int color) { this.color = color; }
    private int color;  // color components
}</code></pre>
<p>This program defines two classes that use each other in the declarations of their class members. Because the <del>class types</del> <strong>classes</strong> <code>Point</code> and <code>PointColor</code> have all the <del>type</del> <strong>class</strong> declarations in package <code>points</code>, including all those in the current compilation unit, as their scope, this program compiles correctly. That is, forward reference is not a problem.</p>
</div>
<div class="example">
<p>Example 7.6-3. Fully Qualified Names</p>
<pre><code>class Point { int x, y; }</code></pre>
<p>In this code, the class <code>Point</code> is declared in a compilation unit with no <code>package</code> declaration, and thus <code>Point</code> is its fully qualified name, whereas in the code:</p>
<pre><code>package vista;
class Point { int x, y; }</code></pre>
<p>the fully qualified name of the class <code>Point</code> is <code>vista.Point</code>. (The package name <code>vista</code> is suitable for local or personal use; if the package were intended to be widely distributed, it would be better to give it a unique package name (<a href="class-terminology-jls.html#jls-6.1">6.1</a>).)</p>
</div>
<p>An implementation of the Java SE Platform must keep track of <del>types</del> <strong>classes and interfaces</strong> within packages by the combination of their enclosing module names and their binary names (<a href="class-terminology-jls.html#jls-13.1">13.1</a>). Multiple ways of naming a <del>type</del> <strong>class or interface</strong> must be expanded to binary names to make sure that such names are understood as referring to the same <del>type</del> <strong>class or interface</strong>.</p>
<blockquote>
<p>For example, if a compilation unit contains the single-type-import declaration (<a href="class-terminology-jls.html#jls-7.5.1">7.5.1</a>):</p>
<pre><code>import java.util.Vector;</code></pre>
<p>then within that compilation unit, the simple name <code>Vector</code> and the fully qualified name <code>java.util.Vector</code> refer to the same <del>type</del> <strong>class</strong>.</p>
</blockquote>
<p>If and only if packages are stored in a file system (<a href="../../../se14/html/jls-7.html#jls-7.2">7.2</a>), the host system may choose to enforce the restriction that it is a compile-time error if a <del>type</del> <strong>class or interface</strong> is not found in a file under a name composed of the <del>type</del> <strong>class or interface</strong> name plus an extension (such as <code>.java</code> or <code>.jav</code>) if either of the following is true:</p>
<ul>
<li><p>The <del>type</del> <strong>class or interface</strong> is referred to by code in other ordinary compilation units of the package in which the <del>type</del> <strong>class or interface</strong> is declared.</p></li>
<li><p>The <del>type</del> <strong>class or interface</strong> is declared <code>public</code> (and therefore is potentially accessible from code in other packages).</p></li>
</ul>
<blockquote>
<p>This restriction implies that there must be at most one such <del>type</del> <strong>class or interface</strong> per compilation unit. This restriction makes it easy for a Java compiler to find a named class <strong>or interface</strong> within a package. In practice, many programmers choose to put each class or interface <del>type</del> in its own compilation unit, whether or not it is <code>public</code> or is referred to by code in other compilation units.</p>
</blockquote>
<blockquote>
<p>For example, the source code for a <code>public</code> type <code>wet.sprocket.Toad</code> would be found in a file <code>Toad.java</code> in the directory <code>wet/sprocket</code>, and the corresponding object code would be found in the file <code>Toad.class</code> in the same directory.</p>
</blockquote>
<h3 id="jls-7.7">7.7 Module Declarations</h3>
<h4 id="jls-7.7.4">7.7.4 Service Provision</h4>
<p>The <code>provides</code> directive specifies a service for which the <code>with</code> clause specifies one or more <em>service providers</em> to <code>java.util.ServiceLoader</code>.</p>
<p>The service must be a class <del>type, an interface type, or an annotation type</del> <strong>or an interface, and not an enum class</strong>. It is a compile-time error if a <code>provides</code> directive specifies an enum <del>type</del> <strong>class</strong> (<a href="class-terminology-jls.html#jls-8.9">8.9</a>) as the service.</p>
<p>The service may be declared in the current module or in another module. If the service is not declared in the current module, then the service must be accessible to code in the current module (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>), or a compile-time error occurs.</p>
<p>Every service provider must be a <strong><code>public</code></strong> class <del>type</del> or <del>an</del> interface <del>type, that is <code>public</code>, and</del> that is top level or <del>nested</del> <code>static</code>, or a compile-time error occurs.</p>
<div class="editorial">
<p>There will eventually be some ambiguity in what &quot;nested <code>static</code>&quot; means. We can resolve it by just eliminating the word &quot;nested&quot;—any <code>static</code> class or interface that can be successfully referenced is fine.</p>
</div>
<p>Every service provider must be declared in the current module, or a compile-time error occurs.</p>
<p>If a service provider explicitly declares a <code>public</code> constructor with no formal parameters, or implicitly declares a <code>public</code> default constructor (<a href="../../../se14/html/jls-8.html#jls-8.8.9">8.8.9</a>), then that constructor is called the <em>provider constructor</em>.</p>
<p>If a service provider explicitly declares a <code>public</code> <code>static</code> method called <code>provider</code> with no formal parameters, then that method is called the <em>provider method</em>.</p>
<p>If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the <code>provides</code> directive; or a compile-time error occurs.</p>
<blockquote>
<p>While a service provider that is specified by a <code>provides</code> directive must be declared in the current module, its provider method may have a return type that is declared in <em>another</em> module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service.</p>
</blockquote>
<p>If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the <code>provides</code> directive, or a compile-time error occurs.</p>
<p>It is a compile-time error if more than one <code>provides</code> directive in a module declaration specifies the same service.</p>
<p>It is a compile-time error if the <code>with</code> clause of a given <code>provides</code> directive specifies the same service provider more than once.</p>
<h2 id="jls-8">Chapter 8: Classes</h2>
<p>Class declarations define new reference types and describe how they are implemented (<a href="class-terminology-jls.html#jls-8.1">8.1</a>).</p>
<p>A <em>top level class</em> <strong>(<a href="class-terminology-jls.html#jls-7.6">7.6</a>)</strong> is a class that is <del>not a nested class</del> <strong>declared at the top level of a compilation unit</strong>.</p>
<p>A <em>nested class</em> is any class whose declaration occurs within the body of another class or interface. <strong>A nested class may be a <em>member class</em> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>), a <em>local class</em> (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>), or an <em>anonymous class</em> (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>).</strong></p>
<p><strong>An <em>inner class</em> (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) is a nested class that can refer to enclosing class instances, local variables, and type variables.</strong></p>
<p><strong>An <em>enum class</em> (<a href="class-terminology-jls.html#jls-8.9">8.9</a>) is a class declared with special syntax that defines a small set of named class instances.</strong></p>
<p>This chapter discusses the common semantics of all classes <del>- top level (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) and nested (including member classes (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>), local classes (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>) and anonymous classes (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>))</del>. Details that are specific to particular kinds of classes are discussed in the sections dedicated to these constructs.</p>
<p>A named class may be declared <code>abstract</code> (<a href="../../../se14/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>) and must be declared abstract if it is incompletely implemented; such a class cannot be instantiated, but can be extended by subclasses. A class may be declared <code>final</code> (<a href="../../../se14/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>), in which case it cannot have subclasses. If a class is declared <code>public</code>, then it can be referred to from code in any package of its module and potentially from code in other modules. Each class except <code>Object</code> is an extension of (that is, a subclass of) a single existing class (<a href="../../../se14/html/jls-8.html#jls-8.1.4">8.1.4</a>) and may implement interfaces (<a href="../../../se14/html/jls-8.html#jls-8.1.5">8.1.5</a>). Classes may be <em>generic</em> (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>), that is, they may declare type variables whose bindings may differ among different instances of the class.</p>
<p>Classes may be decorated with annotations (<a href="../../../se14/html/jls-9.html#jls-9.7">9.7</a>) just like any other kind of declaration.</p>
<p>The body of a class declares members (fields<strong>,</strong> <del>and</del> methods<strong>,</strong> <del>and nested</del> classes<strong>,</strong> and interfaces), instance and static initializers, and constructors (<a href="class-terminology-jls.html#jls-8.1.6">8.1.6</a>). The scope (<a href="class-terminology-jls.html#jls-6.3">6.3</a>) of a member (<a href="../../../se14/html/jls-8.html#jls-8.2">8.2</a>) is the entire body of the declaration of the class to which the member belongs. Field, method, member class, member interface, and constructor declarations may include the access modifiers (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>) <code>public</code>, <code>protected</code>, or <code>private</code>. The members of a class include both declared and inherited members (<a href="../../../se14/html/jls-8.html#jls-8.2">8.2</a>). Newly declared fields can hide fields declared in a superclass or superinterface. Newly declared <del>class members</del> <strong>member classes</strong> and <del>interface members</del> <strong>member interfaces</strong> can hide <del>class or interface members</del> <strong>member classes and interfaces</strong> declared in a superclass or superinterface. Newly declared methods can hide, implement, or override methods declared in a superclass or superinterface.</p>
<p>Field declarations (<a href="../../../se14/html/jls-8.html#jls-8.3">8.3</a>) describe class variables, which are incarnated once, and instance variables, which are freshly incarnated for each instance of the class. A field may be declared <code>final</code> (<a href="../../../se14/html/jls-8.html#jls-8.3.1.2">8.3.1.2</a>), in which case it can be assigned to only once. Any field declaration may include an initializer.</p>
<p>Member class declarations (<a href="class-terminology-jls.html#jls-8.5">8.5</a>) describe nested classes that are members of the surrounding class. Member classes may be <code>static</code><del>, in which case they have no access to the instance variables of the surrounding class;</del> or they may be inner classes (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>).</p>
<p>Member interface declarations (<a href="class-terminology-jls.html#jls-8.5">8.5</a>) describe nested interfaces that are members of the surrounding class.</p>
<p>Method declarations (<a href="../../../se14/html/jls-8.html#jls-8.4">8.4</a>) describe code that may be invoked by method invocation expressions (<a href="../../../se14/html/jls-15.html#jls-15.12">15.12</a>). A class method is invoked relative to the class <del>type</del>; an instance method is invoked with respect to some particular object that is an instance of a class <del>type</del>. A method whose declaration does not indicate how it is implemented must be declared <code>abstract</code>. A method may be declared <code>final</code> (<a href="../../../se14/html/jls-8.html#jls-8.4.3.3">8.4.3.3</a>), in which case it cannot be hidden or overridden. A method may be implemented by platform-dependent <code>native</code> code (<a href="../../../se14/html/jls-8.html#jls-8.4.3.4">8.4.3.4</a>). A <code>synchronized</code> method (<a href="../../../se14/html/jls-8.html#jls-8.4.3.6">8.4.3.6</a>) automatically locks an object before executing its body and automatically unlocks the object on return, as if by use of a <code>synchronized</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.19">14.19</a>), thus allowing its activities to be synchronized with those of other threads (<a href="../../../se14/html/jls-17.html">17</a>).</p>
<p>Method names may be overloaded (<a href="../../../se14/html/jls-8.html#jls-8.4.9">8.4.9</a>).</p>
<p>Instance initializers (<a href="../../../se14/html/jls-8.html#jls-8.6">8.6</a>) are blocks of executable code that may be used to help initialize an instance when it is created (<a href="../../../se14/html/jls-15.html#jls-15.9">15.9</a>).</p>
<p>Static initializers (<a href="../../../se14/html/jls-8.html#jls-8.7">8.7</a>) are blocks of executable code that may be used to help initialize a class.</p>
<p>Constructors (<a href="../../../se14/html/jls-8.html#jls-8.8">8.8</a>) are similar to methods, but cannot be invoked directly by a method call; they are used to initialize new class instances. Like methods, they may be overloaded (<a href="../../../se14/html/jls-8.html#jls-8.8.8">8.8.8</a>).</p>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<p>A class declaration specifies <del>a new named reference type</del> <strong>a new class</strong>.</p>
<div class="deleted">
<p>There are two kinds of class declarations: <em>normal class declarations</em> and <em>enum declarations</em>.</p>
<dl>
<dt><em>ClassDeclaration:</em></dt>
<dd><em>NormalClassDeclaration</em>
</dd>
<dd><em>EnumDeclaration</em>
</dd>
</dl>
</div>
<dl>
<dt><del><em>NormalClassDeclaration:</em></del> <strong><em>ClassDeclaration:</em></strong></dt>
<dd>{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<em>Superclass</em>] [<em>Superinterfaces</em>] <em>ClassBody</em>
</dd>
</dl>
<div class="deleted">
<p>The rules in this section apply to all class declarations, including enum declarations. However, special rules apply to enum declarations with regard to class modifiers, inner classes, and superclasses; these rules are stated in <a href="class-terminology-jls.html#jls-8.9">8.9</a>.</p>
</div>
<div class="editorial">
<p>Enum classes are a kind of class, but enum declarations are a separate syntactic construct—there's no particular reason to group them together here.</p>
<p>A discussion about how different declaration forms for classes (including enum declarations and anonymous class declarations) relate to the rules specified throughout Chapter 8 already appears in <a href="class-terminology-jls.html#jls-8">8</a>. It's confusing to repeat it here.</p>
</div>
<p>The <em>TypeIdentifier</em> in a class declaration specifies the name of the class.</p>
<p>It is a compile-time error if a class has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of a class declaration is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<h4 id="jls-8.1.1">8.1.1 Class Modifiers</h4>
<p>A class declaration may include <em>class modifiers</em>.</p>
<dl>
<dt><em>ClassModifier:</em></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code> <code>protected</code> <code>private</code>
</dd>
<dd><code>abstract</code> <code>static</code> <code>final</code> <code>strictfp</code>
</dd>
</dl>
<p>The rules for annotation modifiers on a class declaration are specified in <a href="../../../se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>The access modifier <code>public</code> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>) pertains only to top level classes (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) and member classes (<a href="class-terminology-jls.html#jls-8.5">8.5</a><strong>, <a href="class-terminology-jls.html#jls-9.5">9.5</a></strong>), not to local classes (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>) <del>or anonymous classes (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>)</del>.</p>
<p>The access modifiers <code>protected</code> and <code>private</code> pertain only to member classes within a directly enclosing class declaration <del>(<a href="class-terminology-jls.html#jls-8.5">8.5</a>)</del>.</p>
<p>The modifier <code>static</code> pertains only to member classes <del>(<a href="class-terminology-jls.html#jls-8.5.1">8.5.1</a>)</del>, not to top level or local <del>or anonymous</del> classes.</p>
<div class="editorial">
<p>We're talking about the <em>ClassModifier</em> production that appears in the <em>ClassDeclaration</em> syntax, which is shared by top level, member, and local classes. There is no <em>ClassModifier</em> production in an anonymous class declaration, so it doesn't make sense to mention such classes here.</p>
</div>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for a class declaration, or if a class declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<blockquote>
<p>If two or more (distinct) class modifiers appear in a class declaration, then it is customary, though not required, that they appear in the order consistent with that shown above in the production for <em>ClassModifier</em>.</p>
</blockquote>
<h5 id="jls-8.1.1.3">8.1.1.3 <code>strictfp</code> Classes</h5>
<p>The effect of the <code>strictfp</code> modifier is to make all <code>float</code> or <code>double</code> expressions within the class declaration (including within variable initializers, instance initializers, static initializers, and constructors) be explicitly FP-strict (<a href="../../../se14/html/jls-15.html#jls-15.4">15.4</a>).</p>
<p>This implies that all methods declared in the class, and all nested <del>types</del> <strong>class and interfaces</strong> declared in the class, are implicitly <code>strictfp</code>.</p>
<h4 id="jls-8.1.3">8.1.3 Inner Classes and Enclosing Instances</h4>
<p>An <em>inner class</em> is a nested class that is not explicitly or implicitly declared <code>static</code>.</p>
<p>An inner class may be a non-<code>static</code> member class (<a href="class-terminology-jls.html#jls-8.5">8.5</a>), a local class (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>), or an anonymous class (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>). A member class of an interface is implicitly <code>static</code> (<a href="class-terminology-jls.html#jls-9.5">9.5</a>) so is never considered to be an inner class.</p>
<p>It is a compile-time error if an inner class declares a static initializer (<a href="../../../se14/html/jls-8.html#jls-8.7">8.7</a>).</p>
<p>It is a compile-time error if an inner class declares a member that is explicitly or implicitly <code>static</code>, unless the member is a constant variable (<a href="../../../se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>An inner class may inherit <code>static</code> members that are not constant variables even though it cannot declare them.</p>
<p>A nested class that is not an inner class may declare <code>static</code> members freely, in accordance with the usual rules of the Java programming language.</p>
<div class="example">
<p>Example 8.1.3-1. Inner Class Declarations and Static Members</p>
<pre><code>class HasStatic {
    static int j = 100;
}
class Outer {
    class Inner extends HasStatic {
        static final int x = 3;  // OK: constant variable
        static int y = 4;  // Compile-time error: an inner class
    }
    static class NestedButNotInner{
        static int z = 5;    // OK: not an inner class
    }
    interface NeverInner {}  // Interfaces are never inner
}</code></pre>
</div>
<p>A statement or expression <em>occurs in a static context</em> if and only if the innermost method, constructor, instance initializer, static initializer, field initializer, or explicit constructor invocation statement enclosing the statement or expression is a static method, a static initializer, the variable initializer of a static variable, or an explicit constructor invocation statement (<a href="class-terminology-jls.html#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>An inner class <em>C</em> is a <em>direct inner class of a class or interface O</em> if <em>O</em> is the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>C</em> and the declaration of <em>C</em> does not occur in a static context.</p>
<blockquote>
<p><strong>If an inner class is a local class or an anonymous class, it may be declared in a static context, and in that case is not considered an inner class of any enclosing class or interface.</strong></p>
</blockquote>
<p>A class <em>C</em> is an <em>inner class of class or interface O</em> if it is either a direct inner class of <em>O</em> or an inner class of an inner class of <em>O</em>.</p>
<blockquote>
<p>It is unusual, but possible, for the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of an inner class to be an interface. This only occurs if the class is <strong>a local or anonymous class</strong> declared in a default <strong>or static</strong> method body (<a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a>). <del>Specifically, it occurs if an anonymous or local class is declared in a default method body, or a member class is declared in the body of an anonymous class that is declared in a default method body.</del></p>
</blockquote>
<div class="editorial">
<p>In that second example, the immediately enclosing type declaration is the anonymous class, not the interface.</p>
</div>
<p>A class or interface <em>O</em> is the <em>zeroth lexically enclosing type declaration of itself</em>.</p>
<p>A class <em>O</em> is the <em>n'th lexically enclosing type declaration of a class C</em> if it is the immediately enclosing type declaration of the <em>n-1</em>'th lexically enclosing type declaration of <em>C</em>.</p>
<p>An instance <em>i</em> of a direct inner class <em>C</em> of a class or interface <em>O</em> is associated with an instance of <em>O</em>, known as the <em>immediately enclosing instance of i</em>. The immediately enclosing instance of an object, if any, is determined when the object is created (<a href="class-terminology-jls.html#jls-15.9.2">15.9.2</a>).</p>
<p>An object <em>o</em> is the <em>zeroth lexically enclosing instance of itself</em>.</p>
<p>An object <em>o</em> is the <em>n'th lexically enclosing instance of an instance i</em> if it is the immediately enclosing instance of the <em>n-1</em>'th lexically enclosing instance of <em>i</em>.</p>
<p>An instance of <del>an inner class <em>I</em></del> <strong>a local class or an anonymous class</strong> whose declaration occurs in a static context has no lexically enclosing instances. <del>However, if <em>I</em> is immediately declared within a static method or static initializer then <em>I</em> does have an <em>enclosing block</em>, which is the innermost block statement lexically enclosing the declaration of <em>I</em>.</del></p>
<div class="editorial">
<p>The term &quot;enclosing block&quot; is never used outside of this paragraph. This section already includes an overwhelming amount of new terminology, so we're better off without this additional definition.</p>
</div>
<p>For every superclass <em>S</em> of <em>C</em> which is itself a direct inner class of a class or interface <em>SO</em>, there is an instance of <em>SO</em> associated with <em>i</em>, known as the <em>immediately enclosing instance of i with respect to S</em>. The immediately enclosing instance of an object with respect to its class'<strong>s</strong> direct superclass, if any, is determined when the superclass constructor is invoked via an explicit constructor invocation statement (<a href="class-terminology-jls.html#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>When an inner class (whose declaration does not occur in a static context) refers to an instance variable that is a member of a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration, the variable of the corresponding lexically enclosing instance is used.</p>
<p>Any local variable, formal parameter, or exception parameter used but not declared in an inner class must either be declared <code>final</code> or be effectively final (<a href="../../../se14/html/jls-4.html#jls-4.12.4">4.12.4</a>), or a compile-time error occurs where the use is attempted.</p>
<p>Any local variable used but not declared in an inner class must be definitely assigned (<a href="../../../se14/html/jls-16.html">16</a>) before the body of the inner class, or a compile-time error occurs.</p>
<blockquote>
<p>Similar rules on variable use apply in the body of a lambda expression (<a href="../../../se14/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p>
</blockquote>
<p>A blank <code>final</code> field (<a href="../../../se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) of a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration may not be assigned within an inner class, or a compile-time error occurs.</p>
<div class="example">
<p>Example 8.1.3-2. Inner Class Declarations</p>
<pre><code>class Outer {
    int i = 100;
    static void classMethod() {
        final int l = 200;
        class LocalInStaticContext {
            int k = i;  // Compile-time error
            int m = l;  // OK
        }
    }
    void foo() {
        class Local {  // A local class
            int j = i;
        }
    }
}</code></pre>
<p>The declaration of class <code>LocalInStaticContext</code> occurs in a static context due to being within the static method <code>classMethod</code>. Instance variables of class <code>Outer</code> are not available within the body of a static method. In particular, instance variables of <code>Outer</code> are not available inside the body of <code>LocalInStaticContext</code>. However, local variables from the surrounding method may be referred to without error (provided they are declared <code>final</code> or are effectively final).</p>
<p>Inner classes whose declarations do not occur in a static context may freely refer to the instance variables of their enclosing <del>type</del> <strong>class or interface</strong> declaration. An instance variable is always defined with respect to an instance. In the case of instance variables of an enclosing <del>type</del> <strong>class or interface</strong> declaration, the instance variable must be defined with respect to an enclosing instance of that <del>declared type</del> <strong>class or interface</strong>. For example, the class <code>Local</code> above has an enclosing instance of class <code>Outer</code>. As a further example:</p>
<pre><code>class WithDeepNesting {
    boolean toBe;
    WithDeepNesting(boolean b) { toBe = b; }

    class Nested {
        boolean theQuestion;
        class DeeplyNested {
            DeeplyNested(){
                theQuestion = toBe || !toBe;
            }
        }
    }
}</code></pre>
<p>Here, every instance of <code>WithDeepNesting.Nested.DeeplyNested</code> has an enclosing instance of class <code>WithDeepNesting.Nested</code> (its immediately enclosing instance) and an enclosing instance of class <code>WithDeepNesting</code> (its 2nd lexically enclosing instance).</p>
</div>
<h4 id="jls-8.1.6">8.1.6 Class Body and Member Declarations</h4>
<p>A <em>class body</em> may contain declarations of members of the class, that is, fields (<a href="../../../se14/html/jls-8.html#jls-8.3">8.3</a>), methods (<a href="../../../se14/html/jls-8.html#jls-8.4">8.4</a>), <strong>and</strong> classes <del>(<a href="class-terminology-jls.html#jls-8.5">8.5</a>),</del> and interfaces (<a href="class-terminology-jls.html#jls-8.5">8.5</a>).</p>
<p>A class body may also contain instance initializers (<a href="../../../se14/html/jls-8.html#jls-8.6">8.6</a>), static initializers (<a href="../../../se14/html/jls-8.html#jls-8.7">8.7</a>), and declarations of constructors (<a href="../../../se14/html/jls-8.html#jls-8.8">8.8</a>) for the class.</p>
<dl>
<dt><em>ClassBody:</em></dt>
<dd><code>{</code> {<em>ClassBodyDeclaration</em>} <code>}</code>
</dd>
<dt><em>ClassBodyDeclaration:</em></dt>
<dd><em>ClassMemberDeclaration</em>
</dd>
<dd><em>InstanceInitializer</em>
</dd>
<dd><em>StaticInitializer</em>
</dd>
<dd><em>ConstructorDeclaration</em>
</dd>
<dt><em>ClassMemberDeclaration:</em></dt>
<dd><em>FieldDeclaration</em>
</dd>
<dd><em>MethodDeclaration</em>
</dd>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><del><em>InterfaceDeclaration</em></del>
</dd>
<dd><strong><em>ClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><code>;</code>
</dd>
</dl>
<p>The scope and shadowing of a declaration of a member <em>m</em> declared in or inherited by a class type <em>C</em> is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<blockquote>
<p>If <em>C</em> itself is a nested class, there may be definitions of the same kind (variable, method, or type) and name as <em>m</em> in enclosing scopes. (The scopes may be blocks, classes, or packages.) In all such cases, the member <em>m</em> declared in or inherited by <em>C</em> shadows (<a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>) the other definitions of the same kind and name.</p>
</blockquote>
<h3 id="jls-8.5">8.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>A <em>member class</em> is a class whose declaration is directly enclosed in the body of another class or interface declaration (<a href="class-terminology-jls.html#jls-8.1.6">8.1.6</a>, <a href="class-terminology-jls.html#jls-9.1.4">9.1.4</a>). <strong>A member class may be an enum class (<a href="class-terminology-jls.html#jls-8.9">8.9</a>).</strong></p>
<p>A <em>member interface</em> is an interface whose declaration is directly enclosed in the body of another class or interface declaration (<a href="class-terminology-jls.html#jls-8.1.6">8.1.6</a>, <a href="class-terminology-jls.html#jls-9.1.4">9.1.4</a>). <strong>A member interface may be an annotation interface (<a href="class-terminology-jls.html#jls-9.6">9.6</a>).</strong></p>
<p>The accessibility of a member <del>type</del> <strong>class or interface</strong> declaration in a class is specified by its access modifier, or by <a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a> if lacking an access modifier.</p>
<p><del>It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in a class, or if a member type declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>.)</del></p>
<div class="editorial">
<p>This is already stated in <a href="class-terminology-jls.html#jls-8.1.1">8.1.1</a> and <a href="../../../se14/html/jls-9.html#jls-9.1.1">9.1.1</a>.</p>
</div>
<p><del>The scope and shadowing of a member type is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</del></p>
<div class="editorial">
<p>This is already stated in <a href="class-terminology-jls.html#jls-8.1">8.1</a> and <a href="class-terminology-jls.html#jls-9.1">9.1</a>.</p>
</div>
<p>If a class declares a member <del>type</del> <strong>class or interface</strong> with a certain name, then the declaration of that <del>type</del> <strong>class or interface</strong> is said to <em>hide</em> any and all accessible declarations of member <del>types</del> <strong>classes and interfaces</strong> with the same name in superclasses and superinterfaces of the class.</p>
<blockquote>
<p>In this respect, hiding of member <del>types</del> <strong>classes and interfaces</strong> is similar to hiding of fields (<a href="../../../se14/html/jls-8.html#jls-8.3">8.3</a>).</p>
</blockquote>
<p>A class inherits from its direct superclass and direct superinterfaces all the non-<code>private</code> member <del>types</del> <strong>classes and interfaces</strong> of the superclass and superinterfaces that are both accessible to code in the class and not hidden by a declaration in the class.</p>
<p>It is possible for a class to inherit more than one member <del>type</del> <strong>class or interface</strong> with the same name, either from its superclass and superinterfaces or from its superinterfaces alone. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the class to refer to any such member <del>type</del> <strong>class or interface</strong> by its simple name will result in a compile-time error, because the reference is ambiguous.</p>
<p>There might be several paths by which the same member <del>type</del> <strong>class or interface</strong> declaration is inherited from an interface. In such a situation, the member <del>type</del> <strong>class or interface</strong> is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<h4 id="jls-8.5.1">8.5.1 Static Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h4>
<p>The <code>static</code> keyword may modify the declaration of a member <del>type</del> <strong>class</strong> <em>C</em> within the body of a non-inner class or interface <em>T</em>. Its effect is to declare that <em>C</em> is not an inner class. Just as a <code>static</code> method of <em>T</em> has no current instance of <em>T</em> in its body, <em>C</em> also has no current instance of <em>T</em>, nor does it have any lexically enclosing instances.</p>
<p>It is a compile-time error if a <code>static</code> class contains a usage of a non-<code>static</code> member of an enclosing class.</p>
<p>A member interface is implicitly <code>static</code> (<a href="../../../se14/html/jls-9.html#jls-9.1.1">9.1.1</a>). It is permitted for the declaration of a member interface to redundantly specify the <code>static</code> modifier.</p>
<h3 id="jls-8.8">8.8 Constructor Declarations</h3>
<h4 id="jls-8.8.7">8.8.7 Constructor Body</h4>
<h5 id="jls-8.8.7.1">8.8.7.1 Explicit Constructor Invocations</h5>
<dl>
<dt><em>ExplicitConstructorInvocation:</em></dt>
<dd>[<em>TypeArguments</em>] <code>this</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd>[<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>ExpressionName</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
<dd><em>Primary</em> <code>.</code> [<em>TypeArguments</em>] <code>super</code> <code>(</code> [<em>ArgumentList</em>] <code>)</code> <code>;</code>
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="../../../se14/html/jls-4.html#jls-4.5.1">4.5.1</a> and <a href="../../../se14/html/jls-15.html#jls-15.12">15.12</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>TypeArguments:</em></dt>
<dd><code>&lt;</code> <em>TypeArgumentList</em> <code>&gt;</code>
</dd>
<dt><em>ArgumentList:</em></dt>
<dd><em>Expression</em> {<code>,</code> <em>Expression</em>}
</dd>
</dl>
</blockquote>
<p>Explicit constructor invocation statements are divided into two kinds:</p>
<ul>
<li><p><em>Alternate constructor invocations</em> begin with the keyword <code>this</code> (possibly prefaced with explicit type arguments). They are used to invoke an alternate constructor of the same class.</p></li>
<li><p><em>Superclass constructor invocations</em> begin with either the keyword <code>super</code> (possibly prefaced with explicit type arguments) or a <em>Primary</em> expression or an <em>ExpressionName</em>. They are used to invoke a constructor of the direct superclass. They are further divided:</p>
<ul>
<li><p><em>Unqualified superclass constructor invocations</em> begin with the keyword <code>super</code> (possibly prefaced with explicit type arguments).</p></li>
<li><p><em>Qualified superclass constructor invocations</em> begin with a <em>Primary</em> expression or an <em>ExpressionName</em>. They allow a subclass constructor to explicitly specify the newly created object's immediately enclosing instance with respect to the direct superclass (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>). This may be necessary when the superclass is an inner class.</p></li>
</ul></li>
</ul>
<p>An explicit constructor invocation statement in a constructor body may not refer to any instance variables or instance methods or inner classes declared in this class or any superclass, or use <code>this</code> or <code>super</code> in any expression; otherwise, a compile-time error occurs.</p>
<blockquote>
<p>This prohibition on using the current instance explains why an explicit constructor invocation statement is deemed to occur in a static context (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>).</p>
</blockquote>
<p>If <em>TypeArguments</em> is present to the left of <code>this</code> or <code>super</code>, then it is a compile-time error if any of the type arguments are wildcards (<a href="../../../se14/html/jls-4.html#jls-4.5.1">4.5.1</a>).</p>
<p>Let <em>C</em> be the class being instantiated, and let <em>S</em> be the direct superclass of <em>C</em>.</p>
<p>If a superclass constructor invocation statement is unqualified, then:</p>
<ul>
<li>If <em>S</em> is an inner member class, but <em>S</em> is not a member of a class enclosing <em>C</em>, then a compile-time error occurs.</li>
</ul>
<p>If a superclass constructor invocation statement is qualified, then:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>p</em> be the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, and let <em>O</em> be the immediately enclosing class of <em>S</em>. It is a compile-time error if the type of <em>p</em> is not <em>O</em> or a subclass of <em>O</em>, or if the type of <em>p</em> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p></li>
</ul>
<p>The exception types that an explicit constructor invocation statement can throw are specified in <a href="../../../se14/html/jls-11.html#jls-11.2.2">11.2.2</a>.</p>
<p>Evaluation of an alternate constructor invocation statement proceeds by first evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p>
<p>Evaluation of a superclass constructor invocation statement proceeds as follows:</p>
<ol type="1">
<li><p>Let <em>i</em> be the instance being created. The immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any) must be determined:</p>
<ul>
<li><p>If <em>S</em> is not an inner class, or if the declaration of <em>S</em> occurs in a static context, then no immediately enclosing instance of <em>i</em> with respect to <em>S</em> exists.</p></li>
<li><p>If the superclass constructor invocation is unqualified, then <em>S</em> is necessarily a local class or an inner member class.</p>
<p>If <em>S</em> is a local class, then let <em>O</em> be the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>S</em>.</p>
<p>If <em>S</em> is an inner member class, then let <em>O</em> be the innermost enclosing class of <em>C</em> of which <em>S</em> is a member.</p>
<p>Let <em>n</em> be an integer (<em>n</em> <em>≥</em> 1) such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>C</em>.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<blockquote>
<p>While it may be the case that <em>S</em> is a member of <em>C</em> due to inheritance, the zeroth lexically enclosing instance of <code>this</code> (that is, <code>this</code> itself) is never used as the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p>
</blockquote></li>
<li><p>If the superclass constructor invocation is qualified, then the <em>Primary</em> expression or the <em>ExpressionName</em> immediately preceding &quot;<code>.super</code>&quot;, <em>p</em>, is evaluated.</p>
<p>If <em>p</em> evaluates to <code>null</code>, a <code>NullPointerException</code> is raised, and the superclass constructor invocation completes abruptly.</p>
<p>Otherwise, the result of this evaluation is the immediately enclosing instance of <em>i</em> with respect to <em>S</em>.</p></li>
</ul></li>
<li><p>After determining the immediately enclosing instance of <em>i</em> with respect to <em>S</em> (if any), evaluation of the superclass constructor invocation statement proceeds by evaluating the arguments to the constructor, left-to-right, as in an ordinary method invocation; and then invoking the constructor.</p></li>
<li><p>Finally, if the superclass constructor invocation statement completes normally, then all instance variable initializers of <em>C</em> and all instance initializers of <em>C</em> are executed. If an instance initializer or instance variable initializer <em>I</em> textually precedes another instance initializer or instance variable initializer <em>J</em>, then <em>I</em> is executed before <em>J</em>.</p>
<p>Execution of instance variable initializers and instance initializers is performed regardless of whether the superclass constructor invocation actually appears as an explicit constructor invocation statement or is provided implicitly. (An alternate constructor invocation does not perform this additional implicit execution.)</p></li>
</ol>
<div class="example">
<p>Example 8.8.7.1-1. Restrictions on Explicit Constructor Invocation Statements</p>
<p>If the first constructor of <code>ColoredPoint</code> in the example from <a href="../../../se14/html/jls-8.html#jls-8.8.7">8.8.7</a> were changed as follows:</p>
<pre><code>class Point {
    int x, y;
    Point(int x, int y) { this.x = x; this.y = y; }
}
class ColoredPoint extends Point {
    static final int WHITE = 0, BLACK = 1;
    int color;
    ColoredPoint(int x, int y) {
        this(x, y, color);  // Changed to color from WHITE
    }
    ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = color;
    }
}</code></pre>
<p>then a compile-time error would occur, because the instance variable <code>color</code> cannot be used by a explicit constructor invocation statement.</p>
</div>
<div class="example">
<p>Example 8.8.7.1-2. Qualified Superclass Constructor Invocation</p>
<p>In the code below, <code>ChildOfInner</code> has no lexically enclosing <del>type</del> <strong>class or interface</strong> declaration, so an instance of <code>ChildOfInner</code> has no enclosing instance. However, the superclass of <code>ChildOfInner</code> (<code>Inner</code>) has a lexically enclosing <del>type</del> <strong>class</strong> declaration (<code>Outer</code>), and an instance of <code>Inner</code> must have an enclosing instance of <code>Outer</code>. The enclosing instance of <code>Outer</code> is set when an instance of <code>Inner</code> is created. Therefore, when we create an instance of <code>ChildOfInner</code>, which is implicitly an instance of <code>Inner</code>, we must provide the enclosing instance of <code>Outer</code> via a qualified superclass invocation statement in <code>ChildOfInner</code>'s constructor. The instance of <code>Outer</code> is called the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code>.</p>
<pre><code>class Outer {
    class Inner {}
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner() { (new Outer()).super(); }
}</code></pre>
<p>Perhaps surprisingly, the same instance of <code>Outer</code> may serve as the immediately enclosing instance of <code>ChildOfInner</code> with respect to <code>Inner</code> <em>for multiple instances of <code>ChildOfInner</code></em>. These instances of <code>ChildOfInner</code> are implicitly linked to the same instance of <code>Outer</code>. The program below achieves this by passing an instance of <code>Outer</code> to the constructor of <code>ChildOfInner</code>, which uses the instance in a qualified superclass constructor invocation statement. The rules for an explicit constructor invocation statement do not prohibit using formal parameters of the constructor that contains the statement.</p>
<pre><code>class Outer {
    int secret = 5;
    class Inner {
        int  getSecret()      { return secret; }
        void setSecret(int s) { secret = s; }
    }
}
class ChildOfInner extends Outer.Inner {
    ChildOfInner(Outer x) { x.super(); }
}

public class Test {
    public static void main(String[] args) {
        Outer x = new Outer();
        ChildOfInner a = new ChildOfInner(x);
        ChildOfInner b = new ChildOfInner(x);
        System.out.println(b.getSecret());
        a.setSecret(6);
        System.out.println(b.getSecret());
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>5
6</code></pre>
<p>The effect is that manipulation of instance variables in the common instance of <code>Outer</code> is visible through references to different instances of <code>ChildOfInner</code>, even though such references are not aliases in the conventional sense.</p>
</div>
<h3 id="jls-8.9">8.9 Enum <del>Types</del> <strong>Classes</strong></h3>
<p>An <em>enum declaration</em> specifies a new <em>enum <del>type</del> <strong>class</strong></em>, a special kind of class <del>type</del> <strong>that defines a small set of named class instances</strong>.</p>
<dl>
<dt><em>EnumDeclaration:</em></dt>
<dd>{<em>ClassModifier</em>} <code>enum</code> <em>TypeIdentifier</em> [<em>Superinterfaces</em>] <em>EnumBody</em>
</dd>
</dl>
<p><strong>An enum declaration may specify a top level enum class (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) or a member enum class (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>).</strong></p>
<p>It is a compile-time error if an enum declaration has the modifier <code>abstract</code> or <code>final</code>.</p>
<p>An enum declaration is implicitly <code>final</code> unless it contains at least one enum constant that has a class body (<a href="class-terminology-jls.html#jls-8.9.1">8.9.1</a>).</p>
<p>A <del>nested</del> <strong>member</strong> enum <del>type</del> <strong>declaration</strong> is implicitly <code>static</code>. It is permitted for the declaration of a <del>nested</del> <strong>member</strong> enum <del>type</del> <strong>class</strong> to redundantly specify the <code>static</code> modifier.</p>
<blockquote>
<p>This implies that it is impossible to declare an enum <del>type</del> <strong>class</strong> <del>in the body of</del> <strong>as a member of</strong> an inner class (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>), because an inner class cannot have <code>static</code> members except for constant variables.</p>
</blockquote>
<p>It is a compile-time error if the same keyword appears more than once as a modifier for an enum declaration, or if an enum declaration has more than one of the access modifiers <code>public</code>, <code>protected</code>, and <code>private</code> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>The direct superclass <strong>type</strong> of an enum <del>type</del> <strong>class</strong> <em>E</em> is <code>Enum&lt;</code><em>E</em><code>&gt;</code> (<a href="../../../se14/html/jls-8.html#jls-8.1.4">8.1.4</a>).</p>
<p>An enum <del>type</del> <strong>class</strong> has no instances other than those defined by its enum constants. It is a compile-time error to attempt to explicitly instantiate an enum <del>type</del> <strong>class</strong> (<a href="../../../se14/html/jls-15.html#jls-15.9.1">15.9.1</a>).</p>
<blockquote>
<p>In addition to the compile-time error, three further mechanisms ensure that no instances of an enum <del>type</del> <strong>class</strong> exist beyond those defined by its enum constants:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The <code>final</code> <code>clone</code> method in <code>Enum</code> ensures that enum constants can never be cloned.</p></li>
<li><p>Reflective instantiation of enum <del>types</del> <strong>classes</strong> is prohibited.</p></li>
<li><p>Special treatment by the serialization mechanism ensures that duplicate instances are never created as a result of deserialization.</p></li>
</ul>
</blockquote>
<h4 id="jls-8.9.1">8.9.1 Enum Constants</h4>
<p>The body of an enum declaration may contain <em>enum constants</em>. An enum constant defines an instance of the enum <del>type</del> <strong>class</strong>.</p>
<dl>
<dt><em>EnumBody:</em></dt>
<dd><code>{</code> [<em>EnumConstantList</em>] [<code>,</code>] [<em>EnumBodyDeclarations</em>] <code>}</code>
</dd>
<dt><em>EnumConstantList:</em></dt>
<dd><em>EnumConstant</em> {<code>,</code> <em>EnumConstant</em>}
</dd>
<dt><em>EnumConstant:</em></dt>
<dd>{<em>EnumConstantModifier</em>} <em>Identifier</em> [<code>(</code> [<em>ArgumentList</em>] <code>)</code>] [<em>ClassBody</em>]
</dd>
<dt><em>EnumConstantModifier:</em></dt>
<dd><em>Annotation</em>
</dd>
</dl>
<blockquote>
<p>The following production from <a href="../../../se14/html/jls-15.html#jls-15.12">15.12</a> is shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>ArgumentList:</em></dt>
<dd><em>Expression</em> {<code>,</code> <em>Expression</em>}
</dd>
</dl>
</blockquote>
<p>The rules for annotation modifiers on an enum constant declaration are specified in <a href="../../../se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>The <em>Identifier</em> in a <em>EnumConstant</em> may be used in a name to refer to the enum constant.</p>
<p>The scope and shadowing of an enum constant is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>An enum constant may be followed by arguments, which are passed to the constructor of the enum when the constant is created during class initialization as described later in this section. The constructor to be invoked is chosen using the normal rules of overload resolution (<a href="../../../se14/html/jls-15.html#jls-15.12.2">15.12.2</a>). If the arguments are omitted, an empty argument list is assumed.</p>
<p>The optional class body of an enum constant implicitly defines an anonymous class declaration (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>) that extends the immediately enclosing enum <del>type</del> <strong>class</strong>. The class body is governed by the usual rules of anonymous classes; in particular it cannot contain any constructors. Instance methods declared in these class bodies may be invoked outside the enclosing enum <del>type</del> <strong>class</strong> only if they override accessible methods in the enclosing enum <del>type</del> <strong>class</strong> (<a href="../../../se14/html/jls-8.html#jls-8.4.8">8.4.8</a>).</p>
<p>It is a compile-time error for the class body of an enum constant to declare an <code>abstract</code> method.</p>
<p>Because there is only one instance of each enum constant, it is permitted to use the <code>==</code> operator in place of the <code>equals</code> method when comparing two object references if it is known that at least one of them refers to an enum constant.</p>
<blockquote>
<p>The <code>equals</code> method in <code>Enum</code> is a <code>final</code> method that merely invokes <code>super.equals</code> on its argument and returns the result, thus performing an identity comparison.</p>
</blockquote>
<h4 id="jls-8.9.2">8.9.2 Enum Body Declarations</h4>
<p>In addition to enum constants, the body of an enum declaration may contain constructor and member declarations as well as instance and static initializers.</p>
<dl>
<dt><em>EnumBodyDeclarations:</em></dt>
<dd><code>;</code> {<em>ClassBodyDeclaration</em>}
</dd>
</dl>
<blockquote>
<p>The following productions from <a href="class-terminology-jls.html#jls-8.1.6">8.1.6</a> are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>ClassBodyDeclaration:</em></dt>
<dd><em>ClassMemberDeclaration</em>
</dd>
<dd><em>InstanceInitializer</em>
</dd>
<dd><em>StaticInitializer</em>
</dd>
<dd><em>ConstructorDeclaration</em>
</dd>
<dt><em>ClassMemberDeclaration:</em></dt>
<dd><em>FieldDeclaration</em>
</dd>
<dd><em>MethodDeclaration</em>
</dd>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><del><em>InterfaceDeclaration</em></del>
</dd>
<dd><strong><em>ClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><code>;</code>
</dd>
</dl>
</blockquote>
<p>Any constructor or member declarations in the body of an enum declaration apply to the enum <del>type</del> <strong>class</strong> exactly as if they had been present in the body of a normal class declaration, unless explicitly stated otherwise.</p>
<p>It is a compile-time error if a constructor declaration in an enum declaration is <code>public</code> or <code>protected</code> (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>).</p>
<p>It is a compile-time error if a constructor declaration in an enum declaration contains a superclass constructor invocation statement (<a href="class-terminology-jls.html#jls-8.8.7.1">8.8.7.1</a>).</p>
<p>It is a compile-time error to refer to a <code>static</code> field of an enum <del>type</del> <strong>class</strong> from a constructor, instance initializer, or instance variable initializer of the enum <del>type</del> <strong>declaration</strong>, unless the field is a constant variable (<a href="../../../se14/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p>
<p>In an enum declaration, a constructor declaration with no access modifiers is <code>private</code>.</p>
<p>In an enum declaration with no constructor declarations, a default constructor is implicitly declared. The default constructor is <code>private</code>, has no formal parameters, and has no <code>throws</code> clause.</p>
<blockquote>
<p>In practice, a compiler is likely to mirror the <code>Enum</code> <del>type</del> <strong>class</strong> by declaring <code>String</code> and <code>int</code> parameters in the default constructor of an enum type. However, these parameters are not specified as &quot;implicitly declared&quot; because different compilers do not need to agree on the form of the default constructor. Only the compiler of an enum <del>type</del> <strong>declaration</strong> knows how to instantiate the enum constants; other compilers can simply rely on the implicitly declared <code>public</code> <code>static</code> fields of the enum <del>type</del> <strong>class</strong> (<a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>) without regard for how those fields were initialized.</p>
</blockquote>
<p>It is a compile-time error if an enum declaration <em>E</em> has an <code>abstract</code> method <em>m</em> as a member, unless <em>E</em> has at least one enum constant and all of <em>E</em>'s enum constants have class bodies that provide concrete implementations of <em>m</em>.</p>
<p>It is a compile-time error for an enum declaration to declare a finalizer (<a href="../../../se14/html/jls-12.html#jls-12.6">12.6</a>). An instance of an enum <del>type</del> <strong>class</strong> may never be finalized.</p>
<div class="example">
<p>Example 8.9.2-1. Enum Body Declarations</p>
<pre><code>enum Coin {
    PENNY(1), NICKEL(5), DIME(10), QUARTER(25);
    Coin(int value) { this.value = value; }

    private final int value;
    public int value() { return value; }
}</code></pre>
<p>Each enum constant arranges for a different value in the field <code>value</code>, passed in via a constructor. The field represents the value, in cents, of an American coin. Note that there are no restrictions on the parameters that may be declared by an enum <del>type's</del> <strong>class's</strong> constructor.</p>
</div>
<div class="example">
<p>Example 8.9.2-2. Restriction On Enum Constant Self-Reference</p>
<p>Without the rule on <code>static</code> field access, apparently reasonable code would fail at run time due to the initialization circularity inherent in enum <del>types</del> <strong>classes</strong>. (A circularity exists in any class with a &quot;self-typed&quot; <code>static</code> field.) Here is an example of the sort of code that would fail:</p>
<pre><code>import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;
    Color() { colorMap.put(toString(), this); }

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
}</code></pre>
<p>Static initialization of this enum would throw a <code>NullPointerException</code> because the <code>static</code> variable <code>colorMap</code> is uninitialized when the constructors for the enum constants run. The restriction above ensures that such code cannot be compiled. However, the code can easily be refactored to work properly:</p>
<pre><code>import java.util.Map;
import java.util.HashMap;

enum Color {
    RED, GREEN, BLUE;

    static final Map&lt;String,Color&gt; colorMap =
        new HashMap&lt;String,Color&gt;();
    static {
        for (Color c : Color.values())
            colorMap.put(c.toString(), c);
    }
}</code></pre>
<p>The refactored version is clearly correct, as static initialization occurs top to bottom.</p>
</div>
<h4 id="jls-8.9.3">8.9.3 Enum Members</h4>
<p>The members of an enum <del>type</del> <strong>class</strong> <em>E</em> are all of the following:</p>
<ul>
<li><p>Members declared in the body of the declaration of <em>E</em>.</p></li>
<li><p>Members inherited from <code>Enum&lt;</code><em>E</em><code>&gt;</code>.</p></li>
<li><p>For each enum constant <em>c</em> declared in the body of the declaration of <em>E</em>, <em>E</em> has an implicitly declared <code>public</code> <code>static</code> <code>final</code> field of type <em>E</em> that has the same name as <em>c</em>. The field has a variable initializer which instantiates <em>E</em> and passes any arguments of <em>c</em> to the constructor chosen for <em>E</em>. The field has the same annotations as <em>c</em> (if any).</p>
<p>These fields are implicitly declared in the same order as the corresponding enum constants, before any <code>static</code> fields explicitly declared in the body of the declaration of <em>E</em>.</p>
<p>An enum constant is said to be <em>created</em> when the corresponding implicitly declared field is initialized.</p></li>
<li><p>An implicitly declared method <code>public</code> <code>static</code> <em>E</em><code>[]</code> <code>values()</code>, which returns an array containing the enum constants of <em>E</em>, in the same order as they appear in the body of the declaration of <em>E</em>.</p></li>
<li><p>An implicitly declared method <code>public</code> <code>static</code> <em>E</em> <code>valueOf(String name)</code>, which returns the enum constant of <em>E</em> with the specified name.</p></li>
<li><p>The following implicitly declared methods:</p>
<pre><code>/**
* Returns an array containing the constants of this enum </code></pre>
<pre class="deleted"><code>* type, in the order they&#39;re declared.  This method may be</code></pre>
<pre class="inserted"><code>* class, in the order they&#39;re declared.  This method may be</code></pre>
<pre><code>* used to iterate over the constants as follows:
*
*    for(E c : E.values())
*        System.out.println(c);
*
* @return an array containing the constants of this enum </code></pre>
<pre class="deleted"><code>* type, in the order they&#39;re declared</code></pre>
<pre class="inserted"><code>* class, in the order they&#39;re declared</code></pre>
<pre><code>*/
public static E[] values();

/**</code></pre>
<pre class="deleted"><code>* Returns the enum constant of this type with the specified</code></pre>
<pre class="inserted"><code>* Returns the enum constant of this class with the specified</code></pre>
<pre><code>* name.
* The string must match exactly an identifier used to declare</code></pre>
<pre class="deleted"><code>* an enum constant in this type.  (Extraneous whitespace </code></pre>
<pre class="inserted"><code>* an enum constant in this class.  (Extraneous whitespace </code></pre>
<pre><code>* characters are not permitted.)
* 
* @return the enum constant with the specified name</code></pre>
<pre class="deleted"><code>* @throws IllegalArgumentException if this enum type has no</code></pre>
<pre class="inserted"><code>* @throws IllegalArgumentException if this enum class has no</code></pre>
<pre><code>* constant with the specified name
*/
public static E valueOf(String name);</code></pre></li>
</ul>
<blockquote>
<p>It follows that the declaration of enum <del>type</del> <strong>class</strong> <em>E</em> cannot contain fields that conflict with the implicitly declared fields corresponding to <em>E</em>'s enum constants, nor contain methods that conflict with implicitly declared methods or override <code>final</code> methods of class <code>Enum&lt;</code><em>E</em><code>&gt;</code>.</p>
</blockquote>
<div class="example">
<p>Example 8.9.3-1. Iterating Over Enum Constants With An Enhanced <code>for</code> Loop</p>
<pre><code>public class Test {
    enum Season { WINTER, SPRING, SUMMER, FALL }

    public static void main(String[] args) {
        for (Season s : Season.values())
            System.out.println(s);
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>WINTER
SPRING
SUMMER
FALL</code></pre>
</div>
<div class="example">
<p>Example 8.9.3-2. Switching Over Enum Constants</p>
<p>A <code>switch</code> statement (<a href="../../../se14/html/jls-14.html#jls-14.11">14.11</a>) is useful for simulating the addition of a method to an enum <del>type</del> <strong>class</strong> from outside the <del>type</del> <strong>class</strong>. This example &quot;adds&quot; a <code>color</code> method to the <code>Coin</code> <del>type</del> <strong>class</strong> from <a href="class-terminology-jls.html#jls-8.9.2">8.9.2</a>, and prints a table of coins, their values, and their colors.</p>
<pre><code>class Test {
    enum CoinColor { COPPER, NICKEL, SILVER }

    static CoinColor color(Coin c) {
        switch (c) {
            case PENNY:
                return CoinColor.COPPER;
            case NICKEL:
                return CoinColor.NICKEL;
            case DIME: case QUARTER:
                return CoinColor.SILVER;
            default:
                throw new AssertionError(&quot;Unknown coin: &quot; + c);
        }
    }

    public static void main(String[] args) {
        for (Coin c : Coin.values())
            System.out.println(c + &quot;\t\t&quot; +
                               c.value() + &quot;\t&quot; + color(c));
    }
}</code></pre>
<p>This program produces the output:</p>
<pre><code>PENNY           1       COPPER
NICKEL          5       NICKEL
DIME            10      SILVER
QUARTER         25      SILVER</code></pre>
</div>
<div class="example">
<p>Example 8.9.3-3. Enum Constants with Class Bodies</p>
<pre><code>enum Operation {
    PLUS {
        double eval(double x, double y) { return x + y; }
    },
    MINUS {
        double eval(double x, double y) { return x - y; }
    },
    TIMES {
        double eval(double x, double y) { return x * y; }
    },
    DIVIDED_BY {
        double eval(double x, double y) { return x / y; }
    };

    // Each constant supports an arithmetic operation
    abstract double eval(double x, double y);

    public static void main(String args[]) {
        double x = Double.parseDouble(args[0]);
        double y = Double.parseDouble(args[1]);
        for (Operation op : Operation.values())
            System.out.println(x + &quot; &quot; + op + &quot; &quot; + y +
                               &quot; = &quot; + op.eval(x, y));
    }
}</code></pre>
<p>Class bodies attach behaviors to the enum constants. The program produces the output:</p>
<pre><code>java Operation 2.0 4.0
2.0 PLUS 4.0 = 6.0
2.0 MINUS 4.0 = -2.0
2.0 TIMES 4.0 = 8.0
2.0 DIVIDED_BY 4.0 = 0.5</code></pre>
<p>This pattern is much safer than using a <code>switch</code> statement in the base <del>type</del> <strong>class</strong> (<code>Operation</code>), as the pattern precludes the possibility of forgetting to add a behavior for a new constant (since the enum declaration would cause a compile-time error).</p>
</div>
<div class="example">
<p>Example 8.9.3-4. Multiple Enum <del>Types</del> <strong>Classes</strong></p>
<p>In the following program, a playing card class is built atop two simple enums.</p>
<pre><code>import java.util.List;
import java.util.ArrayList;
class Card implements Comparable&lt;Card&gt;,
                      java.io.Serializable {
    public enum Rank { DEUCE, THREE, FOUR, FIVE, SIX, SEVEN,
                       EIGHT, NINE, TEN,JACK, QUEEN, KING, ACE }

    public enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES }

    private final Rank rank;
    private final Suit suit;
    public Rank rank() { return rank; }
    public Suit suit() { return suit; }

    private Card(Rank rank, Suit suit) {
        if (rank == null || suit == null)
            throw new NullPointerException(rank + &quot;, &quot; + suit);
        this.rank = rank;
        this.suit = suit;
    }

    public String toString() { return rank + &quot; of &quot; + suit; }

    // Primary sort on suit, secondary sort on rank
    public int compareTo(Card c) {
        int suitCompare = suit.compareTo(c.suit);
        return (suitCompare != 0 ?
                    suitCompare :
                    rank.compareTo(c.rank));
    }

    private static final List&lt;Card&gt; prototypeDeck =
        new ArrayList&lt;Card&gt;(52);

    static {
        for (Suit suit : Suit.values())
            for (Rank rank : Rank.values())
                prototypeDeck.add(new Card(rank, suit));
    }

    // Returns a new deck
    public static List&lt;Card&gt; newDeck() {
        return new ArrayList&lt;Card&gt;(prototypeDeck);
    }
}</code></pre>
<p>The following program exercises the <code>Card</code> class. It takes two integer parameters on the command line, representing the number of hands to deal and the number of cards in each hand:</p>
<pre><code>import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
class Deal {
    public static void main(String args[]) {
        int numHands     = Integer.parseInt(args[0]);
        int cardsPerHand = Integer.parseInt(args[1]);
        List&lt;Card&gt; deck  = Card.newDeck();
        Collections.shuffle(deck);
        for (int i=0; i &lt; numHands; i++)
            System.out.println(dealHand(deck, cardsPerHand));
    }

    /**
     * Returns a new ArrayList consisting of the last n
     * elements of deck, which are removed from deck.
     * The returned list is sorted using the elements&#39;
     * natural ordering.
     */
    public static &lt;E extends Comparable&lt;E&gt;&gt;
    ArrayList&lt;E&gt; dealHand(List&lt;E&gt; deck, int n) {
        int deckSize = deck.size();
        List&lt;E&gt; handView = deck.subList(deckSize - n, deckSize);
        ArrayList&lt;E&gt; hand = new ArrayList&lt;E&gt;(handView);
        handView.clear();
        Collections.sort(hand);
        return hand;
    }
}</code></pre>
<p>The program produces the output:</p>
<pre><code>java Deal 4 3
[DEUCE of CLUBS, SEVEN of CLUBS, QUEEN of DIAMONDS]
[NINE of HEARTS, FIVE of SPADES, ACE of SPADES]
[THREE of HEARTS, SIX of HEARTS, TEN of SPADES]
[TEN of CLUBS, NINE of DIAMONDS, THREE of SPADES]</code></pre>
</div>
<h2 id="jls-9">Chapter 9: Interfaces</h2>
<p>An interface declaration introduces a new <strong>abstract</strong> reference type <del>whose members are classes, interfaces, constants, and methods</del> <strong>that can be implemented by one or more classes</strong>. <strong>Programs can use interfaces to provide a common supertype for otherwise-unrelated classes.</strong></p>
<p><del>This type has</del> <strong>Interfaces have</strong> no instance variables, and typically <del>declares</del> <strong>declare</strong> one or more <code>abstract</code> methods; otherwise unrelated classes can implement <del>the</del> <strong>an</strong> interface by providing implementations for its <code>abstract</code> methods. Interfaces may not be directly instantiated.</p>
<p><del>A <em>nested interface</em> is any interface whose declaration occurs within the body of another class or interface.</del></p>
<p><del>A <em>top level interface</em> is an interface that is not a nested interface.</del></p>
<p><strong>A <em>top level interface</em> (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) is an interface that is declared at the top level of a compilation unit.</strong></p>
<p><strong>A <em>nested interface</em> is any interface whose declaration occurs as a <em>member interface</em> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>) of another class or interface.</strong></p>
<p><del>We distinguish between two kinds of interfaces - normal interfaces and annotation types.</del></p>
<p><strong>An <em>annotation interface</em> (<a href="class-terminology-jls.html#jls-9.6">9.6</a>) is an interface declared with special syntax, intended to be implemented by reflective representations of <em>annotations</em> (<a href="../../../se14/html/jls-9.html#jls-9.7">9.7</a>).</strong></p>
<p>This chapter discusses the common semantics of all interfaces <del>- normal interfaces, both top level (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) and nested (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>), and annotation types (<a href="class-terminology-jls.html#jls-9.6">9.6</a>)</del>. Details that are specific to particular kinds of interfaces are discussed in the sections dedicated to these constructs.</p>
<p><del>Programs can use interfaces to make it unnecessary for related classes to share a common <code>abstract</code> superclass or to add methods to <code>Object</code>.</del></p>
<p>An interface may be declared to be a <em>direct extension</em> of one or more other interfaces, meaning that it inherits all the member <del>types</del> <strong>classes and interfaces</strong>, instance methods, and <del>constants</del> <strong><code>static</code> fields</strong> of the interfaces it extends, except for any members that it may override or hide.</p>
<p>A class may be declared to <em>directly implement</em> one or more interfaces, meaning that any instance of the class implements all the <code>abstract</code> methods specified by the interface or interfaces. A class necessarily implements all the interfaces that its direct superclasses and direct superinterfaces do. This (multiple) interface inheritance allows objects to support (multiple) common behaviors without sharing a superclass.</p>
<p>A variable whose declared type is an interface type may have as its value a reference to any instance of a class which implements the specified interface. It is not sufficient that the class happen to implement all the <code>abstract</code> methods of the interface; the class or one of its superclasses must actually be declared to implement the interface, or else the class is not considered to implement the interface.</p>
<h3 id="jls-9.1">9.1 Interface Declarations</h3>
<p>An <em>interface declaration</em> specifies a new named reference type. <del>There are two kinds of interface declarations - <em>normal interface declarations</em> and <em>annotation type declarations</em> (<a href="class-terminology-jls.html#jls-9.6">9.6</a>).</del></p>
<div class="deleted">
<dl>
<dt><em>InterfaceDeclaration:</em></dt>
<dd><em>NormalInterfaceDeclaration</em>
</dd>
<dd><em>AnnotationTypeDeclaration</em>
</dd>
</dl>
</div>
<dl>
<dt><del><em>NormalInterfaceDeclaration:</em></del> <strong><em>InterfaceDeclaration:</em></strong></dt>
<dd>{<em>InterfaceModifier</em>} <code>interface</code> <em>TypeIdentifier</em> [<em>TypeParameters</em>]<br />
[<em>ExtendsInterfaces</em>] <em>InterfaceBody</em>
</dd>
</dl>
<p>The <em>TypeIdentifier</em> in an interface declaration specifies the name of the interface.</p>
<p>It is a compile-time error if an interface has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of an interface declaration is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a> and <a href="../../../se14/html/jls-6.html#jls-6.4">6.4</a>.</p>
<h4 id="jls-9.1.4">9.1.4 Interface Body and Member Declarations</h4>
<p>The body of an interface may declare members of the interface, that is, fields (<a href="../../../se14/html/jls-9.html#jls-9.3">9.3</a>), methods (<a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a>), <strong>and</strong> classes <del>(<a href="class-terminology-jls.html#jls-9.5">9.5</a>),</del> and interfaces (<a href="class-terminology-jls.html#jls-9.5">9.5</a>).</p>
<dl>
<dt><em>InterfaceBody:</em></dt>
<dd><code>{</code> {<em>InterfaceMemberDeclaration</em>} <code>}</code>
</dd>
<dt><em>InterfaceMemberDeclaration:</em></dt>
<dd><em>ConstantDeclaration</em>
</dd>
<dd><em>InterfaceMethodDeclaration</em>
</dd>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><del><em>InterfaceDeclaration</em></del>
</dd>
<dd><strong><em>ClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><code>;</code>
</dd>
</dl>
<p>The scope of a declaration of a member <em>m</em> declared in or inherited by an interface <del>type</del> <em>I</em> is specified in <a href="class-terminology-jls.html#jls-6.3">6.3</a>.</p>
<h3 id="jls-9.5">9.5 Member <del>Type</del> <strong>Class and Interface</strong> Declarations</h3>
<p>Interfaces may contain member <del>type</del> <strong>class and interface</strong> declarations (<a href="class-terminology-jls.html#jls-8.5">8.5</a>).</p>
<p>Every member <del>type</del> <strong>class or interface</strong> declaration in the body of an interface is implicitly <code>public</code> and <code>static</code>. It is permitted to redundantly specify either or both of these modifiers.</p>
<p>It is a compile-time error if a member <del>type</del> <strong>class or interface</strong> declaration in an interface has the modifier <code>protected</code> or <code>private</code>.</p>
<p><del>It is a compile-time error if the same keyword appears more than once as a modifier for a member type declaration in an interface.</del></p>
<div class="editorial">
<p>This is already stated in <a href="class-terminology-jls.html#jls-8.1.1">8.1.1</a> and <a href="../../../se14/html/jls-9.html#jls-9.1.1">9.1.1</a>.</p>
</div>
<p>If an interface declares a member <del>type</del> <strong>class or interface</strong> with a certain name, then the declaration of that <del>type</del> <strong>class or interface</strong> is said to <em>hide</em> any and all accessible declarations of member <del>types</del> <strong>classes and interfaces</strong> with the same name in superinterfaces of the interface.</p>
<p>An interface inherits from its direct superinterfaces all the <del>non-<code>private</code></del> member <del>types</del> <strong>classes and interfaces</strong> of the superinterfaces that are <del>both accessible to code in the interface and</del> not hidden by a declaration in the interface.</p>
<div class="editorial">
<p>All member classes and interfaces of the superinterfaces are <code>public</code>, so we don't need to consider their acccessibility here.</p>
</div>
<p>It is possible for an interface to inherit more than one member <del>type</del> <strong>class or interface</strong> with the same name. Such a situation does not in itself cause a compile-time error. However, any attempt within the body of the interface to refer to any such member <del>type</del> <strong>class or interface</strong> by its simple name will result in a compile-time error, because the reference is ambiguous.</p>
<p>There might be several paths by which the same member <del>type</del> <strong>class or interface</strong> declaration is inherited from an interface. In such a situation, the member <del>type</del> <strong>class or interface</strong> is considered to be inherited only once, and it may be referred to by its simple name without ambiguity.</p>
<h3 id="jls-9.6">9.6 Annotation <del>Types</del> <strong>Interfaces</strong></h3>
<p>An <em>annotation <del>type</del> declaration</em> specifies a new <em>annotation <del>type</del> <strong>interface</strong></em>, a special kind of interface <del>type</del>. To distinguish an annotation <del>type</del> declaration from a normal interface declaration, the keyword <code>interface</code> is preceded by an <del>at-sign</del> <strong>at sign</strong> (<code>@</code>).</p>
<dl>
<dt><del><em>AnnotationTypeDeclaration:</em></del> <strong><em>AnnotationDeclaration:</em></strong></dt>
<dd>{<em>InterfaceModifier</em>} <code>@</code> <code>interface</code> <em>TypeIdentifier</em> <del><em>AnnotationTypeBody</em></del> <strong><em>AnnotationInterfaceBody</em></strong>
</dd>
</dl>
<blockquote>
<p>Note that the <del>at-sign</del> <strong>at sign</strong> (<code>@</code>) and the keyword <code>interface</code> are distinct tokens. It is possible to separate them with whitespace, but this is discouraged as a matter of style.</p>
</blockquote>
<p>The rules for annotation modifiers on an annotation <del>type</del> declaration are specified in <a href="../../../se14/html/jls-9.html#jls-9.7.4">9.7.4</a> and <a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>.</p>
<p>The <em>TypeIdentifier</em> in an annotation <del>type</del> declaration specifies the name of the annotation <del>type</del> <strong>interface</strong>.</p>
<p>It is a compile-time error if an annotation <del>type</del> <strong>interface</strong> has the same simple name as any of its enclosing classes or interfaces.</p>
<p>The direct superinterface of every annotation <del>type</del> <strong>interface</strong> is <code>java.lang.annotation.Annotation</code>.</p>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeDeclaration</em></del> <strong><em>AnnotationInterfaceDeclaration</em></strong> syntax, an annotation <del>type</del> <strong>interface</strong> declaration cannot be generic, and no <code>extends</code> clause is permitted.</p>
</blockquote>
<blockquote>
<p>A consequence of the fact that an annotation <del>type</del> <strong>interface</strong> cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation <del>type</del> <strong>interface</strong> is never itself an annotation <del>type</del> <strong>interface</strong>. Similarly, <code>java.lang.annotation.Annotation</code> is not itself an annotation <del>type</del> <strong>interface</strong>.</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> inherits several members from <code>java.lang.annotation.Annotation</code>, including the implicitly declared methods corresponding to the instance methods of <code>Object</code>, yet these methods do not define elements of the annotation <del>type</del> <strong>interface</strong> (<a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a>).</p>
<blockquote>
<p>Because these methods do not define elements of the annotation <del>type</del> <strong>interface</strong>, it is illegal to use them in annotations of that type (<a href="../../../se14/html/jls-9.html#jls-9.7">9.7</a>). Without this rule, we could not ensure that elements were of the types representable in annotations, or that accessor methods for them would be available.</p>
</blockquote>
<p>Unless explicitly modified herein, all of the rules that apply to normal interface declarations apply to annotation <del>type</del> declarations.</p>
<blockquote>
<p>For example, annotation <del>types</del> <strong>interfaces</strong> share the same namespace as normal <del>class and interface types</del> <strong>classes and interfaces</strong>; and annotation <del>type</del> declarations <del>are legal wherever interface declarations are legal, and</del> have the same scope and accessibility <strong>as interface declarations</strong>.</p>
</blockquote>
<h4 id="jls-9.6.1">9.6.1 Annotation <del>Type</del> Elements</h4>
<p>The body of an annotation <del>type</del> declaration may contain method declarations, each of which defines an <em>element</em> of the annotation <del>type</del> <strong>interface</strong>. An annotation <del>type</del> <strong>interface</strong> has no elements other than those defined by the methods it explicitly declares.</p>
<dl>
<dt><del><em>AnnotationTypeBody:</em></del> <strong><em>AnnotationInterfaceBody:</em></strong></dt>
<dd><code>{</code> {<del><em>AnnotationTypeMemberDeclaration</em></del> <strong><em>AnnotationMemberDeclaration</em></strong>} <code>}</code>
</dd>
<dt><del><em>AnnotationTypeMemberDeclaration:</em></del> <strong><em>AnnotationMemberDeclaration:</em></strong></dt>
<dd><del><em>AnnotationTypeElementDeclaration</em></del> <strong><em>AnnotationElementDeclaration</em></strong>
</dd>
<dd><em>ConstantDeclaration</em>
</dd>
<dd><del><em>ClassDeclaration</em></del>
</dd>
<dd><del><em>InterfaceDeclaration</em></del>
</dd>
<dd><strong><em>ClassOrInterfaceDeclaration</em></strong>
</dd>
<dd><code>;</code>
</dd>
<dt><del><em>AnnotationTypeElementDeclaration:</em></del> <strong><em>AnnotationElementDeclaration:</em></strong></dt>
<dd>{<del><em>AnnotationTypeElementModifier</em></del> <strong><em>AnnotationElementModifier</em></strong>} <em>UnannType</em> <em>Identifier</em> <code>(</code> <code>)</code> [<em>Dims</em>]<br />
[<em>DefaultValue</em>] <code>;</code>
</dd>
<dt><del><em>AnnotationTypeElementModifier:</em></del> <strong><em>AnnotationElementModifier:</em></strong></dt>
<dd>(one of)
</dd>
<dd><em>Annotation</em> <code>public</code>
</dd>
<dd><code>abstract</code>
</dd>
</dl>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeElementDeclaration</em></del> <strong><em>AnnotationElementDeclaration</em></strong> production, a method declaration in an annotation <del>type</del> declaration cannot have formal parameters, type parameters, or a <code>throws</code> clause. The following production from <a href="../../../se14/html/jls-4.html#jls-4.3">4.3</a> is shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>Dims:</em></dt>
<dd>{<em>Annotation</em>} <code>[</code> <code>]</code> {{<em>Annotation</em>} <code>[</code> <code>]</code>}
</dd>
</dl>
</blockquote>
<blockquote>
<p>By virtue of the <del><em>AnnotationTypeElementModifier</em></del> <strong><em>AnnotationElementModifier</em></strong> production, a method declaration in an annotation <del>type</del> declaration cannot be <code>default</code> or <code>static</code>. Thus, an annotation <del>type</del> <strong>interface</strong> cannot declare the same variety of methods as a normal interface <del>type</del>. Note that it is still possible for an annotation <del>type</del> <strong>interface</strong> to inherit a default method from its implicit superinterface, <code>java.lang.annotation.Annotation</code>, though no such default method exists as of Java SE 14.</p>
</blockquote>
<blockquote>
<p>By convention, the only <del><em>AnnotationTypeElementModifier</em>s</del> <strong><em>AnnotationElementModifier</em>s</strong> that should be present on an annotation <del>type</del> element <strong>declaration</strong> are annotations.</p>
</blockquote>
<p>The return type of a method declared in an annotation <del>type</del> <strong>interface</strong> must be one of the following, or a compile-time error occurs:</p>
<ul>
<li><p>A primitive type</p></li>
<li><p><code>String</code></p></li>
<li><p><code>Class</code> or an invocation of <code>Class</code> (<a href="../../../se14/html/jls-4.html#jls-4.5">4.5</a>)</p></li>
<li><p>An enum type</p></li>
<li><p>An annotation type</p></li>
<li><p>An array type whose component type is one of the preceding types (<a href="../../../se14/html/jls-10.html#jls-10.1">10.1</a>).</p></li>
</ul>
<blockquote>
<p>This rule precludes elements with nested array types, such as:</p>
<pre><code>@interface Verboten {
    String[][] value();
}</code></pre>
</blockquote>
<p>The declaration of a method that returns an array is allowed to place the bracket pair that denotes the array type after the empty formal parameter list. This syntax is supported for compatibility with early versions of the Java programming language. It is very strongly recommended that this syntax is not used in new code.</p>
<p>It is a compile-time error if any method declared in an annotation <del>type</del> <strong>interface</strong> has a signature that is override-equivalent to that of any <code>public</code> or <code>protected</code> method declared in class <code>Object</code> or in the interface <code>java.lang.annotation.Annotation</code>.</p>
<p>It is a compile-time error if <del>an annotation type declaration</del> <strong>a declaration of an annotation interface</strong> <em>T</em> contains an element of type <em>T</em>, either directly or indirectly.</p>
<blockquote>
<p>For example, this is illegal:</p>
<pre><code>@interface SelfRef { SelfRef value(); }</code></pre>
<p>and so is this:</p>
<pre><code>@interface Ping { Pong value(); }
@interface Pong { Ping value(); }</code></pre>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> with no elements is called a <em>marker annotation <del>type</del> <strong>interface</strong></em>.</p>
<p>An annotation <del>type</del> <strong>interface</strong> with one element is called a <em>single-element annotation <del>type</del> <strong>interface</strong></em>.</p>
<p>By convention, the name of the sole element in a single-element annotation <del>type</del> <strong>interface</strong> is <code>value</code>. Linguistic support for this convention is provided by single-element annotations (<a href="../../../se14/html/jls-9.html#jls-9.7.3">9.7.3</a>).</p>
<div class="example">
<p>Example 9.6.1-1. Annotation <del>Type</del> Declaration</p>
<p>The following annotation <del>type</del> declaration defines an annotation <del>type</del> <strong>interface</strong> with several elements:</p>
<pre><code>/**
 * Describes the &quot;request-for-enhancement&quot; (RFE)
 * that led to the presence of the annotated API element.
 */
@interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}</code></pre>
</div>
<div class="example">
<p>Example 9.6.1-2. Marker Annotation <del>Type</del> Declaration</p>
<p>The following annotation <del>type</del> declaration defines a marker annotation <del>type</del> <strong>interface</strong>:</p>
<pre><code>/**
 * An annotation with this type indicates that the 
 * specification of the annotated API element is 
 * preliminary and subject to change.
 */
@interface Preliminary {}</code></pre>
</div>
<div class="example">
<p>Example 9.6.1-3. Single-Element Annotation <del>Type</del> Declarations</p>
<p>The convention that a single-element annotation <del>type</del> <strong>interface</strong> defines an element called <code>value</code> is illustrated in the following annotation <del>type</del> declaration:</p>
<pre><code>/**
 * Associates a copyright notice with the annotated API element.
 */
@interface Copyright {
    String value();
}</code></pre>
<p>The following annotation <del>type</del> declaration defines a single-element annotation <del>type</del> <strong>interface</strong> whose sole element has an array type:</p>
<pre><code>/**
 * Associates a list of endorsers with the annotated class.
 */
@interface Endorsers {
    String[] value();
}</code></pre>
<p>The following annotation <del>type</del> declaration shows a <code>Class</code>-typed element whose value is constrained by a bounded wildcard:</p>
<pre><code>interface Formatter {}

// Designates a formatter to pretty-print the annotated class
@interface PrettyPrinter {
    Class&lt;? extends Formatter&gt; value();
}</code></pre>
<p>The following annotation <del>type</del> declaration contains an element whose type is also an annotation <strong>interface</strong> type:</p>
<pre><code>/**
 * Indicates the author of the annotated program element.
 */
@interface Author {
    Name value();
}
/**</code></pre>
<pre class="deleted"><code> * A person&#39;s name.  This annotation type is not designed
 * to be used directly to annotate program elements, but to
 * define elements of other annotation types.</code></pre>
<pre class="inserted"><code> * A person&#39;s name.  This annotation interface is not designed
 * to be used directly to annotate program elements, but to
 * define elements of other annotation interfaces.</code></pre>
<pre><code>*/
@interface Name {
   String first();
   String last();
}</code></pre>
<p>The grammar for annotation <del>type</del> declarations permits other <del>element</del> <strong>member</strong> declarations besides <del>method</del> <strong>element</strong> declarations. For example, one might choose to declare a nested enum for use in conjunction with an annotation <del>type</del> <strong>interface</strong>:</p>
<pre><code>@interface Quality {
    enum Level { BAD, INDIFFERENT, GOOD }
    Level value();
}</code></pre>
</div>
<h4 id="jls-9.6.2">9.6.2 Defaults for Annotation <del>Type</del> Elements</h4>
<p>An annotation <del>type</del> element <strong>declaration</strong> may have a <em>default value</em>, specified by following the element's (empty) parameter list with the keyword <code>default</code> and an <em>ElementValue</em> (<a href="../../../se14/html/jls-9.html#jls-9.7.1">9.7.1</a>).</p>
<dl>
<dt><em>DefaultValue:</em></dt>
<dd><code>default</code> <em>ElementValue</em>
</dd>
</dl>
<p>It is a compile-time error if the type of the element is not commensurate (<a href="../../../se14/html/jls-9.html#jls-9.7">9.7</a>) with the default value specified.</p>
<p>Default values are not compiled into annotations, but rather applied dynamically at the time annotations are read. Thus, changing a default value affects annotations even in classes that were compiled before the change was made (presuming these annotations lack an explicit value for the defaulted element).</p>
<div class="example">
<p>Example 9.6.2-1. Annotation <del>Type</del> Declaration With Default Values</p>
<p>Here is a refinement of the <code>RequestForEnhancement</code> annotation <del>type</del> <strong>interface</strong> from <a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a>:</p>
<pre><code>@interface RequestForEnhancementDefault {
    int    id();       // No default - must be specified in 
                       // each annotation
    String synopsis(); // No default - must be specified in 
                       // each annotation
    String engineer()  default &quot;[unassigned]&quot;;
    String date()      default &quot;[unimplemented]&quot;;
}</code></pre>
</div>
<h4 id="jls-9.6.3">9.6.3 Repeatable Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>An annotation <del>type</del> <strong>interface</strong> <em>T</em> is <em>repeatable</em> if its declaration is (meta-)annotated with an <code>@Repeatable</code> annotation (<a href="class-terminology-jls.html#jls-9.6.4.8">9.6.4.8</a>) whose <code>value</code> element indicates a <em>containing annotation <del>type</del> <strong>interface</strong> of T</em>.</p>
<p>An annotation <del>type</del> <strong>interface</strong> <em>TC</em> is a <em>containing annotation <del>type</del> <strong>interface</strong> of T</em> if all of the following are true:</p>
<ol type="1">
<li><p><em>TC</em> declares a <code>value()</code> <del>method</del> <strong>element</strong> whose return type is <em>T</em><code>[]</code>.</p></li>
<li><p>Any <del>methods</del> <strong>elements</strong> declared by <em>TC</em> other than <code>value()</code> have a default value.</p></li>
<li><p><em>TC</em> is retained for at least as long as <em>T</em>, where retention is expressed explicitly or implicitly with the <code>@Retention</code> annotation (<a href="class-terminology-jls.html#jls-9.6.4.2">9.6.4.2</a>). Specifically:</p>
<ul>
<li><p>If the retention of <em>TC</em> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, then the retention of <em>T</em> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>.</p></li>
<li><p>If the retention of <em>TC</em> is <code>java.lang.annotation.RetentionPolicy.CLASS</code>, then the retention of <em>T</em> is either <code>java.lang.annotation.RetentionPolicy.CLASS</code> or <code>java.lang.annotation.RetentionPolicy.SOURCE</code>.</p></li>
<li><p>If the retention of <em>TC</em> is <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, then the retention of <em>T</em> is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, <code>java.lang.annotation.RetentionPolicy.CLASS</code>, or <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>.</p></li>
</ul></li>
<li><p><em>T</em> is applicable to at least the same kinds of program element as <em>TC</em> (<a href="class-terminology-jls.html#jls-9.6.4.1">9.6.4.1</a>). Specifically, if the kinds of program element where <em>T</em> is applicable are denoted by the set <em>m<sub>1</sub></em>, and the kinds of program element where <em>TC</em> is applicable are denoted by the set <em>m<sub>2</sub></em>, then each kind in <em>m<sub>2</sub></em> must occur in <em>m<sub>1</sub></em>, except that:</p>
<ul>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code>, then at least one of <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code> or <code>java.lang.annotation.ElementType.TYPE</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.TYPE</code>, then at least one of <code>java.lang.annotation.ElementType.TYPE</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
<li><p>If the kind in <em>m<sub>2</sub></em> is <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code>, then at least one of <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code> or <code>java.lang.annotation.ElementType.TYPE_USE</code> must occur in <em>m<sub>1</sub></em>.</p></li>
</ul>
<blockquote>
<p>This clause implements the policy that an annotation <del>type</del> <strong>interface</strong> may be <em>repeatable</em> on only some of the kinds of program element where it is <em>applicable</em>.</p>
</blockquote></li>
<li><p>If the declaration of <em>T</em> has a (meta-)annotation that corresponds to <code>java.lang.annotation.Documented</code>, then the declaration of <em>TC</em> must have a (meta-)annotation that corresponds to <code>java.lang.annotation.Documented</code>.</p>
<blockquote>
<p>Note that it is permissible for <em>TC</em> to be <code>@Documented</code> while <em>T</em> is not <code>@Documented</code>.</p>
</blockquote></li>
<li><p>If the declaration of <em>T</em> has a (meta-)annotation that corresponds to <code>java.lang.annotation.Inherited</code>, then the declaration of <em>TC</em> must have a (meta)-annotation that corresponds to <code>java.lang.annotation.Inherited</code>.</p>
<blockquote>
<p>Note that it is permissible for <em>TC</em> to be <code>@Inherited</code> while <em>T</em> is not <code>@Inherited</code>.</p>
</blockquote></li>
</ol>
<p>It is a compile-time error if an annotation <del>type</del> <strong>interface</strong> <em>T</em> is (meta-)annotated with an <code>@Repeatable</code> annotation whose <code>value</code> element indicates a type which is not a containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>.</p>
<div class="example">
<p>Example 9.6.3-1. Ill-formed Containing Annotation <del>Type</del> <strong>Interface</strong></p>
<p>Consider the following declarations:</p>
<pre><code>import java.lang.annotation.Repeatable;

@Repeatable(FooContainer.class)
@interface Foo {}

@interface FooContainer { Object[] value(); }</code></pre>
<p>Compiling the <code>Foo</code> declaration produces a compile-time error because <code>Foo</code> uses <code>@Repeatable</code> to attempt to specify <code>FooContainer</code> as its containing annotation <del>type</del> <strong>interface</strong>, but <code>FooContainer</code> is not in fact a containing annotation <del>type</del> <strong>interface</strong> of <code>Foo</code>. (The return type of <code>FooContainer.value()</code> is not <code>Foo[]</code>.)</p>
</div>
<p>The <code>@Repeatable</code> annotation cannot be repeated, so only one containing annotation <del>type</del> <strong>interface</strong> can be specified by a repeatable annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>Allowing more than one containing annotation <del>type</del> <strong>interface</strong> to be specified would cause an undesirable choice at compile time, when multiple annotations of the repeatable annotation <del>type</del> <strong>interface</strong> are logically replaced with a container annotation (<a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>).</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> can be the containing annotation <del>type</del> <strong>interface</strong> of at most one annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>This is implied by the requirement that if the declaration of an annotation <del>type</del> <strong>interface</strong> <em>T</em> specifies a containing annotation <del>type</del> <strong>interface</strong> of <em>TC</em>, then the <code>value()</code> method of <em>TC</em> has a return type involving <em>T</em>, specifically <em>T</em><code>[]</code>.</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> cannot specify itself as its containing annotation <del>type</del> <strong>interface</strong>.</p>
<blockquote>
<p>This is implied by the requirement on the <code>value()</code> method of the containing annotation <del>type</del> <strong>interface</strong>. Specifically, if an annotation <del>type</del> <strong>interface</strong> <em>A</em> specified itself (via <code>@Repeatable</code>) as its containing annotation <del>type</del> <strong>interface</strong>, then the return type of <em>A</em>'s <code>value()</code> method would have to be <em>A</em><code>[]</code>; but this would cause a compile-time error since an annotation <del>type</del> <strong>interface</strong> cannot refer to itself in its elements (<a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a>). More generally, two annotation <del>types</del> <strong>interfaces</strong> cannot specify each other to be their containing annotation <del>types</del> <strong>interfaces</strong>, because cyclic annotation <del>type</del> <strong>interface</strong> declarations are illegal.</p>
</blockquote>
<p>An annotation <del>type</del> <strong>interface</strong> <em>TC</em> may be the containing annotation <del>type</del> <strong>interface</strong> of some annotation <del>type</del> <strong>interface</strong> <em>T</em> while also having its own containing annotation <del>type</del> <strong>interface</strong> <em>TC</em> '. That is, a containing annotation <del>type</del> <strong>interface</strong> may itself be a repeatable annotation <del>type</del> <strong>interface</strong>.</p>
<div class="example">
<p>Example 9.6.3-2. Restricting Where Annotations May Repeat</p>
<p>An annotation whose <del>type</del> declaration indicates a target of <code>java.lang.annotation.ElementType.TYPE</code> can appear in at least as many locations as an annotation whose <del>type</del> declaration indicates a target of <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code>. For example, given the following declarations of repeatable and containing annotation <del>types</del> <strong>interfaces</strong>:</p>
<pre><code>import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;

@Target(ElementType.TYPE)
@Repeatable(FooContainer.class)
@interface Foo {}

@Target(ElementType.ANNOTATION_TYPE)
@interface FooContainer {
    Foo[] value();
}</code></pre>
<p><code>@Foo</code> can appear on any <del>type</del> <strong>class or interface</strong> declaration while <code>@FooContainer</code> can appear on only annotation <del>type</del> <strong>interface</strong> declarations. Therefore, the following annotation <del>type</del> <strong>interface</strong> declaration is legal:</p>
<pre><code>@Foo @Foo
@interface Anno {}</code></pre>
<p>while the following interface declaration is illegal:</p>
<pre><code>@Foo @Foo
interface Intf {}</code></pre>
<p>More broadly, if <code>Foo</code> is a repeatable annotation <del>type</del> <strong>interface</strong> and <code>FooContainer</code> is its containing annotation <del>type</del> <strong>interface</strong>, then:</p>
<ul>
<li><p>If <code>Foo</code> has no <code>@Target</code> meta-annotation and <code>FooContainer</code> has no <code>@Target</code> meta-annotation, then <code>@Foo</code> may be repeated on any program element which supports annotations.</p></li>
<li><p>If <code>Foo</code> has no <code>@Target</code> meta-annotation but <code>FooContainer</code> has an <code>@Target</code> meta-annotation, then <code>@Foo</code> may only be repeated on program elements where <code>@FooContainer</code> may appear.</p></li>
<li><p>If <code>Foo</code> has an <code>@Target</code> meta-annotation, then in the judgment of the designers of the Java programming language, <code>FooContainer</code> must be declared with knowledge of the <code>Foo</code>'s applicability. Specifically, the kinds of program element where <code>FooContainer</code> may appear must logically be the same as, or a subset of, <code>Foo</code>'s kinds.</p>
<p>For example, if <code>Foo</code> is applicable to field and method declarations, then <code>FooContainer</code> may legitimately serve as <code>Foo</code>'s containing annotation <del>type</del> <strong>interface</strong> if <code>FooContainer</code> is applicable to just field declarations (preventing <code>@Foo</code> from being repeated on method declarations). But if <code>FooContainer</code> is applicable only to formal parameter declarations, then <code>FooContainer</code> was a poor choice of containing annotation <del>type</del> <strong>interface</strong> by <code>Foo</code> because <code>@FooContainer</code> cannot be implicitly declared on some program elements where <code>@Foo</code> is repeated.</p>
<p>Similarly, if <code>Foo</code> is applicable to field and method declarations, then <code>FooContainer</code> cannot legitimately serve as <code>Foo</code>'s containing annotation <del>type</del> <strong>interface</strong> if <code>FooContainer</code> is applicable to field and parameter declarations. While it would be possible to take the intersection of the program elements and make <code>Foo</code> repeatable on field declarations only, the presence of additional program elements for <code>FooContainer</code> indicates that <code>FooContainer</code> was not designed as a containing annotation <del>type</del> <strong>interface</strong> for <code>Foo</code>. It would therefore be dangerous for <code>Foo</code> to rely on it.</p></li>
</ul>
</div>
<div class="example">
<p>Example 9.6.3-3. A Repeatable Containing Annotation <del>Type</del> <strong>Interface</strong></p>
<p>The following declarations are legal:</p>
<pre><code>import java.lang.annotation.Repeatable;
</code></pre>
<pre class="deleted"><code>// Foo: Repeatable annotation type</code></pre>
<pre class="inserted"><code>// Foo: Repeatable annotation interface</code></pre>
<pre><code>@Repeatable(FooContainer.class)
@interface Foo { int value(); }</code></pre>
<pre class="deleted"><code>// FooContainer: Containing annotation type of Foo
//               Also a repeatable annotation type itself</code></pre>
<pre class="inserted"><code>// FooContainer: Containing annotation interface of Foo
//               Also a repeatable annotation interface itself</code></pre>
<pre><code>@Repeatable(FooContainerContainer.class)
@interface FooContainer { Foo[] value(); }</code></pre>
<pre class="deleted"><code>// FooContainerContainer: Containing annotation type of FooContainer</code></pre>
<pre class="inserted"><code>// FooContainerContainer: Containing annotation interface of FooContainer</code></pre>
<pre><code>@interface FooContainerContainer { FooContainer[] value(); }</code></pre>
<p>Thus, an annotation whose type is a containing annotation <del>type</del> <strong>interface</strong> may itself be repeated:</p>
<pre><code>@FooContainer({@Foo(1)}) @FooContainer({@Foo(2)})
class Test {}</code></pre>
<p>An annotation <del>type</del> <strong>interface</strong> which is both repeatable and containing is subject to the rules on mixing annotations of repeatable annotation type with annotations of containing annotation type (<a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>). For example, it is not possible to write multiple <code>@Foo</code> annotations alongside multiple <code>@FooContainer</code> annotations, nor is it possible to write multiple <code>@FooContainer</code> annotations alongside multiple <code>@FooContainerContainer</code> annotations. However, if the <code>FooContainerContainer</code> <del>type</del> <strong>annotation interface</strong> was itself repeatable, then it would be possible to write multiple <code>@Foo</code> annotations alongside multiple <code>@FooContainerContainer</code> annotations.</p>
</div>
<h4 id="jls-9.6.4">9.6.4 Predefined Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>Several annotation <del>types</del> <strong>interfaces</strong> are predefined in the libraries of the Java SE Platform. Some of these predefined annotation <del>types</del> <strong>interfaces</strong> have special semantics. These semantics are specified in this section. This section does not provide a complete specification for the predefined annotations contained here in; that is the role of the appropriate API specifications. Only those semantics that require special behavior on the part of a Java compiler or Java Virtual Machine implementation are specified here.</p>
<h5 id="jls-9.6.4.1">9.6.4.1 <code>@Target</code></h5>
<p>An annotation of type <code>java.lang.annotation.Target</code> is used on the declaration of an annotation <del>type</del> <strong>interface</strong> <em>T</em> to specify the contexts in which <em>T</em> is <em>applicable</em>. <code>java.lang.annotation.Target</code> has a single element, <code>value</code>, of type <code>java.lang.annotation.ElementType[]</code>, to specify contexts.</p>
<p>Annotation <del>types</del> <strong>interfaces</strong> may be applicable in <em>declaration contexts</em>, where annotations apply to declarations, or in <em>type contexts</em>, where annotations apply to types used in declarations and expressions.</p>
<p>There are nine declaration contexts, each corresponding to an enum constant of <code>java.lang.annotation.ElementType</code>:</p>
<ol type="1">
<li><p>Module declarations (<a href="../../../se14/html/jls-7.html#jls-7.7">7.7</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.MODULE</code></p></li>
<li><p>Package declarations (<a href="../../../se14/html/jls-7.html#jls-7.4.1">7.4.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PACKAGE</code></p></li>
<li><p>Type declarations: class, interface, enum, and annotation <del>type</del> declarations (<a href="class-terminology-jls.html#jls-8.1.1">8.1.1</a>, <a href="../../../se14/html/jls-9.html#jls-9.1.1">9.1.1</a>, <a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>, <a href="class-terminology-jls.html#jls-8.9">8.9</a>, <a href="class-terminology-jls.html#jls-9.6">9.6</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE</code></p>
<p>Additionally, annotation <del>type</del> declarations correspond to <code>java.lang.annotation.ElementType.ANNOTATION_TYPE</code></p></li>
<li><p>Method declarations (including elements of annotation <del>types</del> <strong>interfaces</strong>) (<a href="../../../se14/html/jls-8.html#jls-8.4.3">8.4.3</a>, <a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="class-terminology-jls.html#jls-9.6.1">9.6.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.METHOD</code></p></li>
<li><p>Constructor declarations (<a href="../../../se14/html/jls-8.html#jls-8.8.3">8.8.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.CONSTRUCTOR</code></p></li>
<li><p>Type parameter declarations of generic classes, interfaces, methods, and constructors (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="../../../se14/html/jls-9.html#jls-9.1.2">9.1.2</a>, <a href="../../../se14/html/jls-8.html#jls-8.4.4">8.4.4</a>, <a href="../../../se14/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.TYPE_PARAMETER</code></p></li>
<li><p>Field declarations (including enum constants) (<a href="../../../se14/html/jls-8.html#jls-8.3.1">8.3.1</a>, <a href="../../../se14/html/jls-9.html#jls-9.3">9.3</a>, <a href="class-terminology-jls.html#jls-8.9.1">8.9.1</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.FIELD</code></p></li>
<li><p>Formal and exception parameter declarations (<a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="../../../se14/html/jls-9.html#jls-9.4">9.4</a>, <a href="../../../se14/html/jls-14.html#jls-14.20">14.20</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.PARAMETER</code></p></li>
<li><p>Local variable declarations (including loop variables of <code>for</code> statements and resource variables of <code>try</code>-with-resources statements) (<a href="../../../se14/html/jls-14.html#jls-14.4">14.4</a>, <a href="../../../se14/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="../../../se14/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="../../../se14/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p>
<p>Corresponds to <code>java.lang.annotation.ElementType.LOCAL_VARIABLE</code></p></li>
</ol>
<p>There are 16 type contexts (<a href="../../../se14/html/jls-4.html#jls-4.11">4.11</a>), all represented by the enum constant <code>TYPE_USE</code> of <code>java.lang.annotation.ElementType</code>.</p>
<p>It is a compile-time error if the same enum constant appears more than once in the <code>value</code> element of an annotation of type <code>java.lang.annotation.Target</code>.</p>
<p>If an annotation of type <code>java.lang.annotation.Target</code> is not present on the declaration of an annotation <del>type</del> <strong>interface</strong> <em>T</em>, then <em>T</em> is applicable in all nine declaration contexts and in all 16 type contexts.</p>
<h5 id="jls-9.6.4.2">9.6.4.2 <code>@Retention</code></h5>
<p>Annotations may be present only in source code, or they may be present in the binary form of a class or interface. An annotation that is present in the binary form may or may not be available at run time via the reflection libraries of the Java SE Platform. The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Retention</code> is used to choose among these possibilities.</p>
<p>If an annotation <em>a</em> corresponds to <del>a type</del> <strong>an annotation interface</strong> <em>T</em>, and <em>T</em> has a (meta-)annotation <em>m</em> that corresponds to <code>java.lang.annotation.Retention</code>, then:</p>
<ul>
<li><p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.SOURCE</code>, then a Java compiler must ensure that <em>a</em> is not present in the binary representation of the class or interface in which <em>a</em> appears.</p></li>
<li><p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.CLASS</code> or <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, then a Java compiler must ensure that <em>a</em> is represented in the binary representation of the class or interface in which <em>a</em> appears, unless <em>a</em> annotates a local variable declaration or <em>a</em> annotates a formal parameter declaration of a lambda expression.</p>
<p>An annotation on the declaration of a local variable, or on the declaration of a formal parameter of a lambda expression, is never retained in the binary representation. In contrast, an annotation on the type of a local variable, or on the type of a formal parameter of a lambda expression, is retained in the binary representation if the annotation <del>type</del> <strong>interface</strong> specifies a suitable retention policy.</p>
<blockquote>
<p>Note that it is not illegal for an annotation <del>type</del> <strong>interface</strong> to be meta-annotated with <code>@Target(java.lang.annotation.ElementType.LOCAL_VARIABLE)</code> <em>and</em> <code>@Retention(java.lang.annotation.RetentionPolicy.CLASS)</code> or <code>@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</code>.</p>
</blockquote>
<p>If <em>m</em> has an element whose value is <code>java.lang.annotation.RetentionPolicy.RUNTIME</code>, the reflection libraries of the Java SE Platform must make <em>a</em> available at run time.</p></li>
</ul>
<p>If <em>T</em> does not have a (meta-)annotation <em>m</em> that corresponds to <code>java.lang.annotation.Retention</code>, then a Java compiler must treat <em>T</em> as if it does have such a meta-annotation <em>m</em> with an element whose value is <code>java.lang.annotation.RetentionPolicy.CLASS</code>.</p>
<h5 id="jls-9.6.4.3">9.6.4.3 <code>@Inherited</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Inherited</code> is used to indicate that annotations on a class <em>C</em> corresponding to a given annotation <del>type</del> <strong>interface</strong> are inherited by subclasses of <em>C</em>.</p>
<h5 id="jls-9.6.4.4">9.6.4.4 <code>@Override</code></h5>
<p>Programmers occasionally overload a method declaration when they mean to override it, leading to subtle problems. The annotation <del>type</del> <strong>interface</strong> <code>Override</code> supports early detection of such problems.</p>
<blockquote>
<p>The classic example concerns the <code>equals</code> method. Programmers write the following in class <code>Foo</code>:</p>
<pre><code>public boolean equals(Foo that) { ... }</code></pre>
<p>when they mean to write:</p>
<pre><code>public boolean equals(Object that) { ... }</code></pre>
<p>This is perfectly legal, but class <code>Foo</code> inherits the <code>equals</code> implementation from <code>Object</code>, which can cause some subtle bugs.</p>
</blockquote>
<p>If a method declaration in <del>type</del> <strong>class or interface</strong> <em>T</em> is annotated with <code>@Override</code>, but the method does not override from <em>T</em> a method declared in a supertype of <em>T</em> (<a href="../../../se14/html/jls-8.html#jls-8.4.8.1">8.4.8.1</a>, <a href="../../../se14/html/jls-9.html#jls-9.4.1.1">9.4.1.1</a>), or is not override-equivalent to a <code>public</code> method of <code>Object</code> (<a href="../../../se14/html/jls-4.html#jls-4.3.2">4.3.2</a>, <a href="../../../se14/html/jls-8.html#jls-8.4.2">8.4.2</a>), then a compile-time error occurs.</p>
<blockquote>
<p>This behavior differs from Java SE 5.0, where <code>@Override</code> only caused a compile-time error if applied to a method that implemented a method from a superinterface that was not also present in a superclass.</p>
</blockquote>
<blockquote>
<p>The clause about overriding a <code>public</code> method is motivated by use of <code>@Override</code> in an interface. Consider the following <del>type</del> declarations:</p>
<pre><code>class Foo     { @Override public int hashCode() {..} }
interface Bar { @Override int hashCode(); }</code></pre>
<p>The use of <code>@Override</code> in the class declaration is legal by the first clause, because <code>Foo.hashCode</code> overrides from <code>Foo</code> the method <code>Object.hashCode</code>.</p>
<p>For the interface declaration, consider that while an interface does not have <code>Object</code> as a supertype, an interface does have <code>public</code> <code>abstract</code> members that correspond to the <code>public</code> members of <code>Object</code> (<a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a>). If an interface chooses to declare them explicitly (that is, to declare members that are override-equivalent to <code>public</code> methods of <code>Object</code>), then the interface is deemed to override them, and use of <code>@Override</code> is allowed.</p>
<p>However, consider an interface that attempts to use <code>@Override</code> on a <code>clone</code> method: (<code>finalize</code> could also be used in this example)</p>
<pre><code>interface Quux { @Override Object clone(); }</code></pre>
<p>Because <code>Object.clone</code> is not <code>public</code>, there is no member called <code>clone</code> implicitly declared in <code>Quux</code>. Therefore, the explicit declaration of <code>clone</code> in <code>Quux</code> is not deemed to &quot;implement&quot; any other method, and it is erroneous to use <code>@Override</code>. (The fact that <code>Quux.clone</code> is <code>public</code> is not relevant.)</p>
<p>In contrast, a class declaration that declares <code>clone</code> is simply overriding <code>Object.clone</code>, so is able to use <code>@Override</code>:</p>
<pre><code>class Beep { @Override protected Object clone() {..} }</code></pre>
</blockquote>
<h5 id="jls-9.6.4.5">9.6.4.5 <code>@SuppressWarnings</code></h5>
<p>Java compilers are increasingly capable of issuing helpful &quot;lint-like&quot; warnings. To encourage the use of such warnings, there should be some way to disable a warning in a part of the program when the programmer knows that the warning is inappropriate.</p>
<p>The annotation <del>type</del> <strong>interface</strong> <code>SuppressWarnings</code> supports programmer control over warnings otherwise issued by a Java compiler. It defines a single element that is an array of <code>String</code>.</p>
<p>If a declaration is annotated with <code>@SuppressWarnings(value = {S1, ..., Sk})</code>, then a Java compiler must suppress (that is, not report) any warning specified by one of <em>S<sub>1</sub></em> ... <em>S<sub>k</sub></em> if that warning would have been generated as a result of the annotated declaration or any of its parts.</p>
<p>The Java programming language defines four kinds of warnings that can be specified by <code>@SuppressWarnings</code>:</p>
<ul>
<li><p>Unchecked warnings (<a href="../../../se14/html/jls-4.html#jls-4.8">4.8</a>, <a href="../../../se14/html/jls-5.html#jls-5.1.6">5.1.6</a>, <a href="../../../se14/html/jls-5.html#jls-5.1.9">5.1.9</a>, <a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="../../../se14/html/jls-8.html#jls-8.4.8.3">8.4.8.3</a>, <a href="../../../se14/html/jls-15.html#jls-15.12.4.2">15.12.4.2</a>, <a href="../../../se14/html/jls-15.html#jls-15.13.2">15.13.2</a>, <a href="../../../se14/html/jls-15.html#jls-15.27.3">15.27.3</a>) are specified by the string &quot;<code>unchecked</code>&quot;.</p></li>
<li><p>Deprecation warnings (<a href="class-terminology-jls.html#jls-9.6.4.6">9.6.4.6</a>) are specified by the string &quot;<code>deprecation</code>&quot;.</p></li>
<li><p>Removal warnings (<a href="class-terminology-jls.html#jls-9.6.4.6">9.6.4.6</a>) are specified by the string &quot;<code>removal</code>&quot;.</p></li>
<li><p>Preview warnings (<a href="../../../se14/html/jls-1.html#jls-1.5">1.5</a>) are specified by the string &quot;<code>preview</code>&quot;.</p></li>
</ul>
<p>Any other string specifies a non-standard warning. A Java compiler must ignore any such string that it does not recognize.</p>
<blockquote>
<p>Compiler vendors are encouraged to document the strings they support for <code>@SuppressWarnings</code>, and to cooperate to ensure that the same strings are recognized across multiple compilers.</p>
</blockquote>
<h5 id="jls-9.6.4.6">9.6.4.6 <code>@Deprecated</code></h5>
<p>Programmers are sometimes discouraged from using certain program elements (modules, <del>types</del> <strong>classes, interfaces</strong>, fields, methods, and constructors) because they are dangerous or because a better alternative exists. The annotation <del>type</del> <strong>interface</strong> <code>Deprecated</code> allows a compiler to warn about uses of these program elements.</p>
<p>A <em>deprecated</em> program element is a module, <del>type</del> <strong>class, interface</strong>, field, method, or constructor whose declaration is annotated with <code>@Deprecated</code>. The manner in which a program element is deprecated depends on the value of the <code>forRemoval</code> element of the annotation:</p>
<ul>
<li><p>If <code>forRemoval=false</code> (the default), then the program element is <em>ordinarily deprecated</em>.</p>
<p>An ordinarily deprecated program element is not intended to be removed in a future release, but programmers should nevertheless migrate away from using it.</p></li>
<li><p>If <code>forRemoval=true</code>, then the program element is <em>terminally deprecated</em>.</p>
<p>A terminally deprecated program element is intended to be removed in a future release. Programmers should stop using it or risk source and binary incompatibilities (<a href="../../../se14/html/jls-13.html#jls-13.2">13.2</a>) when upgrading to a newer release.</p></li>
</ul>
<p>A Java compiler must produce a <em>deprecation warning</em> when an ordinarily deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless:</p>
<ul>
<li><p>The use is within a declaration that is itself deprecated, either ordinarily or terminally; or</p></li>
<li><p>The use is within a declaration that is annotated to suppress deprecation warnings (<a href="class-terminology-jls.html#jls-9.6.4.5">9.6.4.5</a>); or</p></li>
<li><p>The declaration where the use appears and the declaration of the ordinarily deprecated program element are both within the same outermost class; or</p></li>
<li><p>The use is within an <code>import</code> declaration that imports the ordinarily deprecated type or member; or</p></li>
<li><p>The use is within an <code>exports</code> or <code>opens</code> directive (<a href="../../../se14/html/jls-7.html#jls-7.7.2">7.7.2</a>).</p></li>
</ul>
<p>A Java compiler must produce a <em>removal warning</em> when a terminally deprecated program element is used (overridden, invoked, or referenced by name) in the declaration of a program element (whether explicitly or implicitly declared), unless:</p>
<ul>
<li><p>The use is within a declaration that is annotated to suppress removal warnings (<a href="class-terminology-jls.html#jls-9.6.4.5">9.6.4.5</a>); or</p></li>
<li><p>The declaration where the use appears and the declaration of the terminally deprecated program element are both within the same outermost class; or</p></li>
<li><p>The use is within an <code>import</code> declaration that imports the terminally deprecated <del>type</del> <strong>class, interface,</strong> or member; or</p></li>
<li><p>The use is within an <code>exports</code> or <code>opens</code> directive.</p></li>
</ul>
<blockquote>
<p>Terminal deprecation is sufficiently urgent that the use of a terminally deprecated element will cause a removal warning <em>even if the using element is itself deprecated</em>, since there is no guarantee that both elements will be removed at the same time. To dismiss the warning but continue using the element, the programmer must manually acknowledge the risk via an <code>@SuppressWarnings</code> annotation.</p>
</blockquote>
<p>No deprecation warning or removal warning is produced when:</p>
<ul>
<li><p>a local variable or formal parameter is used (referenced by name), even if the declaration of the local variable or formal parameter is annotated with <code>@Deprecated</code>.</p></li>
<li><p>the name of a package is used (referenced by a qualified type name, or an <code>import</code> declaration, or an <code>exports</code> or <code>opens</code> directive), even if the declaration of the package is annotated with <code>@Deprecated</code>.</p></li>
<li><p>the name of a module is used by a qualified <code>exports</code> or <code>opens</code> directive, even if the declaration of the friend module is annotated with <code>@Deprecated</code>.</p></li>
</ul>
<blockquote>
<p>A module declaration that exports or opens a package is usually controlled by the same programmer or team that controls the package's declaration. As such, there is little benefit in warning that the package declaration is annotated with <code>@Deprecated</code> when the package is exported or opened by the module declaration. In contrast, a module declaration that exports or opens a package <em>to a friend module</em> is usually not controlled by the same programmer or team that controls the friend module. Simply exporting or opening the package does not make the module declaration rely on the friend module, so there is little value in warning if the friend module is deprecated; the programmer of the module declaration would almost always wish to suppress such a warning.</p>
</blockquote>
<blockquote>
<p>The only implicit declaration that can cause a deprecation warning or removal warning is a container annotation (<a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>). Namely, if <em>T</em> is a repeatable annotation <del>type</del> <strong>interface</strong> and <em>TC</em> is its containing annotation <del>type</del> <strong>interface</strong>, and <em>TC</em> is deprecated, then repeating the <code>@T</code> annotation will cause a warning. The warning is due to the implicit <code>@TC</code> container annotation. It is strongly discouraged to deprecate a containing annotation <del>type</del> <strong>interface</strong> without deprecating the corresponding repeatable annotation <del>type</del> <strong>interface</strong>.</p>
</blockquote>
<h5 id="jls-9.6.4.7">9.6.4.7 <code>@SafeVarargs</code></h5>
<p>A variable arity parameter with a non-reifiable element type (<a href="../../../se14/html/jls-4.html#jls-4.7">4.7</a>) can cause heap pollution (<a href="../../../se14/html/jls-4.html#jls-4.12.2">4.12.2</a>) and give rise to compile-time unchecked warnings (<a href="../../../se14/html/jls-5.html#jls-5.1.9">5.1.9</a>). Such warnings are uninformative if the body of the variable arity method is well-behaved with respect to the variable arity parameter.</p>
<p>The annotation <del>type</del> <strong>interface</strong> <code>SafeVarargs</code>, when used to annotate a method or constructor declaration, makes a programmer assertion that prevents a Java compiler from reporting unchecked warnings for the declaration or invocation of a variable arity method or constructor where the compiler would otherwise do so due to the variable arity parameter having a non-reifiable element type.</p>
<blockquote>
<p>The annotation <code>@SafeVarargs</code> has non-local effects because it suppresses unchecked warnings at method invocation expressions, in addition to an unchecked warning pertaining to the declaration of the variable arity method itself (<a href="../../../se14/html/jls-8.html#jls-8.4.1">8.4.1</a>). In contrast, the annotation <code>@SuppressWarnings(&quot;unchecked&quot;)</code> has local effects because it only suppresses unchecked warnings pertaining to the declaration of a method.</p>
</blockquote>
<blockquote>
<p>The canonical target for <code>@SafeVarargs</code> is a method like <code>java.util.Collections.addAll</code>, whose declaration starts with:</p>
<pre><code>public static &lt;T&gt; boolean
  addAll(Collection&lt;? super T&gt; c, T... elements)</code></pre>
<p>The variable arity parameter has declared type <code>T[]</code>, which is non-reifiable. However, the method fundamentally just reads from the input array and adds the elements to a collection, both of which are safe operations with respect to the array. Therefore, any compile-time unchecked warnings at method invocation expressions for <code>java.util.Collections.addAll</code> are arguably spurious and uninformative. Applying <code>@SafeVarargs</code> to the method declaration prevents generation of these unchecked warnings at the method invocation expressions.</p>
</blockquote>
<p>It is a compile-time error if a fixed arity method or constructor declaration is annotated with the annotation <code>@SafeVarargs</code>.</p>
<p>It is a compile-time error if a variable arity method declaration that is neither <code>static</code> nor <code>final</code> nor <code>private</code> is annotated with the annotation <code>@SafeVarargs</code>.</p>
<blockquote>
<p>Since <code>@SafeVarargs</code> is only applicable to <code>static</code> methods, <code>final</code> and/or <code>private</code> instance methods, and constructors, the annotation is not usable where method overriding occurs. Annotation inheritance only works for annotations on classes (not on methods, interfaces, or constructors), so an <code>@SafeVarargs</code>-style annotation cannot be passed through instance methods in classes or through interfaces.</p>
</blockquote>
<h5 id="jls-9.6.4.8">9.6.4.8 <code>@Repeatable</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>java.lang.annotation.Repeatable</code> is used on the declaration of a <em>repeatable annotation <del>type</del> <strong>interface</strong></em> to indicate its containing annotation <del>type</del> <strong>interface</strong> (<a href="class-terminology-jls.html#jls-9.6.3">9.6.3</a>).</p>
<blockquote>
<p>Note that an <code>@Repeatable</code> meta-annotation on the declaration of <em>T</em>, indicating <em>TC</em>, is <em>not</em> sufficient to make <em>TC</em> the containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>. There are numerous well-formedness rules for <em>TC</em> to be considered the containing annotation <del>type</del> <strong>interface</strong> of <em>T</em>.</p>
</blockquote>
<h5 id="jls-9.6.4.9">9.6.4.9 <code>@FunctionalInterface</code></h5>
<p>The annotation <del>type</del> <strong>interface</strong> <code>FunctionalInterface</code> is used to indicate that an interface is meant to be a functional interface (<a href="../../../se14/html/jls-9.html#jls-9.8">9.8</a>). It facilitates early detection of inappropriate method declarations appearing in or inherited by an interface that is meant to be functional.</p>
<p>It is a compile-time error if an interface declaration is annotated with <code>@FunctionalInterface</code> but is not, in fact, a functional interface.</p>
<p>Because some interfaces are functional incidentally, it is not necessary or desirable that all declarations of functional interfaces be annotated with <code>@FunctionalInterface</code>.</p>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p>Programs must be compiled either into the <code>class</code> file format specified by <em>The Java Virtual Machine Specification, Java SE 14 Edition</em>, or into a representation that can be mapped into that format by a class loader written in the Java programming language.</p>
<p>A <code>class</code> file corresponding to a class or interface declaration must have certain properties. A number of these properties are specifically chosen to support source code transformations that preserve binary compatibility. The required properties are:</p>
<ol type="1">
<li><p>The class or interface must be named by its <em>binary name</em>, which must meet the following constraints:</p>
<ul>
<li><p>The binary name of a top level <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-7.6">7.6</a>) is its canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>The binary name of a member <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-8.5">8.5</a>, <a href="class-terminology-jls.html#jls-9.5">9.5</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by the simple name of the member.</p></li>
<li><p>The binary name of a local class (<a href="../../../se14/html/jls-14.html#jls-14.3">14.3</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by a non-empty sequence of digits, followed by the simple name of the local class.</p></li>
<li><p>The binary name of an anonymous class (<a href="../../../se14/html/jls-15.html#jls-15.9.5">15.9.5</a>) consists of the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by a non-empty sequence of digits.</p></li>
<li><p>The binary name of a type variable declared by a generic class or interface (<a href="../../../se14/html/jls-8.html#jls-8.1.2">8.1.2</a>, <a href="../../../se14/html/jls-9.html#jls-9.1.2">9.1.2</a>) is the binary name of its immediately enclosing <del>type</del> <strong>class or interface</strong>, followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic method (<a href="../../../se14/html/jls-8.html#jls-8.4.4">8.4.4</a>) is the binary name of the <del>type</del> <strong>class or interface</strong> declaring the method, followed by <code>$</code>, followed by the descriptor of the method (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic constructor (<a href="../../../se14/html/jls-8.html#jls-8.8.4">8.8.4</a>) is the binary name of the <del>type</del> <strong>class</strong> declaring the constructor, followed by <code>$</code>, followed by the descriptor of the constructor (JVMS §4.3.3), followed by <code>$</code>, followed by the simple name of the type variable.</p></li>
</ul></li>
<li><p>A reference to another class or interface <del>type</del> must be symbolic, using the binary name of the <del>type</del> <strong>class or interface</strong>.</p></li>
<li><p>A reference to a field that is a constant variable (<a href="../../../se14/html/jls-4.html#jls-4.12.4">4.12.4</a>) must be resolved at compile time to the value <em>V</em> denoted by the constant variable's initializer.</p>
<p>If such a field is <code>static</code>, then no reference to the field should be present in the code in a binary file, including the class or interface which declared the field. Such a field must always appear to have been initialized (<a href="../../../se14/html/jls-12.html#jls-12.4.2">12.4.2</a>); the default initial value for the field (if different than <em>V</em>) must never be observed.</p>
<p>If such a field is non-<code>static</code>, then no reference to the field should be present in the code in a binary file, except in the class containing the field. (It will be a class rather than an interface, since an interface has only <code>static</code> fields.) The class should have code to set the field's value to <em>V</em> during instance creation (<a href="../../../se14/html/jls-12.html#jls-12.5">12.5</a>).</p></li>
<li><p>Given a legal expression denoting a field access in a class <em>C</em>, referencing a field named <em>f</em> that is not a constant variable and is declared in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying type of the field reference</em> as follows:</p>
<ul>
<li><p>If the expression is referenced by a simple name, then if <em>f</em> is a member of the current class or interface, <em>C</em>, then let <em>T</em> be <em>C</em>. Otherwise, let <em>T</em> be the innermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of which <em>f</em> is a member. In either case, <em>T</em> is the qualifying type of the reference.</p></li>
<li><p>If the reference is of the form <em>TypeName</em><code>.</code><em>f</em>, where <em>TypeName</em> denotes a class or interface, then the class or interface denoted by <em>TypeName</em> is the qualifying type of the reference.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>f</em> or <em>Primary</em><code>.</code><em>f</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="../../../se14/html/jls-4.html#jls-4.9">4.9</a>), then the qualifying type of the reference is <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying type of the reference.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>f</em>, then the superclass of <em>C</em> is the qualifying type of the reference.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>f</em>, then the superclass of the class denoted by <em>TypeName</em> is the qualifying type of the reference.</p></li>
</ul>
<p>The reference to <em>f</em> must be compiled into a symbolic reference to the erasure (<a href="../../../se14/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the reference, plus the simple name of the field, <em>f</em>. The reference must also include a symbolic reference to the erasure of the declared type of the field so that the verifier can check that the type is as expected.</p></li>
<li><p>Given a method invocation expression or a method reference expression in a class or interface <em>C</em>, referencing a method named <em>m</em> declared (or implicitly declared (<a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a>)) in a (possibly distinct) class or interface <em>D</em>, we define the <em>qualifying type of the method invocation</em> as follows:</p>
<ul>
<li><p>If <em>D</em> is <code>Object</code> then the qualifying type of the expression is <code>Object</code>.</p></li>
<li><p>Otherwise:</p>
<ul>
<li><p>If the method is referenced by a simple name, then if <em>m</em> is a member of the current class or interface <em>C</em>, let <em>T</em> be <em>C</em>; otherwise, let <em>T</em> be the innermost lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of which <em>m</em> is a member. In either case, <em>T</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.</code><em>m</em> or <em>ReferenceType</em><code>::</code><em>m</em>, then the type denoted by <em>TypeName</em> or <em>ReferenceType</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>ExpressionName</em><code>.</code><em>m</em> or <em>Primary</em><code>.</code><em>m</em> or <em>ExpressionName</em><code>::</code><em>m</em> or <em>Primary</em><code>::</code><em>m</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is an intersection type <em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a href="../../../se14/html/jls-4.html#jls-4.9">4.9</a>), then the qualifying type of the method invocation is <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is the qualifying type of the method invocation.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>m</em> or <code>super::</code><em>m</em>, then the superclass of <em>C</em> is the qualifying type of the method invocation.</p></li>
<li><p>If the expression is of the form <em>TypeName</em><code>.super.</code><em>m</em> or <em>TypeName</em><code>.super::</code><em>m</em>, then if <em>TypeName</em> denotes a class <em>X</em>, the superclass of <em>X</em> is the qualifying type of the method invocation; if <em>TypeName</em> denotes an interface <em>X</em>, <em>X</em> is the qualifying type of the method invocation.</p></li>
</ul></li>
</ul>
<p>A reference to a method must be resolved at compile time to a symbolic reference to the erasure (<a href="../../../se14/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the invocation, plus the erasure of the signature (<a href="../../../se14/html/jls-8.html#jls-8.4.2">8.4.2</a>) of the method. The signature of a method must include all of the following as determined by <a href="class-terminology-jls.html#jls-15.12.3">15.12.3</a>:</p>
<ul>
<li><p>The simple name of the method</p></li>
<li><p>The number of parameters to the method</p></li>
<li><p>A symbolic reference to the type of each parameter</p></li>
</ul>
<p>A reference to a method must also include either a symbolic reference to the erasure of the return type of the denoted method or an indication that the denoted method is declared <code>void</code> and does not return a value.</p></li>
<li><p>Given a class instance creation expression (<a href="../../../se14/html/jls-15.html#jls-15.9">15.9</a>) or an explicit constructor invocation statement (<a href="class-terminology-jls.html#jls-8.8.7.1">8.8.7.1</a>) or a method reference expression of the form <em>ClassType <code>::</code> <code>new</code></em> (<a href="../../../se14/html/jls-15.html#jls-15.13">15.13</a>) in a class or interface <em>C</em> referencing a constructor <em>m</em> declared in a (possibly distinct) class or interface <em>D</em>, we define the qualifying type of the constructor invocation as follows:</p>
<ul>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...)</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...)</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...)</code> or <em>D</em> <code>::</code> <code>new</code>, then the qualifying type of the invocation is <em>D</em>.</p></li>
<li><p>If the expression is of the form <code>new</code> <em>D</em><code>(...){...}</code> or <em>ExpressionName</em><code>.new</code> <em>D</em><code>(...){...}</code> or <em>Primary</em><code>.new</code> <em>D</em><code>(...){...}</code>, then the qualifying type of the expression is the compile-time type of the expression.</p></li>
<li><p>If the expression is of the form <code>super(...)</code> or <em>ExpressionName</em><code>.super(...)</code> or <em>Primary</em><code>.super(...)</code>, then the qualifying type of the expression is the direct superclass of <em>C</em>.</p></li>
<li><p>If the expression is of the form <code>this(...)</code>, then the qualifying type of the expression is <em>C</em>.</p></li>
</ul>
<p>A reference to a constructor must be resolved at compile time to a symbolic reference to the erasure (<a href="../../../se14/html/jls-4.html#jls-4.6">4.6</a>) of the qualifying type of the invocation, plus the signature of the constructor (<a href="../../../se14/html/jls-8.html#jls-8.8.2">8.8.2</a>). The signature of a constructor must include both:</p>
<ul>
<li><p>The number of parameters of the constructor</p></li>
<li><p>A symbolic reference to the type of each formal parameter</p></li>
</ul></li>
</ol>
<p>A binary representation for a class or interface must also contain all of the following:</p>
<ol type="1">
<li><p>If it is a class and is not <code>Object</code>, then a symbolic reference to the erasure of the direct superclass of this class.</p></li>
<li><p>A symbolic reference to the erasure of each direct superinterface, if any.</p></li>
<li><p>A specification of each field declared in the class or interface, given as the simple name of the field and a symbolic reference to the erasure of the type of the field.</p></li>
<li><p>If it is a class, then the erased signature of each constructor, as described above.</p></li>
<li><p>For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods (<a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a>)), its erased signature and return type, as described above.</p></li>
<li><p>The code needed to implement the class or interface:</p>
<ul>
<li><p>For an interface, code for the field initializers and the implementation of each method with a block body (<a href="../../../se14/html/jls-9.html#jls-9.4.3">9.4.3</a>).</p></li>
<li><p>For a class, code for the field initializers, the instance and static initializers, the implementation of each method with a block body (<a href="../../../se14/html/jls-8.html#jls-8.4.7">8.4.7</a>), and the implementation of each constructor.</p></li>
</ul></li>
<li><p>Every <del>type</del> <strong>class or interface</strong> must contain sufficient information to recover its canonical name (<a href="../../../se14/html/jls-6.html#jls-6.7">6.7</a>).</p></li>
<li><p>Every member <del>type</del> <strong>class or interface</strong> must have sufficient information to recover its source-level access modifier.</p></li>
<li><p>Every nested class <del>and nested</del> <strong>or</strong> interface must have a symbolic reference to its immediately enclosing <del>type</del> <strong>class or interface</strong> (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Every class <strong>or interface</strong> must contain symbolic references to all of its member <del>types</del> <strong>classes and interfaces</strong> (<a href="class-terminology-jls.html#jls-8.5">8.5</a><strong>, <a href="class-terminology-jls.html#jls-9.5">9.5</a></strong>), and to all <del>local and anonymous classes that appear in its methods, constructors, static initializers, instance initializers, and field initializers</del> <strong>other nested classes and interfaces declared within its body</strong>.</p>
<p><del>Every interface must contain symbolic references to all of its member types (<a href="class-terminology-jls.html#jls-9.5">9.5</a>), and to all local and anonymous classes that appear in its default methods and field initializers.</del></p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>synthetic</em> if it does not correspond to a construct declared explicitly or implicitly in source code, unless the emitted construct is a class initialization method (JVMS §2.9).</p></li>
<li><p>A construct emitted by a Java compiler must be marked as <em>mandated</em> if it corresponds to a formal parameter declared implicitly in source code (<a href="../../../se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="../../../se14/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>, <a href="../../../se14/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
</ol>
<blockquote>
<p>The following formal parameters are declared implicitly in source code:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The first formal parameter of a constructor of a non-<code>private</code> inner member class (<a href="../../../se14/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="../../../se14/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
<li><p>The first formal parameter of an anonymous constructor of an anonymous class whose superclass is <del>inner or local</del> <strong>an inner class</strong> (not in a static context) (<a href="../../../se14/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
<li><p>The formal parameter <code>name</code> of the <code>valueOf</code> method which is implicitly declared in an enum <del>type</del> <strong>class</strong> (<a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>).</p></li>
</ul>
</blockquote>
<blockquote>
<p>For reference, the following constructs are declared implicitly in source code, but are not marked as mandated because only formal parameters can be so marked in a <code>class</code> file (JVMS §4.7.24):</p>
</blockquote>
<blockquote>
<ul>
<li><p>Default constructors of classes <del>and enum types</del> (<a href="../../../se14/html/jls-8.html#jls-8.8.9">8.8.9</a>, <a href="class-terminology-jls.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>Anonymous constructors (<a href="../../../se14/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>)</p></li>
<li><p>The <code>values</code> and <code>valueOf</code> methods of enum <del>types</del> <strong>classes</strong> (<a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> fields of enum <del>types</del> <strong>classes</strong> (<a href="class-terminology-jls.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> methods of interfaces (<a href="../../../se14/html/jls-9.html#jls-9.2">9.2</a>)</p></li>
<li><p>Container annotations (<a href="../../../se14/html/jls-9.html#jls-9.7.5">9.7.5</a>)</p></li>
</ul>
</blockquote>
<p>A <code>class</code> file corresponding to a module declaration must have the properties of a <code>class</code> file for a class whose binary name is <code>module-info</code> and which has no superclass, no superinterfaces, no fields, and no methods. In addition, the binary representation of the module must contain all of the following:</p>
<ul>
<li><p>A specification of the name of the module, given as a symbolic reference to the name indicated after <code>module</code>. Also, the specification must include whether the module is normal or open (<a href="../../../se14/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p>A specification of each dependence denoted by a <code>requires</code> directive, given as a symbolic reference to the name of the module indicated by the directive (<a href="../../../se14/html/jls-7.html#jls-7.7.1">7.7.1</a>). Also, the specification must include whether the dependence is <code>transitive</code> and whether the dependence is <code>static</code>.</p></li>
<li><p>A specification of each package denoted by an <code>exports</code> or <code>opens</code> directive, given as a symbolic reference to the name of the package indicated by the directive (<a href="../../../se14/html/jls-7.html#jls-7.7.2">7.7.2</a>). Also, if the directive was qualified, the specification must give symbolic references to the names of the modules indicated by the directive's <code>to</code> clause.</p></li>
<li><p>A specification of each service denoted by a <code>uses</code> directive, given as a symbolic reference to the name of the <del>type</del> <strong>class or interface</strong> indicated by the directive (<a href="../../../se14/html/jls-7.html#jls-7.7.3">7.7.3</a>).</p></li>
<li><p>A specification of the service providers denoted by a <code>provides</code> directive, given as symbolic references to the names of the <del>types</del> <strong>classes and interfaces</strong> indicated by the directive's <code>with</code> clause (<a href="class-terminology-jls.html#jls-7.7.4">7.7.4</a>). Also, the specification must give a symbolic reference to the name of the <del>type</del> <strong>class or interface</strong> indicated as the service by the directive.</p></li>
</ul>
<p>The following sections discuss changes that may be made to class and interface <del>type</del> declarations without breaking compatibility with pre-existing binaries. Under the translation requirements given above, the Java Virtual Machine and its <code>class</code> file format support these changes. Any other valid binary format, such as a compressed or encrypted representation that is mapped back into <code>class</code> files by a class loader under the above requirements, will necessarily support these changes as well.</p>
<h3 id="jls-13.4">13.4 Evolution of Classes</h3>
<h4 id="jls-13.4.26">13.4.26 Evolution of <del>Enums</del> <strong>Enum Classes</strong></h4>
<p>Adding or reordering constants in an enum <strong>declaration</strong> will not break compatibility with pre-existing binaries.</p>
<p><del>If a pre-existing binary attempts to access an enum constant that no longer exists, the client will fail at run time with a <code>NoSuchFieldError</code>. Therefore such a change is not recommended for widely distributed enums.</del></p>
<p><strong>Removing an enum constant will remove the corresponding implicit field declaration, with consequences described in <a href="../../../se14/html/jls-13.html#jls-13.4.8">13.4.8</a>.</strong></p>
<p>In all other respects, the binary compatibility rules for <del>enums</del> <strong>enum classes</strong> are identical to those for <del>classes</del> <strong>normal classes</strong>.</p>
<h3 id="jls-13.5">13.5 Evolution of Interfaces</h3>
<h4 id="jls-13.5.7">13.5.7 Evolution of Annotation <del>Types</del> <strong>Interfaces</strong></h4>
<p>Annotation <del>types</del> <strong>interfaces</strong> behave exactly like any other interface. Adding or removing an element from an annotation <del>type</del> <strong>interface</strong> is analogous to adding or removing a method. There are important considerations governing other changes to annotation <del>types</del> <strong>interfaces</strong>, such as making an annotation <del>type</del> <strong>interface</strong> repeatable (<a href="class-terminology-jls.html#jls-9.6.3">9.6.3</a>), but these have no effect on the linkage of binaries by the Java Virtual Machine. Rather, such changes affect the behavior of reflective APIs that manipulate annotations. The documentation of these APIs specifies their behavior when various changes are made to the underlying annotation <del>types</del> <strong>interfaces</strong>.</p>
<p>Adding or removing annotations has no effect on the correct linkage of the binary representations of programs in the Java programming language.</p>
<h2 id="jls-15">Chapter 15: Expressions</h2>
<h3 id="jls-15.8">15.8 Primary Expressions</h3>
<h4 id="jls-15.8.4">15.8.4 Qualified <code>this</code></h4>
<p>Any lexically enclosing instance (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>) can be referred to by explicitly qualifying the keyword <code>this</code>.</p>
<p>Let <em>T</em> be the type denoted by <em>TypeName</em>. Let <em>n</em> be an integer such that <em>T</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class or interface in which the qualified <code>this</code> expression appears.</p>
<p>The value of an expression of the form <em>TypeName</em><code>.this</code> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p>
<p>The type of the expression is <em>T</em>.</p>
<p>It is a compile-time error if the expression occurs in a class or interface which is not an inner class of class <em>T</em> or <em>T</em> itself.</p>
<h3 id="jls-15.9">15.9 Class Instance Creation Expressions</h3>
<h4 id="jls-15.9.2">15.9.2 Determining Enclosing Instances</h4>
<p>Let <em>C</em> be the class being instantiated, and let <em>i</em> be the instance being created. If <em>C</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance</em> (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>), determined as follows:</p>
<ul>
<li><p>If <em>C</em> is an anonymous class, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, the immediately enclosing instance of <em>i</em> is <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is a local class, then:</p>
<ul>
<li><p>If <em>C</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>O</em> be the immediately enclosing class <strong>or interface declaration</strong> of <em>C</em>. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>C</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, if <em>C</em> is a member of a class enclosing the class <strong>or interface</strong> in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>C</em> is a member. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<p>If <em>C</em> is an anonymous class, and its direct superclass <em>S</em> is an inner class, then <em>i</em> may have an <em>immediately enclosing instance with respect to S</em>, determined as follows:</p>
<ul>
<li><p>If <em>S</em> is a local class, then:</p>
<ul>
<li><p>If <em>S</em> occurs in a static context, then <em>i</em> has no immediately enclosing instance with respect to <em>S</em>.</p></li>
<li><p>Otherwise, if the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, let <em>O</em> be the immediately enclosing <del>type</del> <strong>class or interface</strong> declaration of <em>S</em>. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
</ul></li>
<li><p>If <em>S</em> is an inner member class, then:</p>
<ul>
<li><p>If the class instance creation expression is unqualified, then:</p>
<ul>
<li><p>If the class instance creation expression occurs in a static context, then a compile-time error occurs.</p></li>
<li><p>Otherwise, if <em>S</em> is a member of a class enclosing the class <strong>or interface</strong> in which the class instance creation expression appears, then let <em>O</em> be the immediately enclosing class of which <em>S</em> is a member. Let <em>n</em> be an integer such that <em>O</em> is the <em>n</em>'th lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the class <strong>or interface</strong> in which the class instance creation expression appears.</p>
<p>The immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the <em>n</em>'th lexically enclosing instance of <code>this</code>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the class instance creation expression is qualified, then the immediately enclosing instance of <em>i</em> with respect to <em>S</em> is the object that is the value of the <em>Primary</em> expression or the <em>ExpressionName</em>.</p></li>
</ul></li>
</ul>
<h3 id="jls-15.12">15.12 Method Invocation Expressions</h3>
<h4 id="jls-15.12.1">15.12.1 Compile-Time Step 1: Determine Class or Interface to Search</h4>
<p>The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and which class or interface to search for definitions of methods of that name.</p>
<p>The name of the method is specified by the <em>MethodName</em> or <em>Identifier</em> which immediately precedes the left parenthesis of the <em>MethodInvocation</em>.</p>
<p>For the class or interface to search, there are six cases to consider, depending on the form that precedes the left parenthesis of the <em>MethodInvocation</em>:</p>
<ul>
<li><p>If the form is <em>MethodName</em>, that is, just an <em>Identifier</em>, then:</p>
<p>If the <em>Identifier</em> appears in the scope of a method declaration with that name (<a href="class-terminology-jls.html#jls-6.3">6.3</a>, <a href="../../../se14/html/jls-6.html#jls-6.4.1">6.4.1</a>), then:</p>
<ul>
<li><p>If there is an enclosing <del>type</del> <strong>class or interface</strong> declaration of which that method is a member, let <em>T</em> be the innermost such <del>type</del> <strong>class or interface</strong> declaration. The class or interface to search is <em>T</em>.</p>
<blockquote>
<p>This search policy is called the &quot;comb rule&quot;. It effectively looks for methods in a nested class's superclass hierarchy before looking for methods in an enclosing class and its superclass hierarchy. See <a href="../../../se14/html/jls-6.html#jls-6.5.7.1">6.5.7.1</a> for an example.</p>
</blockquote></li>
<li><p>Otherwise, the method declaration may be in scope due to one or more single-static-import or static-import-on-demand declarations. There is no class or interface to search, as the method to be invoked is determined later (<a href="../../../se14/html/jls-15.html#jls-15.12.2.1">15.12.2.1</a>).</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the type to search is the type denoted by <em>TypeName</em>.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the class or interface to search is the declared type <em>T</em> of the variable denoted by <em>ExpressionName</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p></li>
<li><p>If the form is <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then let <em>T</em> be the type of the <em>Primary</em> expression. The class or interface to search is <em>T</em> if <em>T</em> is a class or interface type, or the upper bound of <em>T</em> if <em>T</em> is a type variable.</p>
<p>It is a compile-time error if <em>T</em> is not a reference type.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the class to search is the superclass of the class whose declaration contains the method invocation.</p>
<p>Let <em>T</em> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. It is a compile-time error if <em>T</em> is the class <code>Object</code> or <em>T</em> is an interface.</p></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if <em>TypeName</em> denotes neither a class nor an interface.</p></li>
<li><p>If <em>TypeName</em> denote a class, <em>C</em>, then the class to search is the superclass of <em>C</em>.</p>
<p>It is a compile-time error if <em>C</em> is not a lexically enclosing <del>type</del> <strong>class or interface</strong> declaration of the current class <strong>or interface</strong>, or if <em>C</em> is the class <code>Object</code>.</p>
<p>Let <em>T</em> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. It is a compile-time error if <em>T</em> is the class <code>Object</code>.</p></li>
<li><p>Otherwise, <em>TypeName</em> denotes the interface to be searched, <em>I</em>.</p>
<p>Let <em>T</em> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. It is a compile-time error if <em>I</em> is not a direct superinterface of <em>T</em>, or if there exists some other direct superclass or direct superinterface of <em>T</em>, <em>J</em>, such that <em>J</em> is a subtype of <em>I</em>.</p></li>
</ul></li>
</ul>
<blockquote>
<p>The <em>TypeName</em> <code>.</code> <code>super</code> syntax is overloaded: traditionally, the <em>TypeName</em> refers to a lexically enclosing <del>type</del> <strong>class</strong> declaration <del>which is a class</del>, and the target is the superclass of this class, as if the invocation were an unqualified <code>super</code> in the lexically enclosing <del>type</del> <strong>class</strong> declaration.</p>
<pre><code>class Superclass {
    void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass1 extends Superclass {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass1.super.foo();  // Gets the &#39;println&#39; behavior
        }
    };
}</code></pre>
<p>To support invocation of default methods in superinterfaces, the <em>TypeName</em> may also refer to a direct superinterface of the current class or interface, and the target is that superinterface.</p>
<pre><code>interface Superinterface {
    default void foo() { System.out.println(&quot;Hi&quot;); }
}

class Subclass2 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    void tweak() {
        Superinterface.super.foo();  // Gets the &#39;println&#39; behavior
    }
}</code></pre>
<p>No syntax supports a combination of these forms, that is, invoking a superinterface method of a lexically enclosing <del>type</del> <strong>class</strong> declaration <del>which is a class</del>, as if the invocation were of the form <em>InterfaceName</em> <code>.</code> <code>super</code> in the lexically enclosing <del>type</del> <strong>class</strong> declaration.</p>
<pre><code>class Subclass3 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass3.Superinterface.super.foo();  // Illegal
        }
    };
}</code></pre>
<p>A workaround is to introduce a <code>private</code> method in the lexically enclosing <del>type</del> <strong>class</strong> declaration<del>,</del> that performs the interface <code>super</code> call.</p>
</blockquote>
<h4 id="jls-15.12.3">15.12.3 Compile-Time Step 3: Is the Chosen Method Appropriate?</h4>
<p>If there is a most specific method declaration for a method invocation, it is called the <em>compile-time declaration</em> for the method invocation.</p>
<p>It is a compile-time error if an argument to a method invocation is not compatible with its target type, as derived from the invocation type of the compile-time declaration.</p>
<p>If the compile-time declaration is applicable by variable arity invocation, then where the last formal parameter type of the invocation type of the method is <em>F<sub>n</sub></em><code>[]</code>, it is a compile-time error if the type which is the erasure of <em>F<sub>n</sub></em> is not accessible (<a href="../../../se14/html/jls-6.html#jls-6.6">6.6</a>) at the point of invocation.</p>
<p>If the compile-time declaration is <code>void</code>, then the method invocation must be a top level expression (that is, the <em>Expression</em> in an expression statement or in the <em>ForInit</em> or <em>ForUpdate</em> part of a <code>for</code> statement), or a compile-time error occurs. Such a method invocation produces no value and so must be used only in a situation where a value is not needed.</p>
<p>In addition, whether the compile-time declaration is appropriate may depend on the form of the method invocation expression before the left parenthesis, as follows:</p>
<ul>
<li><p>If the form is <em>MethodName</em> - that is, just an <em>Identifier</em> - and the compile-time declaration is an instance method, then:</p>
<ul>
<li><p>It is a compile-time error if the method invocation occurs in a static context (<a href="class-terminology-jls.html#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Otherwise, let <em>C</em> be the immediately enclosing class of which the compile-time declaration is a member. If the method invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, then a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must be <code>static</code>, or a compile-time error occurs.</p></li>
<li><p>If the form is <em>ExpressionName</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em> or <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then the compile-time declaration must not be a <code>static</code> method declared in an interface, or a compile-time error occurs.</p></li>
<li><p>If the form is <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
</ul></li>
<li><p>If the form is <em>TypeName</em> <code>.</code> <code>super</code> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em>, then:</p>
<ul>
<li><p>It is a compile-time error if the compile-time declaration is <code>abstract</code>.</p></li>
<li><p>It is a compile-time error if the method invocation occurs in a static context.</p></li>
<li><p>If <em>TypeName</em> denotes a class <em>C</em>, then if the method invocation is not directly enclosed by <em>C</em> or an inner class of <em>C</em>, a compile-time error occurs.</p></li>
<li><p>If <em>TypeName</em> denotes an interface, let <em>T</em> be the <del>type</del> <strong>class or interface</strong> declaration immediately enclosing the method invocation. A compile-time error occurs if there exists a method, distinct from the compile-time declaration, that overrides (<a href="../../../se14/html/jls-9.html#jls-9.4.1">9.4.1</a>) the compile-time declaration from a direct superclass or direct superinterface of <em>T</em>.</p>
<blockquote>
<p>In the case that a superinterface overrides a method declared in a grandparent interface, this rule prevents the child interface from &quot;skipping&quot; the override by simply adding the grandparent to its list of direct superinterfaces. The appropriate way to access functionality of a grandparent is through the direct superinterface, and only if that interface chooses to expose the desired behavior. (Alternately, the programmer is free to define an additional superinterface that exposes the desired behavior with a <code>super</code> method invocation.)</p>
</blockquote></li>
</ul></li>
</ul>
<p>...</p>
</main><footer class="legal-footer"><hr/><a href="https://docs.oracle.com/en/java/javase/15/docs/legal/copyright.html">Copyright</a> &copy; 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java15speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 15+36 --></footer>
</body>
</html>
