<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Specification for JEP 354: Switch Expressions (Preview)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  .inserted, strong, ins {
      background-color: #d0ffd0;
      font-weight: inherit;
      text-decoration: underline;
  }
  del, .deleted {
      background-color: #ffe0e0;
      text-decoration: line-through;
  }
  dl { margin-left: 1.5em; }
  dt { margin-top: .8em; }
  dd { margin-left: 1.5em; }
  p { padding: 0 .2em 0 .2em; }
  div.editorial {
      margin: 2.5em 0 2.5em 2em;
      padding: .8em;
      font-style: italic;
      background-color: #e8e8e8;
      border: 1px dotted #a0a0a0;
  }
  blockquote {
      margin-left: 1.5em;
      font-style: italic;
      font-size: 90%;
  }
  div.example {
      margin-left: 2.5em;
      font-style: italic;
      font-size: 90%;
  }
  blockquote div.example, div.example blockquote {
      font-size: inherit;
  }
  div.example > p:first-child,
  div.table > p:first-child,
  div.grammar > p:first-child {
      font-weight: bold;
      font-style: normal;
  }
  div.example pre {
      margin-left: 2.5em;
      font-style: normal;
  }
  a[href^="http"]::after {
      content:"\202F\21D7";
  }
  </style>
<script>window.ohcglobal || document.write('<script src="https://docs.oracle.com/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<header id="title-block-header">
<h1 class="title">Specification for JEP 354: Switch Expressions (Preview)</h1>
<p>Copyright © 2019 Oracle and/or its affiliates · All Rights Reserved · <a href="http://www.oracle.com/technetwork/java/javase/terms/license/java13speclicense.html">License</a></p>
<p>This document proposes changes to <em>The Java(R) Language Specification, Java SE 13 Edition</em> in support of Switch Expressions, a preview feature of Java SE 13.</p>
<p>See <a href="http://openjdk.java.net/jeps/354">JEP 354</a> for an overview of Switch Expressions.</p>
<p class="date">Last updated 2019-05-28</p>
</header>
<nav id="TOC">
<ul>
<li><a href="switch-expressions.html#summary">Summary</a></li>
<li><a href="switch-expressions.html#jep354-3">Chapter 3: Lexical Structure</a><ul>
<li><a href="switch-expressions.html#jep354-3.8">3.8 Identifiers</a></li>
<li><a href="switch-expressions.html#jep354-3.9">3.9 Keywords</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-5">Chapter 5: Conversions and Contexts</a><ul>
<li><a href="switch-expressions.html#jep354-5.6">5.6 Numeric Contexts</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-6">Chapter 6: Names</a><ul>
<li><a href="switch-expressions.html#jep354-6.5">6.5 Determining the Meaning of a Name</a><ul>
<li><a href="switch-expressions.html#jep354-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</a></li>
</ul></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-11">Chapter 11: Exceptions</a><ul>
<li><a href="switch-expressions.html#jep354-11.2">11.2 Compile-Time Checking of Exceptions</a><ul>
<li><a href="switch-expressions.html#jep354-11.2.1">11.2.1 Exception Analysis of Expressions</a></li>
<li><a href="switch-expressions.html#jep354-11.2.2">11.2.2 Exception Analysis of Statements</a></li>
</ul></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-14">Chapter 14: Blocks and Statements</a><ul>
<li><a href="switch-expressions.html#jep354-14.1">14.1 Normal and Abrupt Completion of Statements</a></li>
<li><a href="switch-expressions.html#jep-14.5">14.5 Statements</a></li>
<li><a href="switch-expressions.html#jep354-14.11">14.11 The <code>switch</code> Statement</a><ul>
<li><a href="switch-expressions.html#jep354-14.11.1"><strong>14.11.1 The Switch Block</strong></a></li>
<li><a href="switch-expressions.html#jep354-14.11.2"><strong>14.11.2 The <code>switch</code> Block of a <code>switch</code> Statement</strong></a></li>
<li><a href="switch-expressions.html#jep354-14.11.3"><strong>14.11.3 Execution of a <code>switch</code> statement</strong></a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-14.15">14.15 The <code>break</code> Statement</a></li>
<li><a href="switch-expressions.html#jep354-14.16">14.16 The <code>continue</code> Statement</a></li>
<li><a href="switch-expressions.html#jep354-14.17">14.17 The <code>return</code> Statement</a></li>
<li><a href="switch-expressions.html#jep354-14.21">14.21 <strong>The <code>yield</code> Statement</strong></a></li>
<li><a href="switch-expressions.html#jep354-14.22"><del>14.21</del> <strong>14.22</strong> Unreachable Statements</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-15">Chapter 15: Expressions</a><ul>
<li><a href="switch-expressions.html#jep354-15.1">15.1 Evaluation, Denotation, and Result</a></li>
<li><a href="switch-expressions.html#jep354-15.2">15.2 Forms of Expressions</a></li>
<li><a href="switch-expressions.html#jep354-15.6">15.6 Normal and Abrupt Completion of Evaluation</a></li>
<li><a href="switch-expressions.html#jep354-15.12">15.12 Method Invocation Expressions</a><ul>
<li><a href="switch-expressions.html#jep354-15.12.2">15.12.2 Compile-Time Step 2: Determine Method Signature</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-15.15">15.15 Unary <del>Operators</del> <strong>Expressions</strong></a></li>
<li><a href="switch-expressions.html#jep354-15.25">15.25 Conditional Operator <code>? :</code></a><ul>
<li><a href="switch-expressions.html#jep354-15.25.1">15.25.1 Boolean Conditional Expressions</a></li>
<li><a href="switch-expressions.html#jep354-15.25.2">15.25.2 Numeric Conditional Expressions</a></li>
<li><a href="switch-expressions.html#jep354-15.25.3">15.25.3 Reference Conditional Expressions</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-15.28"><strong>15.28 <code>switch</code> Expressions</strong></a></li>
<li><a href="switch-expressions.html#jep354-15.28.1"><strong>15.28.1 The switch block of a <code>switch</code> expression</strong></a></li>
<li><a href="switch-expressions.html#jep354-15.28.2"><strong>15.28.2 Run-Time Evaluation of <code>switch</code> Expressions</strong></a></li>
<li><a href="switch-expressions.html#jep354-15.29"><del>15.28</del> <strong>15.29</strong> Constant Expressions</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-16">Chapter 16: Definite Assignment</a><ul>
<li><a href="switch-expressions.html#jep354-16.1">16.1 Definite Assignment and Expressions</a><ul>
<li><a href="switch-expressions.html#jep354-16.1.7"><strong>16.1.7 <code>switch</code> Expressions</strong></a></li>
<li><a href="switch-expressions.html#jep354-16.1.8"><strong>16.1.8 <code>switch</code> Expressions</strong></a></li>
<li><a href="switch-expressions.html#jep354-16.1.9"><del>16.1.7</del> <strong>16.1.9</strong> Other Expressions of Type <code>boolean</code></a></li>
<li><a href="switch-expressions.html#jep354-16.1.10"><del>16.1.8</del> <strong>16.1.10</strong> Assignment Expressions</a></li>
<li><a href="switch-expressions.html#jep354-16.1.11"><del>16.1.9</del> <strong>16.1.11</strong> Operators <code>++</code> and <code>--</code></a></li>
<li><a href="switch-expressions.html#jep354-16.1.12"><del>16.1.10</del> <strong>16.1.12</strong> Other Expressions</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-16.2">16.2 Definite Assignment and Statements</a><ul>
<li><a href="switch-expressions.html#jep354-16.2.9">16.2.9 <code>switch</code> Statements</a></li>
<li><a href="switch-expressions.html#jep354-16.2.13">16.2.13 <code>break</code>, <strong><code>yield</code>,</strong> <code>continue</code>, <code>return</code>, and <code>throw</code> Statements</a></li>
</ul></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-18">Chapter 18: Type Inference</a><ul>
<li><a href="switch-expressions.html#jep354-18.2">18.2 Reduction</a><ul>
<li><a href="switch-expressions.html#jep354-18.2.1">18.2.1 Expression Compatibility Constraints</a></li>
</ul></li>
<li><a href="switch-expressions.html#jep354-18.5">18.5 Uses of Inference</a><ul>
<li><a href="switch-expressions.html#jep354-18.5.2">18.5.2 Invocation Type Inference</a></li>
<li><a href="switch-expressions.html#jep354-18.5.4">18.5.4 More Specific Method Inference</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h3 id="summary">Summary</h3>
<p>This document describes changes to the <a href="https://docs.oracle.com/javase/specs/jls/se11/html">Java Language Specification</a> to enhance the <code>switch</code> statement, including:</p>
<ul>
<li><p>A new body form that evaluates expressions or blocks without fallthrough.</p></li>
<li><p>A new <code>switch</code> <em>expression</em> which, along with a new <code>yield</code> statement, allows a switch to produce a value.</p></li>
</ul>
<div class="editorial">
<p>This version of the draft specification uses a new <code>yield</code> statement to produce a value for a <code>switch</code> expression. The <a href="http://cr.openjdk.java.net/~gbierman/jep354-jls-201905.html">first draft</a> of this specification used a <code>break-with</code> statement.</p>
</div>
<p>See <a href="http://openjdk.java.net/jeps/354">JEP 354</a> for an overview.</p>
<p>Changes are described with respect to existing sections of the Java Language Specification. New text is indicated <strong>like this</strong> and deleted text is indicated <del>like this</del>. Explanation and discussion, as needed, is set aside in grey boxes.</p>
<!-- Need the chapter 3 stuff here -->
<h2 id="jep354-3">Chapter 3: Lexical Structure</h2>
<h3 id="jep354-3.8">3.8 Identifiers</h3>
<p>An <em>identifier</em> is an unlimited-length sequence of <em>Java letters</em> and <em>Java digits</em>, the first of which must be a <em>Java letter</em>.</p>
<dl>
<dt><em>Identifier:</em></dt>
<dd><em>IdentifierChars</em> <em>but not a</em> <em>Keyword</em> <em>or</em> <em>BooleanLiteral</em> <em>or</em> <em>NullLiteral</em>
</dd>
<dt><em>IdentifierChars:</em></dt>
<dd><em>JavaLetter</em> {<em>JavaLetterOrDigit</em>}
</dd>
<dt><em>JavaLetter:</em></dt>
<dd><em>any Unicode character that is a &quot;Java letter&quot;</em>
</dd>
<dt><em>JavaLetterOrDigit:</em></dt>
<dd><em>any Unicode character that is a &quot;Java letter-or-digit&quot;</em>
</dd>
</dl>
<p>A &quot;Java letter&quot; is a character for which the method <code>Character.isJavaIdentifierStart(int)</code> returns true.</p>
<p>A &quot;Java letter-or-digit&quot; is a character for which the method <code>Character.isJavaIdentifierPart(int)</code> returns true.</p>
<blockquote>
<p>The &quot;Java letters&quot; include uppercase and lowercase ASCII Latin letters <code>A-Z</code> (<code>\u0041-\u005a</code>), and <code>a-z</code> (<code>\u0061-\u007a</code>), and, for historical reasons, the ASCII dollar sign (<code>$</code>, or <code>\u0024</code>) and underscore (<code>_</code>, or <code>\u005f</code>). The dollar sign should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems. The underscore may be used in identifiers formed of two or more characters, but it cannot be used as a one-character identifier due to being a keyword.</p>
</blockquote>
<blockquote>
<p>The &quot;Java digits&quot; include the ASCII digits <code>0-9</code> (<code>\u0030-\u0039</code>).</p>
</blockquote>
<p>Letters and digits may be drawn from the entire Unicode character set, which supports most writing scripts in use in the world today, including the large sets for Chinese, Japanese, and Korean. This allows programmers to use identifiers in their programs that are written in their native languages.</p>
<p>An identifier cannot have the same spelling (Unicode character sequence) as a keyword (<a href="../../se11/html/jls-3.html#jls-3.9">3.9</a>), boolean literal (<a href="../../se11/html/jls-3.html#jls-3.10.3">3.10.3</a>), or the null literal (<a href="../../se11/html/jls-3.html#jls-3.10.7">3.10.7</a>), or a compile-time error occurs.</p>
<p>Two identifiers are the same only if, after ignoring characters that are ignorable, the identifiers have the same Unicode character for each letter or digit. An ignorable character is a character for which the method <code>Character.isIdentifierIgnorable(int)</code> returns true. Identifiers that have the same external appearance may yet be different.</p>
<blockquote>
<p>For example, the identifiers consisting of the single letters LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>), LATIN SMALL LETTER A (<code>a</code>, <code>\u0061</code>), GREEK CAPITAL LETTER ALPHA (<code>A</code>, <code>\u0391</code>), CYRILLIC SMALL LETTER A (<code>a</code>, <code>\u0430</code>) and MATHEMATICAL BOLD ITALIC SMALL A (<code>a</code>, <code>\ud835\udc82</code>) are all different.</p>
<p>Unicode composite characters are different from their canonical equivalent decomposed characters. For example, a LATIN CAPITAL LETTER A ACUTE (<code>Á</code>, <code>\u00c1</code>) is different from a LATIN CAPITAL LETTER A (<code>A</code>, <code>\u0041</code>) immediately followed by a NON-SPACING ACUTE (<code>´</code>, <code>\u0301</code>) in identifiers. See The Unicode Standard, Section 3.11 &quot;Normalization Forms&quot;.</p>
</blockquote>
<blockquote>
<p>Examples of identifiers are:</p>
<ul>
<li><code>String</code></li>
<li><code>i3</code></li>
<li>αρετη</li>
<li><code>MAX_VALUE</code></li>
<li><code>isLetterOrDigit</code></li>
</ul>
</blockquote>
<div class="inserted">
<p>The identifiers <code>var</code> and <code>yield</code> are <em>restricted identifiers</em> because they are not allowed in some contexts.</p>
</div>
<p>A <em>type identifier</em> is an identifier that is not the character sequence <code>var</code> <strong>, or the character sequence <code>yield</code></strong>.</p>
<dl>
<dt><em>TypeIdentifier:</em></dt>
<dd><em>Identifier</em> <em>but not</em> <code>var</code> <strong>or <code>yield</code></strong>
</dd>
</dl>
<blockquote>
<p>Type identifiers are used in certain contexts involving the declaration or use of types. For example, the name of a class must be a <em>TypeIdentifier</em>, so it is illegal to declare a class named <code>var</code> <strong>or <code>yield</code></strong> (<a href="../../se11/html/jls-8.html#jls-8.1">8.1</a>).</p>
</blockquote>
<div class="inserted">
<p>An <em>unqualified method identifier</em> is an identifier that is not the character sequence <code>yield</code>.</p>
<dl>
<dt><em>UnqualifiedMethodIdentifier:</em></dt>
<dd><em>Identifier</em> <em>but not</em> <code>yield</code>
</dd>
</dl>
<blockquote>
<p>This restriction allows <code>yield</code> to be used in a <code>yield</code> statement (<a href="switch-expressions.html#jep354-14.21">14.21</a>) and still also be used as a (qualified) method name for compatibility reasons.</p>
</blockquote>
</div>
<h3 id="jep354-3.9">3.9 Keywords</h3>
<p>51 character sequences, formed from ASCII letters, are reserved for use as keywords and cannot be used as identifiers (<a href="../../se11/html/jls-3.html#jls-3.8">3.8</a>).</p>
<dl>
<dt><em>Keyword:</em></dt>
<dd>(one of)
</dd>
<dd><code>abstract continue for new switch</code><br />
<code>assert default if package synchronized</code><br />
<code>boolean do goto private this</code><br />
<code>break double implements protected throw</code><br />
<code>byte else import public throws</code><br />
<code>case enum instanceof return transient</code><br />
<code>catch extends int short try</code><br />
<code>char final interface static void</code><br />
<code>class finally long strictfp volatile</code><br />
<code>const float native super while</code><br />
<code>_</code> (underscore)
</dd>
</dl>
<blockquote>
<p>The keywords <code>const</code> and <code>goto</code> are reserved, even though they are not currently used. This may allow a Java compiler to produce better error messages if these C++ keywords incorrectly appear in programs.</p>
</blockquote>
<blockquote>
<p>A variety of character sequences are sometimes assumed, incorrectly, to be keywords:</p>
</blockquote>
<blockquote>
<ul>
<li><p><code>true</code> and <code>false</code> are not keywords, but rather boolean literals (<a href="../../se11/html/jls-3.html#jls-3.10.3">3.10.3</a>).</p></li>
<li><p><code>null</code> is not a keyword, but rather the null literal (<a href="../../se11/html/jls-3.html#jls-3.10.7">3.10.7</a>).</p></li>
<li><p><del><code>var</code> is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration (<a href="../../se11/html/jls-14.html#jls-14.4">14.4</a>, <a href="../../se11/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="../../se11/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="../../se11/html/jls-14.html#jls-14.20.3">14.20.3</a>) and the type of a lambda formal parameter (<a href="../../se11/html/jls-15.html#jls-15.27.1">15.27.1</a>).</del></p></li>
</ul>
</blockquote>
<div class="inserted">
<blockquote>
<ul>
<li>The restricted identifiers <code>var</code> and <code>yield</code> are not keywords. <code>var</code> has special meaning as the type of a local variable declaration (<a href="../../se11/html/jls-14.html#jls-14.4">14.4</a>, <a href="../../se11/html/jls-14.html#jls-14.14.1">14.14.1</a>, <a href="../../se11/html/jls-14.html#jls-14.14.2">14.14.2</a>, <a href="../../se11/html/jls-14.html#jls-14.20.3">14.20.3</a>) and the type of a lambda formal parameter (<a href="../../se11/html/jls-15.html#jls-15.27.1">15.27.1</a>). <code>yield</code> has special meaning in a <code>yield</code> statement (<a href="switch-expressions.html#jep354-14.21">14.21</a>). All invocations of a method called <code>yield</code> must be qualified so as to be distinguished from a <code>yield</code> statement.</li>
</ul>
</blockquote>
</div>
<p>A further ten character sequences are <em>restricted keywords</em>: <code>open</code>, <code>module</code>, <code>requires</code>, <code>transitive</code>, <code>exports</code>, <code>opens</code>, <code>to</code>, <code>uses</code>, <code>provides</code>, and <code>with</code>. These character sequences are tokenized as keywords solely where they appear as terminals in the <em>ModuleDeclaration</em>, <em>ModuleDirective</em>, and <em>RequiresModifier</em> productions (<a href="../../se11/html/jls-7.html#jls-7.7">7.7</a>). They are tokenized as identifiers everywhere else, for compatibility with programs written before the introduction of restricted keywords. There is one exception: immediately to the right of the character sequence <code>requires</code> in the <em>ModuleDirective</em> production, the character sequence <code>transitive</code> is tokenized as a keyword unless it is followed by a separator, in which case it is tokenized as an identifier.</p>
<h2 id="jep354-5">Chapter 5: Conversions and Contexts</h2>
<p>Every expression written in the Java programming language either produces no result (<a href="switch-expressions.html#jep354-15.1">15.1</a>) or has a type that can be deduced at compile time (<a href="../../se11/html/jls-15.html#jls-15.3">15.3</a>). When an expression appears in most contexts, it must be <em>compatible</em> with a type expected in that context; this type is called the <em>target type</em>. For convenience, compatibility of an expression with its surrounding context is facilitated in two ways:</p>
<ul>
<li><p>First, for some expressions, termed <em>poly expressions</em> (<a href="switch-expressions.html#jep354-15.2">15.2</a>), the deduced type can be influenced by the target type. The same expression can have different types in different contexts.</p></li>
<li><p>Second, after the type of the expression has been deduced, an implicit <em>conversion</em> from the type of the expression to the target type can sometimes be performed.</p></li>
</ul>
<p>If neither strategy is able to produce the appropriate type, a compile-time error occurs.</p>
<p>The rules determining whether an expression is a poly expression, and if so, its type and compatibility in a particular context, vary depending on the kind of context and the form of the expression. In addition to influencing the type of the expression, the target type may in some cases influence the run time behavior of the expression in order to produce a value of the appropriate type.</p>
<p>Similarly, the rules determining whether a target type allows an implicit conversion vary depending on the kind of context, the type of the expression, and, in one special case, the value of a constant expression (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>). A conversion from type <em>S</em> to type <em>T</em> allows an expression of type <em>S</em> to be treated at compile time as if it had type <em>T</em> instead. In some cases this will require a corresponding action at run time to check the validity of the conversion or to translate the run-time value of the expression into a form appropriate for the new type <em>T</em>.</p>
<div class="example">
<p>Example 5.0-1. Conversions at Compile Time and Run Time</p>
<ul>
<li><p>A conversion from type <code>Object</code> to type <code>Thread</code> requires a run-time check to make sure that the run-time value is actually an instance of class <code>Thread</code> or one of its subclasses; if it is not, an exception is thrown.</p></li>
<li><p>A conversion from type <code>Thread</code> to type <code>Object</code> requires no run-time action; <code>Thread</code> is a subclass of <code>Object</code>, so any reference produced by an expression of type <code>Thread</code> is a valid reference value of type <code>Object</code>.</p></li>
<li><p>A conversion from type <code>int</code> to type <code>long</code> requires run-time sign-extension of a 32-bit integer value to the 64-bit <code>long</code> representation. No information is lost.</p></li>
<li><p>A conversion from type <code>double</code> to type <code>long</code> requires a non-trivial translation from a 64-bit floating-point value to the 64-bit integer representation. Depending on the actual run-time value, information may be lost.</p></li>
</ul>
</div>
<p>The conversions possible in the Java programming language are grouped into several broad categories:</p>
<ul>
<li>Identity conversions</li>
<li>Widening primitive conversions</li>
<li>Narrowing primitive conversions</li>
<li>Widening reference conversions</li>
<li>Narrowing reference conversions</li>
<li>Boxing conversions</li>
<li>Unboxing conversions</li>
<li>Unchecked conversions</li>
<li>Capture conversions</li>
<li>String conversions</li>
<li>Value set conversions</li>
</ul>
<p>There are six kinds of <em>conversion contexts</em> in which poly expressions may be influenced by context or implicit conversions may occur. Each kind of context has different rules for poly expression typing and allows conversions in some of the categories above but not others. The contexts are:</p>
<ul>
<li><p>Assignment contexts (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>, <a href="../../se11/html/jls-15.html#jls-15.26">15.26</a>), in which an expression's value is bound to a named variable. Primitive and reference types are subject to widening, values may be boxed or unboxed, and some primitive constant expressions may be subject to narrowing. An unchecked conversion may also occur.</p></li>
<li><p>Strict invocation contexts (<a href="../../se11/html/jls-5.html#jls-5.3">5.3</a>, <a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>, <a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>), in which an argument is bound to a formal parameter of a constructor or method. Widening primitive, widening reference, and unchecked conversions may occur.</p></li>
<li><p>Loose invocation contexts (<a href="../../se11/html/jls-5.html#jls-5.3">5.3</a>, <a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>, <a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>), in which, like strict invocation contexts, an argument is bound to a formal parameter. Method or constructor invocations may provide this context if no applicable declaration can be found using only strict invocation contexts. In addition to widening and unchecked conversions, this context allows boxing and unboxing conversions to occur.</p></li>
<li><p>String contexts (<a href="../../se11/html/jls-5.html#jls-5.4">5.4</a>, <a href="../../se11/html/jls-15.html#jls-15.18.1">15.18.1</a>), in which a value of any type is converted to an object of type <code>String</code>.</p></li>
<li><p>Casting contexts (<a href="../../se11/html/jls-5.html#jls-5.5">5.5</a>), in which an expression's value is converted to a type explicitly specified by a cast operator (<a href="../../se11/html/jls-15.html#jls-15.16">15.16</a>). Casting contexts are more inclusive than assignment or loose invocation contexts, allowing any specific conversion other than a string conversion, but certain casts to a reference type are checked for correctness at run time.</p></li>
<li><p>Numeric contexts (<a href="switch-expressions.html#jep354-5.6">5.6</a>), in which the operands of a numeric operator <strong>or some other expressions that operate on numbers</strong> may be widened to a common type <del>so that an operation can be performed</del>.</p></li>
</ul>
<p>The term &quot;conversion&quot; is also used to describe, without being specific, any conversions allowed in a particular context. For example, we say that an expression that is the initializer of a local variable is subject to &quot;assignment conversion&quot;, meaning that a specific conversion will be implicitly chosen for that expression according to the rules for the assignment context.</p>
<div class="example">
<p>Example 5.0-2. Conversions In Various Contexts</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> Test {            </a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">        <span class="co">// Casting conversion (5.4) of a float literal to</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">        <span class="co">// type int. Without the cast operator, this would</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        <span class="co">// be a compile-time error, because this is a</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        <span class="co">// narrowing conversion (5.1.3):</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">        <span class="dt">int</span> i = (<span class="dt">int</span>)<span class="fl">12.5f</span>;</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">        <span class="co">// String conversion (5.4) of i&#39;s int value:</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;(int)12.5f==&quot;</span> + i);</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        <span class="co">// Assignment conversion (5.2) of i&#39;s value to type</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">        <span class="co">// float. This is a widening conversion (5.1.2):</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">        <span class="dt">float</span> f = i;</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">        <span class="co">// String conversion of f&#39;s float value:</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;after float widening: &quot;</span> + f);</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">        <span class="co">// Numeric promotion (5.6) of i&#39;s value to type</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">        <span class="co">// float. This is a binary numeric promotion.</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">        <span class="co">// After promotion, the operation is float*float:</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(f);</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">        f = f * i;</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">        <span class="co">// Two string conversions of i and f:</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;*&quot;</span> + i + <span class="st">&quot;==&quot;</span> + f);</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">        <span class="co">// Invocation conversion (5.3) of f&#39;s value</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">        <span class="co">// to type double, needed because the method Math.sin</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30">        <span class="co">// accepts only a double argument:</span></a>
<a class="sourceLine" id="cb1-31" data-line-number="31">        <span class="dt">double</span> d = <span class="bu">Math</span>.<span class="fu">sin</span>(f);</a>
<a class="sourceLine" id="cb1-32" data-line-number="32"></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">        <span class="co">// Two string conversions of f and d:</span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Math.sin(&quot;</span> + f + <span class="st">&quot;)==&quot;</span> + d);</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">    }</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">}</a></code></pre></div>
<p>This program produces the output:</p>
<pre><code>(int)12.5f==12
after float widening: 12.0
12.0*12==144.0
Math.sin(144.0)==-0.49102159389846934</code></pre>
</div>
<h3 id="jep354-5.6">5.6 Numeric Contexts</h3>
<div class="editorial">
<p>The entire section 5.6 has been re-organised and is replaced with the following text. (Sections 5.6.1 and 5.6.2 are now inlined in the section.)</p>
</div>
<div class="inserted">
<p><em>Numeric contexts</em> apply to the operands of arithmetic operators, array creation and access expressions, conditional expressions, and the result expressions of <code>switch</code> expressions.</p>
<p>An expression appears in a numeric context if it is one of:</p>
<ol type="1">
<li><p>the dimension expression in an array creation expression (<a href="../../se11/html/jls-15.html#jls-15.10.1">15.10.1</a>)</p></li>
<li><p>the index expression in an array access expression (<a href="../../se11/html/jls-15.html#jls-15.10.3">15.10.3</a>)</p></li>
<li><p>the operand of a unary operator <code>+</code>, <code>-</code>, or <code>~</code></p></li>
<li><p>an operand of a binary operator <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code></p></li>
<li><p>an operand of a shift operator <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, or <code>&gt;&gt;&gt;</code>. Operands to these shift operators are treated separately rather than as a group. A <code>long</code> shift distance (right operand) does not promote the value being shifted (left operand) to <code>long</code>.</p></li>
<li><p>an operand of a binary operator <code>+</code>, <code>==</code>, <code>!=</code>, <code>&amp;</code>, <code>^</code>, or <code>|</code>, where the operands are both convertible to a numeric type</p></li>
<li><p>the second or third operand of a numeric conditional expression ([15.25.2])</p></li>
<li><p>a result expression of a standalone <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28.1">15.28.1</a>), where all the result expressions are convertible to a numeric type</p></li>
</ol>
<p>The number of expressions in a numeric context depends on the context. Some contexts have exactly one expression, some contexts have exactly two, and some have an arbitrary number.</p>
<p>Numeric contexts are divided into three kinds:</p>
<ul>
<li><p>A <em>numeric array context</em> is a numeric context that is either an array creation expression, or an array access expression.</p></li>
<li><p>A <em>numeric choice context</em> is a numeric context that is either a numeric conditional expression or a standalone <code>switch</code> expression where all the result expressions are convertible to a numeric type.</p></li>
<li><p>A <em>numeric arithmetic context</em> is a numeric context is not an numeric array context and is not a numeric choice context.</p></li>
</ul>
<p>Numeric promotion is a process that determines a <em>promoted type</em> for the expressions in a numeric context. This promoted type, <em>T</em>, is chosen such that each expression can be converted to <em>T</em> and, in the case of an arithmetic operation, the operation is defined for values of type <em>T</em>. The order of expressions in a numeric context is not significant in the process of numeric promotion.</p>
<p>Numeric promotion applies the following steps:</p>
<ol type="1">
<li><p>If any expression is of a reference type, it is subjected to unboxing conversion (5.1.8).</p></li>
<li><p>Next, widening primitive conversion (<a href="../../se11/html/jls-5.html#jls-5.1.2">5.1.2</a>) and narrowing primitive conversion (<a href="../../se11/html/jls-5.html#jls-5.1.3">5.1.3</a>) are applied to some expressions in the process of determining a promoted type, as specified by the following rules:</p></li>
</ol>
<ul>
<li><p>If any expression is of type <code>double</code>, then the promoted type is <code>double</code>, and other expressions that are not of type <code>double</code> undergo widening primitive conversion to <code>double</code>.</p></li>
<li><p>Otherwise, if any expression is of type <code>float</code>, then the promoted type is <code>float</code> and other expressions that are not of type <code>float</code> undergo widening primitive conversion to <code>float</code>.</p></li>
<li><p>Otherwise, if any expression is of type <code>long</code>, then the promoted type is <code>long</code> and other expressions that are not of type <code>long</code> undergo widening primitive conversion to <code>long</code>.</p></li>
<li><p>Otherwise, if any expression appears in a numeric array context or a numeric arithmetic context, rather than a numeric choice context, then the promoted type is <code>int</code> and other expressions that are not of type <code>int</code> undergo widening primitive conversion to <code>int</code>.</p></li>
<li><p>Otherwise, the expression is in a numeric choice context and the following rules apply:</p></li>
<li><p>If any expression is of type <code>int</code> and is not a constant expression, then <em>T</em> is <code>int</code> and other expressions that are not of type <code>int</code> undergo widening primitive conversion to <code>int</code>.</p></li>
<li><p>Otherwise, if any expression is of type <code>short</code>, and every other expression is either of type <code>short</code>, or of type <code>byte</code>, or a constant expression of type <code>int</code> with a value that is representable in the type <code>short</code>, then <em>T</em> is <code>short</code>, the <code>byte</code> expressions undergo widening primitive conversion to <code>short</code>, and the <code>int</code> expressions undergo narrowing primitive conversion to <code>short</code>.</p></li>
<li><p>Otherwise, if any expression is of type <code>byte</code>, and every other expression is either of type <code>byte</code> or a constant expression of type <code>int</code> with a value that is representable in the type <code>byte</code>, then <em>T</em> is <code>byte</code> and the <code>int</code> expressions undergo narrowing primitive conversion to <code>byte</code>.</p></li>
<li><p>Otherwise, if any expression is of type <code>char</code>, and every other expression is either of type <code>char</code> or a constant expression of type <code>int</code> with a value that is representable in the type <code>char</code>, then <em>T</em> is <code>char</code> and the <code>int</code> expressions undergo narrowing primitive conversion to <code>char</code>.</p></li>
<li><p>Otherwise, <em>T</em> is <code>int</code> and all the expressions that are not of type <code>int</code> undergo widening primitive conversion to <code>int</code>.</p></li>
</ul>
<ol start="3" type="1">
<li>After the conversion(s), if any, value set conversion (5.1.13) is then applied to each expression.</li>
</ol>
<p>A <em>unary numeric promotion</em> applies numeric promotion to a single expression that occurs in a numeric context. A <em>binary numeric promotion</em> is performed on a pair of expressions that occur in a numeric context that is not a numeric choice context.</p>
<div class="example">
<p>Example 5.6-1. Unary Numeric Promotion</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">        <span class="dt">byte</span> b = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">        <span class="dt">int</span> a[] = <span class="kw">new</span> <span class="dt">int</span>[b];  <span class="co">// dimension expression promotion</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">        <span class="dt">char</span> c = <span class="ch">&#39;\u0001&#39;</span>;</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">        a[c] = <span class="dv">1</span>;              <span class="co">// index expression promotion</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">        a[<span class="dv">0</span>] = -c;             <span class="co">// unary - promotion</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;a: &quot;</span> + a[<span class="dv">0</span>] + <span class="st">&quot;,&quot;</span> + a[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        b = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        <span class="dt">int</span> i = ~b;            <span class="co">// bitwise complement promotion</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;~0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(b)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                           + <span class="st">&quot;==0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(i));</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        i = b &lt;&lt; 4L;           <span class="co">// shift promotion (left operand)</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(b)</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">                           + <span class="st">&quot;&lt;&lt;4L==0x&quot;</span> + <span class="bu">Integer</span>.<span class="fu">toHexString</span>(i));</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">}</a></code></pre></div>
<p>This program produces the output:</p>
<pre><code>a: -1,1
~0xffffffff==0x0
0xffffffff&lt;&lt;4L==0xfffffff0</code></pre>
<p>Example 5.6-2. Binary Numeric Promotion</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">int</span> i    = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        <span class="dt">float</span> f  = <span class="fl">1.0f</span>;</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        <span class="dt">double</span> d = <span class="fl">2.0</span>;</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">        <span class="co">// First int*float is promoted to float*float, then</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">        <span class="co">// float==double is promoted to double==double:</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">        <span class="kw">if</span> (i * f == d) <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;oops&quot;</span>);</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">        <span class="co">// A char&amp;byte is promoted to int&amp;int:</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">        <span class="dt">byte</span> b = <span class="bn">0x1f</span>;</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">        <span class="dt">char</span> c = <span class="ch">&#39;G&#39;</span>;</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">        <span class="dt">int</span> control = c &amp; b;</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="bu">Integer</span>.<span class="fu">toHexString</span>(control));</a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">        <span class="co">// Here int:float is promoted to float:float:</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">        f = (b==<span class="dv">0</span>) ? i : <span class="fl">4.0f</span>;</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="fl">1.0</span>/f);</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">}</a></code></pre></div>
<p>This program produces the output:</p>
<pre><code>7
0.25</code></pre>
<p>The example converts the ASCII character <code>G</code> to the ASCII control-G (BEL), by masking off all but the low 5 bits of the character. The <code>7</code> is the numeric value of this control character.</p>
</div>
</div>
<!--
*Numeric contexts* apply to the operands of ~~an arithmetic operator~~
**arithmetic operators, and some other expressions that operate on numbers**.

Numeric contexts allow the use of:

-   an identity conversion ([5.1.1])

-   a widening primitive conversion ([5.1.2])

-   a widening reference conversion ([5.1.5]) followed by an unboxing conversion

-   a widening reference conversion followed by an unboxing conversion, then
    followed by a widening primitive conversion

-   an unboxing conversion ([5.1.8])

-   an unboxing conversion followed by a widening primitive conversion

A *numeric promotion* is a process by which~~, given an arithmetic operator and
its argument expressions, the arguments are~~ **one or more expressions in a
numeric context are** converted to an inferred target type
*T*. *T* is chosen during promotion such that each ~~argument~~ expression can be
converted to *T* and ~~the arithmetic operation~~ **, in the case of an
arithmetic operation, the operation** is defined for values of type *T*.

:::inserted

Numeric promotion is defined by the following steps

1.   If any expression is of a reference type, it is subjected to unboxing
    conversion (5.1.8).

2.   Next, a target type *T* is chosen, and widening primitive conversion
    ([5.1.2]) and narrowing primitive conversion ([5.1.3]) are applied to some
    expressions as specified by the following rules:

  -   If any expression is of type `double`, then *T* is `double`, and
        other expressions that are not of type `double` are widened to
        `double`.

  -   Otherwise, if any expression is of type `float`, then *T* is `float`
        and other expressions that are not of type `float` are widened to
        `float`.

  -   Otherwise, if any expression is of type `long`, then *T* is `long` and
        other expressions that are not of type `long` are widened to `long`.

  -   Otherwise, if any expression is of type `int` and is not a constant
        expression, then *T* is `int` and other expressions that are not of type
        `int` are widened to `int`.

  -   Otherwise, if any expression is of type `short`, and every other
        expression is either of type `short`, or of type `byte`, or a constant
        expression of type `int` with a value that is representable in the type
        `short`, then *T* is `short`, the `byte` expressions are widened to
        `short`, and the `int` expressions are narrowed to `short`.

  -   Otherwise, if any expression is of type `byte`, and every other
        expression is either of type `byte` or a constant expression of type
        `int` with a value that is representable in the type `byte`, then *T* is
        `byte` and the `int` expressions are narrowed to `byte`.

  -   Otherwise, if any expression is of type `char`, and every other
        expression is either of type `char` or a constant expression of type
        `int` with a value that is representable in the type `char`, then *T* is
        `char` and the `int` expressions are narrowed to `char`.

  -   Otherwise, *T* is `int` and all the expressions that are not of type
        `int` are widened to `int`.

3.   After the conversion(s), if any, value set conversion (5.1.13) is then
    applied to each expression.

:::

~~The two kinds of numeric promotion are unary numeric promotion ([5.6.1]) and
binary numeric promotion ([5.6.2]).~~

:::editorial
The following subsections are small enough that they can be removed, with their
contents collapsed into this section.
:::



#### ~~5.6.1 Unary Numeric Promotion~~ {#jep354-5.6.1}

:::deleted

Some operators apply *unary numeric promotion* to a single operand, which must
produce a value of a numeric type:

-   If the operand is of compile-time type `Byte`, `Short`, `Character`, or
    `Integer`, it is subjected to unboxing conversion ([5.1.8]).
    The result is then promoted to a value of type `int` by a widening primitive
    conversion ([5.1.2]) or an identity conversion ([5.1.1]).

-   Otherwise, if the operand is of compile-time type `Long`, `Float`, or
    `Double`, it is subjected to unboxing conversion ([5.1.8]).

-   Otherwise, if the operand is of compile-time type `byte`, `short`, or
    `char`, it is promoted to a value of type `int` by a widening primitive
    conversion ([5.1.2]).

-   Otherwise, a unary numeric operand remains as is and is not converted.

After the conversion(s), if any, value set conversion ([5.1.13]) is then
applied.

:::

**A *unary numeric promotion* applies numeric promotion to an operand expression
and a notional non-constant expression of type `int`.**

Unary numeric promotion is performed on expressions in the following situations:

-   Each dimension expression in an array creation expression ([15.10.1])

-   The index expression in an array access expression ([15.10.3])

-   The operand of a unary plus operator `+` ([15.15.3])

-   The operand of a unary minus operator `-` ([15.15.4])

-   The operand of a bitwise complement operator `~` ([15.15.5])

-   Each operand, separately, of a shift operator `<<`, `>>`, or `>>>`
    ([15.19]).

    A `long` shift distance (right operand) does not promote the value being
    shifted (left operand) to `long`.

:::example

Example ~~5.6.1-1~~ **5.6-1**. Unary Numeric Promotion

```java
class Test {
    public static void main(String[] args) {
        byte b = 2;
        int a[] = new int[b];  // dimension expression promotion
        char c = '\u0001';
        a[c] = 1;              // index expression promotion
        a[0] = -c;             // unary - promotion
        System.out.println("a: " + a[0] + "," + a[1]);
        b = -1;
        int i = ~b;            // bitwise complement promotion
        System.out.println("~0x" + Integer.toHexString(b)
                           + "==0x" + Integer.toHexString(i));
        i = b << 4L;           // shift promotion (left operand)
        System.out.println("0x" + Integer.toHexString(b)
                           + "<<4L==0x" + Integer.toHexString(i));
    }
}
```

This program produces the output:

    a: -1,1
    ~0xffffffff==0x0
    0xffffffff<<4L==0xfffffff0

:::



#### ~~5.6.2 Binary Numeric Promotion~~ {#jep354-5.6.2}

:::deleted

When an operator applies *binary numeric promotion* to a pair of operands, each
of which must denote a value that is convertible to a numeric type, the
following rules apply, in order:

1.  If any operand is of a reference type, it is subjected to unboxing
    conversion ([5.1.8]).

2.  Widening primitive conversion ([5.1.2]) is applied to convert either or both
    operands as specified by the following rules:

    -   If either operand is of type `double`, the other is converted to
        `double`.

    -   Otherwise, if either operand is of type `float`, the other is converted
        to `float`.

    -   Otherwise, if either operand is of type `long`, the other is converted
        to `long`.

    -   Otherwise, both operands are converted to type `int`.

After the conversion(s), if any, value set conversion ([5.1.13]) is then applied
to each operand.

:::

**A *binary numeric promotion* applies numeric promotion to two operand
expressions and a notional non-constant expression of type `int`.**

Binary numeric promotion is performed on the operands of certain operators:

-   The multiplicative operators `*`, `/`, and `%` ([15.17])

-   The addition and subtraction operators for numeric types `+` and `-`
    ([15.18.2])

-   The numerical comparison operators `<`, `<=`, `>`, and `>=` ([15.20.1])

-   The numerical equality operators `==` and `!=` ([15.21.1])

-   The integer bitwise operators `&`, `^`, and `|` ([15.22.1])


**Numeric promotion is performed directly on expressions in the following
situations:**

-   **The second and third operand of a numeric conditional expression
    ([15.25.2])**

-   **The result expressions of a `switch` expression, if the type of each result
    expression is convertible to a numeric type ([15.28.1])**

:::example

Example ~~5.6.2-1~~ **5.6-2**. Binary Numeric Promotion

```java
class Test {
    public static void main(String[] args) {
        int i    = 0;
        float f  = 1.0f;
        double d = 2.0;
        // First int*float is promoted to float*float, then
        // float==double is promoted to double==double:
        if (i * f == d) System.out.println("oops");

        // A char&byte is promoted to int&int:
        byte b = 0x1f;
        char c = 'G';
        int control = c & b;
        System.out.println(Integer.toHexString(control));

        // Here int:float is promoted to float:float:
        f = (b==0) ? i : 4.0f;
        System.out.println(1.0/f);
    }
}
```

This program produces the output:

    7
    0.25

The example converts the ASCII character `G` to the ASCII control-G (BEL), by
masking off all but the low 5 bits of the character.
The `7` is the numeric value of this control character.

:::
-->
<h2 id="jep354-6">Chapter 6: Names</h2>
<h3 id="jep354-6.5">6.5 Determining the Meaning of a Name</h3>
<p>The meaning of a name depends on the context in which it is used. The determination of the meaning of a name requires three steps:</p>
<ul>
<li><p>First, context causes a name syntactically to fall into one of seven categories: <em>ModuleName</em>, <em>PackageName</em>, <em>TypeName</em>, <em>ExpressionName</em>, <em>MethodName</em>, <em>PackageOrTypeName</em>, or <em>AmbiguousName</em>.</p>
<p><em>TypeName</em> <strong>and MethodName</strong> <del>is</del> <strong>are</strong> less expressive than the other <del>six</del> <strong>five</strong> categories, because <del>it is</del> <strong>they are</strong> denoted with <em>TypeIdentifier</em> <strong>and <em>UnqualifiedMethodIdentifier</em>, respectively</strong>. <strong>In the former case this</strong> <del>, which</del> excludes the character <del>sequence</del> <strong>sequences</strong> <code>var</code> <strong>and <code>yield</code></strong> (<a href="../../se11/html/jls-3.html#jls-3.8">3.8</a>)<strong>, and in the later it excludes the character sequence <code>yield</code></strong>.</p></li>
<li><p>Second, a name that is initially classified by its context as an <em>AmbiguousName</em> or as a <em>PackageOrTypeName</em> is then reclassified to be a <em>PackageName</em>, <em>TypeName</em>, or <em>ExpressionName</em>.</p></li>
<li><p>Third, the resulting category then dictates the final determination of the meaning of the name (or a compile-time error if the name has no meaning).</p></li>
</ul>
<dl>
<dt><em>ModuleName:</em></dt>
<dd><em>Identifier</em>
</dd>
<dd><em>ModuleName</em> <code>.</code> <em>Identifier</em>
</dd>
<dt><em>PackageName:</em></dt>
<dd><em>Identifier</em>
</dd>
<dd><em>PackageName</em> <code>.</code> <em>Identifier</em>
</dd>
<dt><em>TypeName:</em></dt>
<dd><em>TypeIdentifier</em>
</dd>
<dd><em>PackageOrTypeName</em> <code>.</code> <em>TypeIdentifier</em>
</dd>
<dt><em>PackageOrTypeName:</em></dt>
<dd><em>Identifier</em>
</dd>
<dd><em>PackageOrTypeName</em> <code>.</code> <em>Identifier</em>
</dd>
<dt><em>ExpressionName:</em></dt>
<dd><em>Identifier</em>
</dd>
<dd><em>AmbiguousName</em> <code>.</code> <em>Identifier</em>
</dd>
<dt><em>MethodName:</em></dt>
<dd><del><em>Identifier</em></del> <strong><em>UnqualifiedMethodIdentifier</em></strong>
</dd>
<dt><em>AmbiguousName:</em></dt>
<dd><em>Identifier</em>
</dd>
<dd><em>AmbiguousName</em> <code>.</code> <em>Identifier</em>
</dd>
</dl>
<blockquote>
<p>The use of context helps to minimize name conflicts between entities of different kinds. Such conflicts will be rare if the naming conventions described in <a href="../../se11/html/jls-6.html#jls-6.1">6.1</a> are followed. Nevertheless, conflicts may arise unintentionally as types developed by different programmers or different organizations evolve. For example, types, methods, and fields may have the same name. It is always possible to distinguish between a method and a field with the same name, since the context of a use always tells whether a method is intended.</p>
</blockquote>
<h4 id="jep354-6.5.2">6.5.2 Reclassification of Contextually Ambiguous Names</h4>
<p>An <em>AmbiguousName</em> is then reclassified as follows.</p>
<p>If the <em>AmbiguousName</em> is a simple name, consisting of a single <em>Identifier</em>:</p>
<ul>
<li><p>If the <em>Identifier</em> appears within the scope (<a href="../../se11/html/jls-6.html#jls-6.3">6.3</a>) of a local variable declaration (<a href="../../se11/html/jls-14.html#jls-14.4">14.4</a>) or parameter declaration (<a href="../../se11/html/jls-8.html#jls-8.4.1">8.4.1</a>, <a href="../../se11/html/jls-8.html#jls-8.8.1">8.8.1</a>, <a href="../../se11/html/jls-14.html#jls-14.20">14.20</a>) or field declaration (<a href="../../se11/html/jls-8.html#jls-8.3">8.3</a>) with that name, then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if a field of that name is declared in the compilation unit (<a href="../../se11/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em> by a single-static-import declaration (<a href="../../se11/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="../../se11/html/jls-7.html#jls-7.5.4">7.5.4</a>) then the <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and appears within the scope (<a href="../../se11/html/jls-6.html#jls-6.3">6.3</a>) of a top level class (<a href="../../se11/html/jls-8.html">8</a>) or interface type declaration (<a href="../../se11/html/jls-9.html">9</a>), a local class declaration (<a href="../../se11/html/jls-14.html#jls-14.3">14.3</a>) or member type declaration (<a href="../../se11/html/jls-8.html#jls-8.5">8.5</a>, <a href="../../se11/html/jls-9.html#jls-9.5">9.5</a>) with that name, then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and a type of that name is declared in the compilation unit (<a href="../../se11/html/jls-7.html#jls-7.3">7.3</a>) containing the <em>Identifier</em>, either by a single-type-import declaration (<a href="../../se11/html/jls-7.html#jls-7.5.1">7.5.1</a>), or by a type-import-on-demand declaration (<a href="../../se11/html/jls-7.html#jls-7.5.2">7.5.2</a>), or by a single-static-import declaration (<a href="../../se11/html/jls-7.html#jls-7.5.3">7.5.3</a>), or by a static-import-on-demand declaration (<a href="../../se11/html/jls-7.html#jls-7.5.4">7.5.4</a>), then the <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, the <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.</p></li>
</ul>
<p>If the <em>AmbiguousName</em> is a qualified name, consisting of a name, a &quot;<code>.</code>&quot;, and an <em>Identifier</em>, then the name to the left of the &quot;<code>.</code>&quot; is first reclassified, for it is itself an <em>AmbiguousName</em>. There is then a choice:</p>
<ul>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as a <em>PackageName</em>, then:</p>
<ul>
<li><p>If the <em>Identifier</em> is a valid <em>TypeIdentifier</em>, and there is a package whose name is the name to the left of the &quot;<code>.</code>&quot;, and that package contains a declaration of a type whose name is the same as the <em>Identifier</em>, then this <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, this <em>AmbiguousName</em> is reclassified as a <em>PackageName</em>. A later step determines whether or not a package of that name actually exists.</p></li>
</ul></li>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as a <em>TypeName</em>, then:</p>
<ul>
<li><p>If the <em>Identifier</em> is the name of a method or field of the type denoted by <em>TypeName</em>, then this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>.</p></li>
<li><p>Otherwise, if the <em>Identifier</em> is a valid <em>TypeIdentifier</em> and is the name of a member type of the type denoted by <em>TypeName</em>, then this <em>AmbiguousName</em> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul></li>
<li><p>If the name to the left of the &quot;<code>.</code>&quot; is reclassified as an <em>ExpressionName</em>, then this <em>AmbiguousName</em> is reclassified as an <em>ExpressionName</em>. A later step determines whether or not a member with the name <em>Identifier</em> actually exists.</p></li>
</ul>
<blockquote>
<p>The requirement that a potential type name be &quot;a valid <em>TypeIdentifier</em>&quot; prevents treating <code>var</code> <strong>and <code>yield</code></strong> as a type name. It is usually redundant, because the rules for declarations already prevent the introduction of types named <code>var</code> <strong>and <code>yield</code></strong>. However, in some cases, a compiler may find a binary class named <code>var</code> <strong>or <code>yield</code></strong>, and we want to be clear that such classes can never be named. The simplest solution is to consistently check for a valid <em>TypeIdentifier</em>.</p>
</blockquote>
<div class="example">
<p>Example 6.5.2-1. Reclassification of Contextually Ambiguous Names</p>
<p>Consider the following contrived &quot;library code&quot;:</p>
<pre><code>package org.rpgpoet;
import java.util.Random;
public interface Music { Random[] wizards = new Random[4]; }</code></pre>
<p>and then consider this example code in another package:</p>
<pre><code>package bazola;
class Gabriel {
    static int n = org.rpgpoet.Music.wizards.length;
}</code></pre>
<p>First of all, the name <code>org.rpgpoet.Music.wizards.length</code> is classified as an <em>ExpressionName</em> because it functions as a <em>PostfixExpression</em>. Therefore, each of the names:</p>
<pre><code>org.rpgpoet.Music.wizards
org.rpgpoet.Music
org.rpgpoet
org</code></pre>
<p>is initially classified as an <em>AmbiguousName</em>. These are then reclassified:</p>
<ul>
<li><p>The simple name <code>org</code> is reclassified as a <em>PackageName</em> (since there is no variable or type named org in scope).</p></li>
<li><p>Next, assuming that there is no class or interface named <code>rpgpoet</code> in any compilation unit of package <code>org</code> (and we know that there is no such class or interface because package <code>org</code> has a subpackage named <code>rpgpoet</code>), the qualified name <code>org.rpgpoet</code> is reclassified as a <em>PackageName</em>.</p></li>
<li><p>Next, because package <code>org.rpgpoet</code> has an accessible (<a href="../../se11/html/jls-6.html#jls-6.6">6.6</a>) interface type named <code>Music</code>, the qualified name <code>org.rpgpoet.Music</code> is reclassified as a <em>TypeName</em>.</p></li>
<li><p>Finally, because the name <code>org.rpgpoet.Music</code> is a <em>TypeName</em>, the qualified name <code>org.rpgpoet.Music.wizards</code> is reclassified as an <em>ExpressionName</em>.</p></li>
</ul>
</div>
<h2 id="jep354-11">Chapter 11: Exceptions</h2>
<h3 id="jep354-11.2">11.2 Compile-Time Checking of Exceptions</h3>
<h4 id="jep354-11.2.1">11.2.1 Exception Analysis of Expressions</h4>
<p>A class instance creation expression (<a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>) can throw an exception class <em>E</em> iff either:</p>
<ul>
<li><p>The expression is a qualified class instance creation expression and the qualifying expression can throw <em>E</em>; or</p></li>
<li><p>Some expression of the argument list can throw <em>E</em>; or</p></li>
<li><p><em>E</em> is one of the exception types of the invocation type of the chosen constructor (<a href="../../se11/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>); or</p></li>
<li><p>The class instance creation expression includes a <em>ClassBody</em>, and some instance initializer or instance variable initializer in the <em>ClassBody</em> can throw <em>E</em>.</p></li>
</ul>
<p>A method invocation expression (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) can throw an exception class <em>E</em> iff either:</p>
<ul>
<li><p>The method invocation expression is of the form <em>Primary</em> <code>.</code> <em>[TypeArguments]</em> <em>Identifier</em> and the <em>Primary</em> expression can throw <em>E</em>; or</p></li>
<li><p>Some expression of the argument list can throw <em>E</em>; or</p></li>
<li><p><em>E</em> is one of the exception types of the invocation type of the chosen method (<a href="../../se11/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
</ul>
<p><strong>A <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) can throw an exception class <em>E</em> iff either:</strong></p>
<ul>
<li><p><strong>The selector expression can throw <em>E</em>; or</strong></p></li>
<li><p><strong>Some switch labeled expression, switch labeled block, switch labeled throw statement, or statement group in the switch block can throw <em>E</em>.</strong></p></li>
</ul>
<p>A lambda expression (<a href="../../se11/html/jls-15.html#jls-15.27">15.27</a>) can throw no exception classes.</p>
<p>For every other kind of expression, the expression can throw an exception class <em>E</em> iff one of its immediate subexpressions can throw <em>E</em>.</p>
<blockquote>
<p>Note that a method reference expression (<a href="../../se11/html/jls-15.html#jls-15.13">15.13</a>) of the form <em>Primary <code>::</code> [TypeArguments] Identifier</em> can throw an exception class if the <em>Primary</em> subexpression can throw an exception class. In contrast, a lambda expression can throw nothing, and has no immediate subexpressions on which to perform exception analysis. It is the <em>body</em> of a lambda expression, containing expressions and statements, that can throw exception classes.</p>
</blockquote>
<h4 id="jep354-11.2.2">11.2.2 Exception Analysis of Statements</h4>
<p>A <code>throw</code> statement (<a href="../../se11/html/jls-14.html#jls-14.18">14.18</a>) whose thrown expression has static type <em>E</em> and is not a final or effectively final exception parameter can throw <em>E</em> or any exception class that the thrown expression can throw.</p>
<blockquote>
<p>For example, the statement <code>throw new java.io.FileNotFoundException();</code> can throw <code>java.io.FileNotFoundException</code> only. Formally, it is not the case that it &quot;can throw&quot; a subclass or superclass of <code>java.io.FileNotFoundException</code>.</p>
</blockquote>
<p>A <code>throw</code> statement whose thrown expression is a final or effectively final exception parameter of a <code>catch</code> clause <em>C</em> can throw an exception class <em>E</em> iff:</p>
<ul>
<li><p><em>E</em> is an exception class that the <code>try</code> block of the <code>try</code> statement which declares <em>C</em> can throw; and</p></li>
<li><p><em>E</em> is assignment compatible with any of <em>C</em>'s catchable exception classes; and</p></li>
<li><p><em>E</em> is not assignment compatible with any of the catchable exception classes of the <code>catch</code> clauses declared to the left of <em>C</em> in the same <code>try</code> statement.</p></li>
</ul>
<p>A <code>try</code> statement (<a href="../../se11/html/jls-14.html#jls-14.20">14.20</a>) can throw an exception class <em>E</em> iff either:</p>
<ul>
<li><p>The <code>try</code> block can throw <em>E</em>, or an expression used to initialize a resource (in a <code>try</code>-with-resources statement) can throw <em>E</em>, or the automatic invocation of the <code>close()</code> method of a resource (in a <code>try</code>-with-resources statement) can throw <em>E</em>, and <em>E</em> is not assignment compatible with any catchable exception class of any <code>catch</code> clause of the <code>try</code> statement, and either no <code>finally</code> block is present or the <code>finally</code> block can complete normally; or</p></li>
<li><p>Some <code>catch</code> block of the <code>try</code> statement can throw <em>E</em> and either no <code>finally</code> block is present or the <code>finally</code> block can complete normally; or</p></li>
<li><p>A <code>finally</code> block is present and can throw <em>E</em>.</p></li>
</ul>
<p>An explicit constructor invocation statement (<a href="../../se11/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>) can throw an exception class <em>E</em> iff either:</p>
<ul>
<li><p>Some expression of the constructor invocation's parameter list can throw <em>E</em>; or</p></li>
<li><p><em>E</em> is determined to be an exception class of the <code>throws</code> clause of the constructor that is invoked (<a href="../../se11/html/jls-15.html#jls-15.12.2.6">15.12.2.6</a>).</p></li>
</ul>
<p><strong>A <code>switch</code> statement (<a href="switch-expressions.html#jep354-14.11">14.11</a>) can throw an exception class <em>E</em> iff either:</strong></p>
<ul>
<li><p><strong>The selector expression can throw <em>E</em>; or</strong></p></li>
<li><p><strong>Some switch labeled expression, switch labeled block, switch labeled throw statement, or statement group in the switch block can throw <em>E</em>.</strong></p></li>
</ul>
<p>Any other statement <em>S</em> can throw an exception class <em>E</em> iff an expression or statement immediately contained in <em>S</em> can throw <em>E</em>.</p>
<h2 id="jep354-14">Chapter 14: Blocks and Statements</h2>
<h3 id="jep354-14.1">14.1 Normal and Abrupt Completion of Statements</h3>
<p>Every statement has a normal mode of execution in which certain computational steps are carried out. The following sections describe the normal mode of execution for each kind of statement.</p>
<p>If all the steps are carried out as described, with no indication of abrupt completion, the statement is said to <em>complete normally</em>. However, certain events may prevent a statement from completing normally:</p>
<ul>
<li><p>The <code>break</code> (<a href="switch-expressions.html#jep354-14.15">14.15</a>), <strong><code>yield</code> (<a href="switch-expressions.html#jep354-14.21">14.21</a>),</strong> <code>continue</code> (<a href="switch-expressions.html#jep354-14.16">14.16</a>), and <code>return</code> (<a href="switch-expressions.html#jep354-14.17">14.17</a>) statements cause a transfer of control that may prevent normal completion of <strong>expressions,</strong> statements<strong>, and blocks</strong> that <strong>may</strong> contain them.</p></li>
<li><p>Evaluation of certain expressions may throw exceptions from the Java Virtual Machine (<a href="switch-expressions.html#jep354-15.6">15.6</a>). An explicit <code>throw</code> (<a href="../../se11/html/jls-14.html#jls-14.18">14.18</a>) statement also results in an exception. An exception causes a transfer of control that may prevent normal completion of statements.</p></li>
</ul>
<p>If such an event occurs, then execution of one or more statements may be terminated before all steps of their normal mode of execution have completed; such statements are said to <em>complete abruptly</em>.</p>
<p>An abrupt completion always has an associated <em>reason</em>, which is one of the following:</p>
<ul>
<li><p>A <code>break</code> with no label</p></li>
<li><p>A <code>break</code> with a given label</p></li>
<li><p><strong>A <code>yield</code> with a given value</strong></p></li>
<li><p>A <code>continue</code> with no label</p></li>
<li><p>A <code>continue</code> with a given label</p></li>
<li><p>A <code>return</code> with no value</p></li>
<li><p>A <code>return</code> with a given value</p></li>
<li><p>A <code>throw</code> with a given value, including exceptions thrown by the Java Virtual Machine</p></li>
</ul>
<p>The terms &quot;complete normally&quot; and &quot;complete abruptly&quot; also apply to the evaluation of expressions (<a href="switch-expressions.html#jep354-15.6">15.6</a>). The only reason an expression can complete abruptly is that an exception is thrown, because of either a <code>throw</code> with a given value (<a href="../../se11/html/jls-14.html#jls-14.18">14.18</a>) or a run-time exception or error (<a href="../../se11/html/jls-11.html">Chapter 11 (Exceptions)</a>, <a href="switch-expressions.html#jep354-15.6">15.6</a>).</p>
<p>If a statement evaluates an expression, abrupt completion of the expression always causes the immediate abrupt completion of the statement, with the same reason. All succeeding steps in the normal mode of execution are not performed.</p>
<p>Unless otherwise specified in this chapter, abrupt completion of a substatement causes the immediate abrupt completion of the statement itself, with the same reason, and all succeeding steps in the normal mode of execution of the statement are not performed.</p>
<p>Unless otherwise specified, a statement completes normally if all expressions it evaluates and all substatements it executes complete normally.</p>
<!--
:::inserted
 

|              | yield |  break |  break with label  |  continue  | return  |
| :--------    | :-------:  | :----: | :-------: | :--------: |  -----: |
| method       |   X        |   X    |   X       |  X         |   H     |
| lambda       |   X        |   X    |   X       |  X         |   H     |
| block        |   P        |   P    |   P       |  P         |   P     |
| for/while/do |   P        |   H    |   P       |  H         |   P     |
| switch-s     |   P        |   H    |   P       |  P         |   P     |
| switch-e     |   H        |   X    |   X       |  X         |   X     |
-->
<p>:::</p>
<h3 id="jep-14.5">14.5 Statements</h3>
<p>There are many kinds of statements in the Java programming language. Most correspond to statements in the C and C++ languages, but some are unique.</p>
<p>As in C and C++, the <code>if</code> statement of the Java programming language suffers from the so-called &quot;dangling <code>else</code> problem,&quot; illustrated by this misleadingly formatted example:</p>
<pre><code>if (door.isOpen())
    if (resident.isVisible())
        resident.greet(&quot;Hello!&quot;);
else door.bell.ring();  // A &quot;dangling else&quot;</code></pre>
<p>The problem is that both the outer <code>if</code> statement and the inner <code>if</code> statement might conceivably own the <code>else</code> clause. In this example, one might surmise that the programmer intended the <code>else</code> clause to belong to the outer <code>if</code> statement.</p>
<p>The Java programming language, like C and C++ and many programming languages before them, arbitrarily decrees that an <code>else</code> clause belongs to the innermost <code>if</code> to which it might possibly belong. This rule is captured by the following grammar:</p>
<dl>
<dt><em>Statement:</em></dt>
<dd><em>StatementWithoutTrailingSubstatement</em>
</dd>
<dd><em>LabeledStatement</em>
</dd>
<dd><em>IfThenStatement</em>
</dd>
<dd><em>IfThenElseStatement</em>
</dd>
<dd><em>WhileStatement</em>
</dd>
<dd><em>ForStatement</em>
</dd>
<dt><em>StatementNoShortIf:</em></dt>
<dd><em>StatementWithoutTrailingSubstatement</em>
</dd>
<dd><em>LabeledStatementNoShortIf</em>
</dd>
<dd><em>IfThenElseStatementNoShortIf</em>
</dd>
<dd><em>WhileStatementNoShortIf</em>
</dd>
<dd><em>ForStatementNoShortIf</em>
</dd>
<dt><em>StatementWithoutTrailingSubstatement:</em></dt>
<dd><em>Block</em>
</dd>
<dd><em>EmptyStatement</em>
</dd>
<dd><em>ExpressionStatement</em>
</dd>
<dd><em>AssertStatement</em>
</dd>
<dd><em>SwitchStatement</em>
</dd>
<dd><em>DoStatement</em>
</dd>
<dd><em>BreakStatement</em>
</dd>
<dd><em>ContinueStatement</em>
</dd>
<dd><em>ReturnStatement</em>
</dd>
<dd><em>SynchronizedStatement</em>
</dd>
<dd><em>ThrowStatement</em>
</dd>
<dd><em>TryStatement</em>
</dd>
<dd><strong><em>YieldStatement</em></strong>
</dd>
</dl>
<blockquote>
<p>The following productions from [14.9] are shown here for convenience:</p>
</blockquote>
<blockquote>
<dl>
<dt><em>IfThenStatement:</em></dt>
<dd><code>if</code> <code>(</code> <em>Expression</em> <code>)</code> <em>Statement</em>
</dd>
<dt><em>IfThenElseStatement:</em></dt>
<dd><code>if</code> <code>(</code> <em>Expression</em> <code>)</code> <em>StatementNoShortIf</em> <code>else</code> <em>Statement</em>
</dd>
<dt><em>IfThenElseStatementNoShortIf:</em></dt>
<dd><code>if</code> <code>(</code> <em>Expression</em> <code>)</code> <em>StatementNoShortIf</em> <code>else</code> <em>StatementNoShortIf</em>
</dd>
</dl>
</blockquote>
<p>Statements are thus grammatically divided into two categories: those that might end in an <code>if</code> statement that has no <code>else</code> clause (a &quot;short <code>if</code> statement&quot;) and those that definitely do not.</p>
<p>Only statements that definitely do not end in a short <code>if</code> statement may appear as an immediate substatement before the keyword <code>else</code> in an <code>if</code> statement that does have an <code>else</code> clause.</p>
<p>This simple rule prevents the &quot;dangling <code>else</code>&quot; problem. The execution behavior of a statement with the &quot;no short <code>if</code>&quot; restriction is identical to the execution behavior of the same kind of statement without the &quot;no short <code>if</code>&quot; restriction; the distinction is drawn purely to resolve the syntactic difficulty.</p>
<h3 id="jep354-14.11">14.11 The <code>switch</code> Statement</h3>
<div class="editorial">
<p>Much of this section has been moved into subsections.</p>
</div>
<p>The <code>switch</code> statement transfers control to one of several statements depending on the value of an expression. <strong>This expression is known as the <em>selector expression</em>.</strong></p>
<dl>
<dt><em>SwitchStatement:</em></dt>
<dd><code>switch</code> <code>(</code> <em>Expression</em> <code>)</code> <em>SwitchBlock</em>
</dd>
</dl>
<div class="deleted">
<dl>
<dt><em>SwitchBlock:</em></dt>
<dd><code>{</code> {<em>SwitchBlockStatementGroup</em>} {<em>SwitchLabel</em>} <code>}</code>
</dd>
<dt><em>SwitchBlockStatementGroup:</em></dt>
<dd><em>SwitchLabels</em> <em>BlockStatements</em>
</dd>
<dt><em>SwitchLabels:</em></dt>
<dd><em>SwitchLabel</em> {<em>SwitchLabel</em>}
</dd>
<dt><em>SwitchLabel:</em></dt>
<dd><code>case</code> <em>ConstantExpression</em> <code>:</code>
</dd>
<dd><code>case</code> <em>EnumConstantName</em> <code>:</code>
</dd>
<dd><code>default</code> <code>:</code>
</dd>
<dt><em>EnumConstantName:</em></dt>
<dd><em>Identifier</em>
</dd>
</dl>
</div>
<p>The type of the <em>Expression</em> must be <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>Character</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>String</code>, or an enum type (<a href="../../se11/html/jls-8.html#jls-8.9">8.9</a>), or a compile-time error occurs.</p>
<h4 id="jep354-14.11.1"><strong>14.11.1 The Switch Block</strong></h4>
<div class="inserted">
<dl>
<dt><em>SwitchBlock:</em></dt>
<dd><code>{</code> <em>SwitchLabeledRule</em> {<em>SwitchLabeledRule</em>} <code>}</code>
</dd>
<dd><code>{</code> {<em>SwitchLabeledStatementGroup</em>} {<em>SwitchLabel</em> <code>:</code>} <code>}</code>
</dd>
<dt><em>SwitchLabeledRule:</em></dt>
<dd><em>SwitchLabeledExpression</em>
</dd>
<dd><em>SwitchLabeledBlock</em>
</dd>
<dd><em>SwitchLabeledThrowStatement</em>
</dd>
<dt><em>SwitchLabeledExpression:</em></dt>
<dd><em>SwitchLabel</em> <code>-&gt;</code> <em>Expression</em> <code>;</code>
</dd>
<dt><em>SwitchLabeledBlock:</em></dt>
<dd><em>SwitchLabel</em> <code>-&gt;</code> <em>Block</em>
</dd>
<dt><em>SwitchLabeledThrowStatement:</em></dt>
<dd><em>SwitchLabel</em> <code>-&gt;</code> <em>ThrowStatement</em>
</dd>
<dt><em>SwitchLabel:</em></dt>
<dd><code>case</code> <em>CaseConstant</em> {<code>,</code> <em>CaseConstant</em>}
</dd>
<dd><code>default</code>
</dd>
<dt><em>CaseConstant:</em></dt>
<dd><em>ConditionalExpression</em>
</dd>
<dt><em>SwitchLabeledStatementGroup:</em></dt>
<dd><em>SwitchLabel</em> <code>:</code> {<em>SwitchLabel</em> <code>:</code>} <em>BlockStatements</em>
</dd>
</dl>
</div>
<p>The body of <strong>both</strong> a <code>switch</code> statement <strong>and a <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>)</strong> is known as a <em>switch block</em>. <strong>This block can consist of either:</strong></p>
<ol type="1">
<li><p><strong><em>Switch labeled rules</em>, which use <code>-&gt;</code> to introduce either a <em>switch labeled expression</em>, <em>switch labeled block</em>, or a <em>switch labeled throw statement</em>; or</strong></p></li>
<li><p><strong><em>Switch labeled statement groups</em>, which use <code>:</code> to introduce <em>switch labeled block statements</em>.</strong></p></li>
</ol>
<p><del>Any statement immediately contained by the switch block may be labeled with one or more <em>switch labels</em>, which are <code>case</code> or <code>default</code> labels.</del> <strong>A switch labeled rule has a <em>switch label</em> and either an expression, block, or <code>throw</code> statement. A switch labeled statement group has one or more switch labels and zero or more block statements. A switch label is either a <code>case</code> or <code>default</code> label.</strong> Every <code>case</code> label has <del>a</del> <strong>one or more</strong> <code>case</code> constant<strong>s, each of</strong> which is either a constant expression or the name of an enum constant. Switch labels and their <code>case</code> constants are said to be <em>associated</em> with the <code>switch</code> <del>statement</del> <strong>block</strong>.</p>
<p><strong>Every <code>case</code> constant associated with a given switch block must be either a constant expression (<a href="switch-expressions.html#jep354-15.29">15.29</a>) or the name of an enum constant ([8.9.1]), or a compile-time error occurs.</strong></p>
<blockquote>
<p><strong>This excludes the possibility of using <code>null</code> as a <code>case</code> constant.</strong></p>
</blockquote>
<div class="deleted">
<p>Given a <code>switch</code> statement, all of the following must be true or a compile-time error occurs:</p>
<ul>
<li><p>Every <code>case</code> constant associated with the <code>switch</code> statement must be assignment compatible with the type of the <code>switch</code> statement's <em>Expression</em> (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>).</p></li>
<li><p>If the type of the <code>switch</code> statement's <em>Expression</em> is an enum type, then every <code>case</code> constant associated with the <code>switch</code> statement must be an enum constant of that type.</p></li>
<li><p>No two of the <code>case</code> constants associated with the <code>switch</code> statement have the same value.</p></li>
<li><p>No <code>case</code> constant associated with the <code>switch</code> statement is <code>null</code>.</p></li>
<li><p>At most one <code>default</code> label is associated with the <code>switch</code> statement.</p></li>
</ul>
</div>
<div class="inserted">
<p>A switch block is said to be <em>compatible</em> with the type of the selector expression, <em>T</em>, if both of the following are true:</p>
<ul>
<li><p>If <em>T</em> is not an enum type, then every <code>case</code> constant associated with the switch block is assignment compatible with <em>T</em> (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>).</p></li>
<li><p>If <em>T</em> is an enum type, then every <code>case</code> constant associated with the switch block is an enum constant of type <em>T</em>.</p></li>
</ul>
<p>At run time, the value of the selector expression is compared with each <code>case</code> constant (if the selector expression is a reference type that is convertible to a numeric type, then it is first subject to an unboxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>)):</p>
<ul>
<li><p>If one of the <code>case</code> constants is equal to the value of the selector expression, then we say that the <code>case</code> label <em>matches</em>. Equality is defined in terms of the <code>==</code> operator (<a href="../../se11/html/jls-15.html#jls-15.21">15.21</a>) unless the value of the selector expression is a <code>String</code>, in which case equality is defined in terms of the <code>equals</code> method of class <code>String</code>.</p></li>
<li><p>If no <code>case</code> label matches but there is a <code>default</code> label, then we say that the <code>default</code> label <em>matches</em>.</p></li>
</ul>
<blockquote>
<p>A <code>case</code> label can contain several <code>case</code> constants, and matches the value of a selector expression if any one of its <code>case</code> constants matches.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">switch</span> (day) {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="kw">case</span> SATURDAY, SUNDAY:</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">        <span class="co">// matches if it is a Saturday OR a Sunday</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;It&#39;s the weekend!&quot;</span>);</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">}</a></code></pre></div>
</blockquote>
</div>
<blockquote>
<p>The prohibition against using <code>null</code> as a <code>case</code> constant prevents code being written that can never be executed. If the <del><code>switch</code> statement's <em>Expression</em></del> <strong>selector expression</strong> is of a reference type, that is, <code>String</code> or a boxed primitive type or an enum type, then an exception <del>will be thrown</del> will occur if the <em>Expression</em> evaluates to <code>null</code> at run time. In the judgment of the designers of the Java programming language, this is a better outcome than <del>silently skipping the entire <code>switch</code> statement or choosing to execute the statements (if any) after the <code>default</code> label (if any)</del> <strong>either the switch block not matching or even the <code>default</code> label matching</strong>.</p>
</blockquote>
<blockquote>
<p><del>A Java compiler is encouraged (but not required) to provide a warning if a <code>switch</code> on an enum-valued expression lacks a <code>default</code> label and lacks <code>case</code> labels for one or more of the enum's constants. Such a <code>switch</code> will silently do nothing if the expression evaluates to one of the missing constants.</del></p>
</blockquote>
<blockquote>
<p>In C and C++ the body of a <code>switch</code> statement can be a statement and statements with <code>case</code> <del>labels</del> <strong>heads</strong> do not have to be immediately contained by that statement. Consider the simple loop:</p>
<pre><code>for (i = 0; i &lt; n; ++i) foo();</code></pre>
<p>where <code>n</code> is known to be positive. A trick known as <em>Duff's device</em> can be used in C or C++ to unroll the loop, but this is not valid code in the Java programming language:</p>
<pre><code>int q = (n+7)/8;
switch (n%8) {
    case 0: do { foo();    // Great C hack, Tom,
    case 7:      foo();    // but it&#39;s not valid here.
    case 6:      foo();
    case 5:      foo();
    case 4:      foo();
    case 3:      foo();
    case 2:      foo();
    case 1:      foo();
            } while (--q &gt; 0);
}</code></pre>
<p>Fortunately, this trick does not seem to be widely known or used. Moreover, it is less needed nowadays; this sort of code transformation is properly in the province of state-of-the-art optimizing compilers.</p>
</blockquote>
<h4 id="jep354-14.11.2"><strong>14.11.2 The <code>switch</code> Block of a <code>switch</code> Statement</strong></h4>
<div class="inserted">
<p>Given a <code>switch</code> statement, all of the following must be true or a compile-time error occurs:</p>
<ul>
<li><p>The switch block must be compatible with the type of the selector expression.</p></li>
<li><p>No two of the <code>case</code> constants associated with the switch block may have the same value.</p></li>
<li><p>At most one <code>default</code> label is associated with the switch block.</p></li>
<li><p>All switch labeled expressions in the switch block must be statement expressions (<a href="../../se11/html/jls-14.html#jls-14.8">14.8</a>).</p></li>
</ul>
<blockquote>
<p>Switch labeled rules in <code>switch</code> statements differ from those in <code>switch</code> expressions (<a href="switch-expressions.html#jep354-15.28">15.28</a>). In <code>switch</code> statements they must be switch labeled <em>statement</em> expressions, whereas in <code>switch</code> expressions they may be any switch labeled expression (<a href="switch-expressions.html#jep354-15.28.1">15.28.1</a>).</p>
</blockquote>
</div>
<h4 id="jep354-14.11.3"><strong>14.11.3 Execution of a <code>switch</code> statement</strong></h4>
<div class="deleted">
<p>A <code>switch</code> statement is executed by first evaluating the <em>Expression</em>. If the <em>Expression</em> evaluates to <code>null</code>, a <code>NullPointerException</code> is thrown and the entire <code>switch</code> statement completes abruptly for that reason. Otherwise, if the result is of type <code>Character</code>, <code>Byte</code>, <code>Short</code>, or <code>Integer</code>, it is subject to unboxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p>
<p>If evaluation of the <em>Expression</em> or the subsequent unboxing conversion (if any) completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason.</p>
<p>Otherwise, execution continues by comparing the value of the <em>Expression</em> with each <code>case</code> constant, and there is a choice:</p>
<ul>
<li><p>If one of the <code>case</code> constants is equal to the value of the expression, then we say that the <code>case</code> label <em>matches</em>. Equality is defined in terms of the <code>==</code> operator (<a href="../../se11/html/jls-15.html#jls-15.21">15.21</a>) unless the value of the expression is a <code>String</code>, in which case equality is defined in terms of the <code>equals</code> method of class <code>String</code>.</p>
<p>All statements after the matching <code>case</code> label in the <code>switch</code> block, if any, are executed in sequence.</p>
<p>If all these statements complete normally, or if there are no statements after the matching <code>case</code> label, then the entire <code>switch</code> statement completes normally.</p></li>
<li><p>If no <code>case</code> label matches but there is a <code>default</code> label, then all statements after the <code>default</code> label in the <code>switch</code> block, if any, are executed in sequence.</p>
<p>If all these statements complete normally, or if there are no statements after the <code>default</code> label, then the entire <code>switch</code> statement completes normally.</p></li>
<li><p>If no <code>case</code> label matches and there is no <code>default</code> label, then no further action is taken and the <code>switch</code> statement completes normally.</p></li>
</ul>
</div>
<div class="inserted">
<p>When the <code>switch</code> statement is executed, first the selector expression is evaluated:</p>
<ol type="1">
<li><p>If evaluation of the selector expression completes abruptly for some reason, the <code>switch</code> statement completes abruptly for the same reason.</p></li>
<li><p>If the selector expression evaluates to <code>null</code>, then a <code>NullPointerException</code> is thrown and the entire <code>switch</code> statement completes abruptly for that reason.</p></li>
<li><p>Otherwise, execution continues by determining if a switch label associated with the switch block matches the value of the selector expression:</p>
<p>If no switch label matches, then the entire <code>switch</code> statement completes normally.</p>
<p>If a switch label matches, then one of the following applies:</p>
<ul>
<li><p>If it is the switch label for a statement expression, then the statement expression is evaluated. If the result of evaluation is a value, it is discarded. If the evaluation completes normally, then the <code>switch</code> statement completes normally.</p></li>
<li><p>If it is the switch label for a block, then the block is executed. If this block completes normally, then the <code>switch</code> statement completes normally.</p></li>
<li><p>If it is the switch label for a <code>throw</code> statement, then the <code>throw</code> statement is executed.</p></li>
<li><p>If it is the switch label for a statement group, then all the statements in the switch block that follow it are executed in order. If these statements complete normally, then the <code>switch</code> statement completes normally.</p></li>
<li><p>Otherwise, there are no statements that follow it in the switch block, and the <code>switch</code> statement completes normally.</p></li>
</ul></li>
</ol>
</div>
<p>If <del>any statement immediately contained by the <em>Block</em> body of the <code>switch</code> statement</del> <strong>execution of any statement or expression</strong> completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If execution of <del>the <em>Statement</em></del> <strong>a statement</strong> completes abruptly because of a <code>break</code> with no label, no further action is taken and the <code>switch</code> statement completes normally.</p></li>
<li><p>If execution of <del>the <em>Statement</em></del> <strong>a statement or expression</strong> completes abruptly for any other reason, the <code>switch</code> statement completes abruptly for the same reason.</p></li>
</ul>
<!-- SwitchExpressions1 Spec. Removed for SwitchExpressions2 and replaced with following.
    > **The case of abrupt completion because of a `yield` statement is
    > prohibited by ([14.15]).**
-->
<blockquote>
<p><strong>The case of abrupt completion because of a <code>yield</code> statement is handled by the general rule for <code>switch</code> expressions (<a href="switch-expressions.html#jep354-15.28">15.28</a>).</strong></p>
</blockquote>
<blockquote>
<p>The case of abrupt completion because of a <code>break</code> with a label is handled by the general rule for labeled statements (<a href="../../se11/html/jls-14.html#jls-14.7">14.7</a>).</p>
</blockquote>
<div class="example">
<p>Example <del>14.11-1</del> <strong>14.11.3-1</strong>. Fall-Through in the <code>switch</code> Statement</p>
<p><del>As in C and C++, execution of statements in a <code>switch</code> block &quot;falls through labels.&quot;</del></p>
<p><strong>When a selector expression matches a switch label for a switch labeled rule, the labeled expression or statement is executed and nothing else. In the case of a switch label for a statement group, <em>all</em> the block statements in the switch block that follow the switch label are executed, including those that appear after subsequent switch labels. The effect is that, as in C and C++, execution of statements can &quot;fall through labels.&quot;</strong></p>
<p>For example, the program:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">class</span> TooMany {</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howMany</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">            <span class="kw">case</span> <span class="dv">1</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="st">&quot;one &quot;</span>);</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">            <span class="kw">case</span> <span class="dv">2</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">print</span>(<span class="st">&quot;too &quot;</span>);</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">            <span class="kw">case</span> <span class="dv">3</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">        <span class="fu">howMany</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">        <span class="fu">howMany</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">        <span class="fu">howMany</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">}</a></code></pre></div>
<p>contains a <code>switch</code> block in which the code for each <code>case</code> falls through into the code for the next <code>case</code>. As a result, the program prints:</p>
<pre><code>many
too many
one too many</code></pre>
<p><strong>This fall through behaviour can be the cause of subtle bugs.</strong> If code is not to fall through <code>case</code> to <code>case</code> in this manner, <del>then <code>break</code> statements should be used, as in this example</del> <strong>switch labeled rules can be used, or <code>break</code> statements can be used to explicitly indicate where control should be transfered, as follows</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java deleted"><code class="sourceCode java"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">class</span> TwoMany {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howMany</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">            <span class="kw">case</span> <span class="dv">1</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;one&quot;</span>);</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">            <span class="kw">case</span> <span class="dv">2</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;two&quot;</span>);</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">            <span class="kw">case</span> <span class="dv">3</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">                    <span class="kw">break</span>;  <span class="co">// not needed, but good style</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">        }</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">        <span class="fu">howMany</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">        <span class="fu">howMany</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">        <span class="fu">howMany</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb16-16" data-line-number="16">    }</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">}</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode java inserted"><code class="sourceCode java"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">class</span> TwoMany {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howManyRule</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">            <span class="kw">case</span> <span class="dv">1</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;one&quot;</span>);</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">            <span class="kw">case</span> <span class="dv">2</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;two&quot;</span>);</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">            <span class="kw">case</span> <span class="dv">3</span> -&gt; <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">    <span class="dt">static</span> <span class="dt">void</span> <span class="fu">howManyGroup</span>(<span class="dt">int</span> k) {</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">        <span class="kw">switch</span> (k) {</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">            <span class="kw">case</span> <span class="dv">1</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;one&quot;</span>);</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">            <span class="kw">case</span> <span class="dv">2</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;two&quot;</span>);</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">                    <span class="kw">break</span>;  <span class="co">// exit the switch</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">            <span class="kw">case</span> <span class="dv">3</span>: <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;many&quot;</span>);</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">                    <span class="kw">break</span>;  <span class="co">// not needed, but good style</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">        }</a>
<a class="sourceLine" id="cb17-18" data-line-number="18">    }</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span> args) {</a>
<a class="sourceLine" id="cb17-20" data-line-number="20">        <span class="fu">howManyRule</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">        <span class="fu">howManyRule</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb17-22" data-line-number="22">        <span class="fu">howManyRule</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb17-23" data-line-number="23">        <span class="fu">howManyGroup</span>(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb17-24" data-line-number="24">        <span class="fu">howManyGroup</span>(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb17-25" data-line-number="25">        <span class="fu">howManyGroup</span>(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb17-26" data-line-number="26">    }</a>
<a class="sourceLine" id="cb17-27" data-line-number="27">}</a></code></pre></div>
<p>This program prints:</p>
<div class="deleted">
<pre><code>one
two
many</code></pre>
</div>
<div class="inserted">
<pre><code>one
two
many
one
two
many</code></pre>
</div>
</div>
<h3 id="jep354-14.15">14.15 The <code>break</code> Statement</h3>
<p>A <code>break</code> statement transfers control out of an enclosing statement.</p>
<dl>
<dt><em>BreakStatement:</em></dt>
<dd><del><code>break</code> [ <em>Identifier</em> ] <code>;</code></del>
</dd>
<dd><strong><code>break</code> <em>Identifier</em> <code>;</code></strong>
</dd>
<dd><strong><code>break</code> <code>;</code></strong>
</dd>
</dl>
<p><strong>There are two kinds of <code>break</code> statement:</strong></p>
<ol type="1">
<li><p><strong>A <code>break</code> statement with label <em>Identifier</em>.</strong></p></li>
<li><p><strong>A <code>break</code> statement with no label.</strong></p></li>
</ol>
<p>A <code>break</code> statement with no label attempts to transfer control to the innermost enclosing <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement <del>of the immediately enclosing method or initializer</del>; this statement, which is called the <em>break target</em>, then immediately completes normally.</p>
<p><del>To be precise, a <code>break</code> statement with no label always completes abruptly, the reason being a <code>break</code> with no label.</del></p>
<p><del>If no <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement in the immediately enclosing method, constructor, or initializer contains the <code>break</code> statement, a compile-time error occurs.</del></p>
<p>A <code>break</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se11/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; this statement, which is called the <em>break target</em>, then immediately completes normally. <del>In this case, the break target need not be a <code>switch</code>, <code>while</code>, <code>do</code>, or <code>for</code> statement.</del></p>
<p><del>To be precise, a <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>break</code> with label <em>Identifier</em>.</del></p>
<p><del>A <code>break</code> statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body. There are no non-local jumps. If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, initializer, or lambda body contains the <code>break</code> statement, a compile-time error occurs.</del></p>
<p><strong>It is a compile-time error if a <code>break</code> statement has no break target.</strong></p>
<p><strong>It is a compile-time error if the break target of a <code>break</code> statement contains any method, constructor, initializer, lambda expression, or <code>switch</code> expression that encloses the <code>break</code> statement.</strong></p>
<p><strong>Execution of an <code>break</code> statement with no label always completes abruptly, the reason being a break with no label.</strong></p>
<p><strong>Execution of a <code>break</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a break with label <em>Identifier</em>.</strong></p>
<blockquote>
<p>It can be seen, then, that a <code>break</code> statement always completes abruptly.</p>
</blockquote>
<blockquote>
<p>The preceding descriptions say &quot;attempts to transfer control&quot; rather than just &quot;transfers control&quot; because if there are any <code>try</code> statements (<a href="../../se11/html/jls-14.html#jls-14.20">14.20</a>) within the break target whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>break</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the break target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>break</code> statement.</p>
</blockquote>
<div class="example">
<p>Example 14.15-1. The <code>break</code> Statement</p>
<p>In the following example, a mathematical graph is represented by an array of arrays. A graph consists of a set of nodes and a set of edges; each edge is an arrow that points from some node to some other node, or from a node to itself. In this example it is assumed that there are no redundant edges; that is, for any two nodes <em>P</em> and <em>Q</em>, where <em>Q</em> may be the same as <em>P</em>, there is at most one edge from <em>P</em> to <em>Q</em>.</p>
<p>Nodes are represented by integers, and there is an edge from node <em>i</em> to node <code>edges[*i*][*j*]</code> for every <em>i</em> and <em>j</em> for which the array reference <code>edges[*i*][*j*]</code> does not throw an <code>ArrayIndexOutOfBoundsException</code>.</p>
<p>The task of the method <code>loseEdges</code>, given integers <em>i</em> and <em>j</em>, is to construct a new graph by copying a given graph but omitting the edge from node <em>i</em> to node <em>j</em>, if any, and the edge from node <em>j</em> to node <em>i</em>, if any:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> Graph {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="dt">int</span> edges[][];</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="kw">public</span> <span class="fu">Graph</span>(<span class="dt">int</span>[][] edges) { <span class="kw">this</span>.<span class="fu">edges</span> = edges; }</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="kw">public</span> Graph <span class="fu">loseEdges</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">        <span class="dt">int</span> n = edges.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        <span class="dt">int</span>[][] newedges = <span class="kw">new</span> <span class="dt">int</span>[n][];</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">        <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">edgelist:</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">{</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">            <span class="dt">int</span> z;</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">search:</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">{</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">            <span class="kw">if</span> (k == i) {</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">                    <span class="kw">if</span> (edges[k][z] == j) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">                }</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">            } <span class="kw">else</span> <span class="kw">if</span> (k == j) {</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">                    <span class="kw">if</span> (edges[k][z] == i) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">                }</a>
<a class="sourceLine" id="cb20-22" data-line-number="22">            }</a>
<a class="sourceLine" id="cb20-23" data-line-number="23"></a>
<a class="sourceLine" id="cb20-24" data-line-number="24">            <span class="co">// No edge to be deleted; share this list.</span></a>
<a class="sourceLine" id="cb20-25" data-line-number="25">            newedges[k] = edges[k];</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">            <span class="kw">break</span> edgelist;</a>
<a class="sourceLine" id="cb20-27" data-line-number="27">} <span class="co">//search</span></a>
<a class="sourceLine" id="cb20-28" data-line-number="28"></a>
<a class="sourceLine" id="cb20-29" data-line-number="29">            <span class="co">// Copy the list, omitting the edge at position z.</span></a>
<a class="sourceLine" id="cb20-30" data-line-number="30">            <span class="dt">int</span> m = edges[k].<span class="fu">length</span> - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb20-31" data-line-number="31">            <span class="dt">int</span> ne[] = <span class="kw">new</span> <span class="dt">int</span>[m];</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], <span class="dv">0</span>, ne, <span class="dv">0</span>, z);</a>
<a class="sourceLine" id="cb20-33" data-line-number="33">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], z+<span class="dv">1</span>, ne, z, m-z);</a>
<a class="sourceLine" id="cb20-34" data-line-number="34">            newedges[k] = ne;</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">} <span class="co">//edgelist</span></a>
<a class="sourceLine" id="cb20-36" data-line-number="36">        }</a>
<a class="sourceLine" id="cb20-37" data-line-number="37">        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Graph</span>(newedges);</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">    }</a>
<a class="sourceLine" id="cb20-39" data-line-number="39">}</a></code></pre></div>
<p>Note the use of two statement labels, <code>edgelist</code> and <code>search</code>, and the use of <code>break</code> statements. This allows the code that copies a list, omitting one edge, to be shared between two separate tests, the test for an edge from node <em>i</em> to node <em>j</em>, and the test for an edge from node <em>j</em> to node <em>i</em>.</p>
</div>
<h3 id="jep354-14.16">14.16 The <code>continue</code> Statement</h3>
<p>A <code>continue</code> statement may occur only in a <code>while</code>, <code>do</code>, or <code>for</code> statement; statements of these three kinds are called <em>iteration statements</em>. Control passes to the loop-continuation point of an iteration statement.</p>
<dl>
<dt><em>ContinueStatement:</em></dt>
<dd><del><code>continue</code> [ <em>Identifier</em> ] <code>;</code></del>
</dd>
<dd><strong><code>continue</code> <em>Identifier</em> <code>;</code></strong>
</dd>
<dd><strong><code>continue</code> <code>;</code></strong>
</dd>
</dl>
<p><strong>There are two kinds of <code>continue</code> statement:</strong></p>
<ol type="1">
<li><p><strong>A <code>continue</code> statement with label <em>Identifier</em>.</strong></p></li>
<li><p><strong>A <code>continue</code> statement with no label.</strong></p></li>
</ol>
<p>A <code>continue</code> statement with no label attempts to transfer control to the innermost enclosing <code>while</code>, <code>do</code>, or <code>for</code> statement <del>of the immediately enclosing method, constructor, or initializer</del>; this statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</p>
<p><del>To be precise, such a <code>continue</code> statement always completes abruptly, the reason being a <code>continue</code> with no label.</del></p>
<p><del>If no <code>while</code>, <code>do</code>, or <code>for</code> statement of the immediately enclosing method, constructor, or initializer contains the <code>continue</code> statement, a compile-time error occurs.</del></p>
<p>A <code>continue</code> statement with label <em>Identifier</em> attempts to transfer control to the enclosing labeled statement (<a href="../../se11/html/jls-14.html#jls-14.7">14.7</a>) that has the same <em>Identifier</em> as its label; that statement, which is called the <em>continue target</em>, then immediately ends the current iteration and begins a new one.</p>
<p><del>To be precise, a <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a <code>continue</code> with label <em>Identifier</em>.</del></p>
<p>The continue target <strong>of a <code>continue</code> statement with label</strong> must be a <code>while</code>, <code>do</code>, or <code>for</code> statement, or a compile-time error occurs.</p>
<p><del>A <code>continue</code> statement must refer to a label within the immediately enclosing method, constructor, initializer, or lambda body. There are no non-local jumps. If no labeled statement with <em>Identifier</em> as its label in the immediately enclosing method, constructor, initializer, or lambda body contains the <code>continue</code> statement, a compile-time error occurs.</del></p>
<p><strong>It is a compile-time error if a <code>continue</code> statement has no continue target,.</strong></p>
<p><strong>It is a compile-time error if the continue target contains any method, constructor, initializer, lambda expression, or <code>switch</code> expression that contains the <code>continue</code> statement.</strong></p>
<p><strong>Execution of an <code>continue</code> statement with no label always completes abruptly, the reason being a continue with no label.</strong></p>
<p><strong>Execution of a <code>continue</code> statement with label <em>Identifier</em> always completes abruptly, the reason being a continue with label <em>Identifier</em>.</strong></p>
<blockquote>
<p>It can be seen, then, that a <code>continue</code> statement always completes abruptly.</p>
</blockquote>
<blockquote>
<p>See the descriptions of the <code>while</code> statement (<a href="../../se11/html/jls-14.html#jls-14.12">14.12</a>), <code>do</code> statement (<a href="../../se11/html/jls-14.html#jls-14.13">14.13</a>), and <code>for</code> statement (<a href="../../se11/html/jls-14.html#jls-14.14">14.14</a>) for a discussion of the handling of abrupt termination because of <code>continue</code>.</p>
</blockquote>
<blockquote>
<p>The preceding descriptions say &quot;attempts to transfer control&quot; rather than just &quot;transfers control&quot; because if there are any <code>try</code> statements (<a href="../../se11/html/jls-14.html#jls-14.20">14.20</a>) within the continue target whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>continue</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements are executed, in order, innermost to outermost, before control is transferred to the continue target. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>continue</code> statement.</p>
</blockquote>
<div class="example">
<p>Example 14.16-1. The <code>continue</code> Statement</p>
<p>In the <code>Graph</code> class in <a href="switch-expressions.html#jep354-14.15">14.15</a>, one of the <code>break</code> statements is used to finish execution of the entire body of the outermost <code>for</code> loop. This break can be replaced by a <code>continue</code> if the <code>for</code> loop itself is labeled:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> Graph {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">int</span> edges[][];</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">public</span> <span class="fu">Graph</span>(<span class="dt">int</span>[][] edges) { <span class="kw">this</span>.<span class="fu">edges</span> = edges; }</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    <span class="kw">public</span> Graph <span class="fu">loseEdges</span>(<span class="dt">int</span> i, <span class="dt">int</span> j) {</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">        <span class="dt">int</span> n = edges.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">        <span class="dt">int</span>[][] newedges = <span class="kw">new</span> <span class="dt">int</span>[n][];</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">edgelists:</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">        <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k &lt; n; ++k) {</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">            <span class="dt">int</span> z;</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">search:</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">{</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">            <span class="kw">if</span> (k == i) {</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">                    <span class="kw">if</span> (edges[k][z] == j) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">                }</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">            } <span class="kw">else</span> <span class="kw">if</span> (k == j) {</a>
<a class="sourceLine" id="cb21-18" data-line-number="18">                <span class="kw">for</span> (z = <span class="dv">0</span>; z &lt; edges[k].<span class="fu">length</span>; ++z) {</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">                    <span class="kw">if</span> (edges[k][z] == i) <span class="kw">break</span> search;</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">                }</a>
<a class="sourceLine" id="cb21-21" data-line-number="21">            }</a>
<a class="sourceLine" id="cb21-22" data-line-number="22"></a>
<a class="sourceLine" id="cb21-23" data-line-number="23">            <span class="co">// No edge to be deleted; share this list.</span></a>
<a class="sourceLine" id="cb21-24" data-line-number="24">            newedges[k] = edges[k];</a>
<a class="sourceLine" id="cb21-25" data-line-number="25">            <span class="kw">continue</span> edgelists;</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">} <span class="co">//search</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"></a>
<a class="sourceLine" id="cb21-28" data-line-number="28">            <span class="co">// Copy the list, omitting the edge at position z.</span></a>
<a class="sourceLine" id="cb21-29" data-line-number="29">            <span class="dt">int</span> m = edges[k].<span class="fu">length</span> - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-30" data-line-number="30">            <span class="dt">int</span> ne[] = <span class="kw">new</span> <span class="dt">int</span>[m];</a>
<a class="sourceLine" id="cb21-31" data-line-number="31">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], <span class="dv">0</span>, ne, <span class="dv">0</span>, z);</a>
<a class="sourceLine" id="cb21-32" data-line-number="32">            <span class="bu">System</span>.<span class="fu">arraycopy</span>(edges[k], z+<span class="dv">1</span>, ne, z, m-z);</a>
<a class="sourceLine" id="cb21-33" data-line-number="33">            newedges[k] = ne;</a>
<a class="sourceLine" id="cb21-34" data-line-number="34">        } <span class="co">//edgelists</span></a>
<a class="sourceLine" id="cb21-35" data-line-number="35">        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Graph</span>(newedges);</a>
<a class="sourceLine" id="cb21-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb21-37" data-line-number="37">}</a></code></pre></div>
<p>Which to use, if either, is largely a matter of programming style.</p>
</div>
<h3 id="jep354-14.17">14.17 The <code>return</code> Statement</h3>
<p>A <code>return</code> statement returns control to the invoker of a method (<a href="../../se11/html/jls-8.html#jls-8.4">8.4</a>, <a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) or constructor (<a href="../../se11/html/jls-8.html#jls-8.8">8.8</a>, <a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>).</p>
<dl>
<dt><em>ReturnStatement:</em></dt>
<dd><del><code>return</code> [ <em>Expression</em> ] <code>;</code></del>
</dd>
<dd><strong><code>return</code> <em>Exression</em> <code>;</code></strong>
</dd>
<dd><strong><code>return</code> <code>;</code></strong>
</dd>
</dl>
<p><strong>There are two kinds of <code>return</code> statement:</strong></p>
<ol type="1">
<li><p><strong>A <code>return</code> statement with value <em>Expression</em>.</strong></p></li>
<li><p><strong>A <code>return</code> statement with no value.</strong></p></li>
</ol>
<p><del>A <code>return</code> statement is <em>contained</em> in the innermost constructor, method, initializer, or lambda expression whose body encloses the <code>return</code> statement.</del></p>
<p><strong>A <code>return</code> statement attempts to transfer control to the invoker of the innermost enclosing constructor, method, or lambda expression; this declaration is called the <em>return target</em>. In the case of a return statement with value <em>Expression</em>, the value of the <em>Expression</em> becomes the value of the invocation.</strong></p>
<p><strong>It is a compile-time error if a <code>return</code> statement has no return target.</strong></p>
<p><strong>It is a compile-time error if the return target contains any initializer, or <code>switch</code> expression that encloses the <code>return</code> statement.</strong></p>
<p><del>It is a compile-time error if a <code>return</code> statement is contained in an instance initializer or a static initializer (<a href="../../se11/html/jls-8.html#jls-8.6">8.6</a>, <a href="../../se11/html/jls-8.html#jls-8.7">8.7</a>).</del></p>
<p><del>A <code>return</code> statement with no <em>Expression</em> must be contained in one of the following, or a compile-time error occurs:</del></p>
<ul>
<li><p><del>A method that is declared, using the keyword <code>void</code>, not to return a value (<a href="../../se11/html/jls-8.html#jls-8.4.5">8.4.5</a>)</del></p></li>
<li><p><del>A constructor (<a href="../../se11/html/jls-8.html#jls-8.8.7">8.8.7</a>)</del></p></li>
<li><p><del>A lambda expression (<a href="../../se11/html/jls-15.html#jls-15.27">15.27</a>)</del></p></li>
</ul>
<p><strong>It is a compile-time error if the return target of a <code>return</code> statement with no value is a method, and that method is not declared 'void'.</strong></p>
<p><del>A <code>return</code> statement with no <em>Expression</em> attempts to transfer control to the invoker of the method, constructor, or lambda body that contains it. To be precise, a <code>return</code> statement with no <em>Expression</em> always completes abruptly, the reason being a return with no value.</del></p>
<p><del>A <code>return</code> statement with an <em>Expression</em> must be contained in one of the following, or a compile-time error occurs:</del></p>
<ul>
<li><p><del>A method that is declared to return a value</del></p></li>
<li><p><del>A lambda expression</del></p></li>
</ul>
<p><del>The <em>Expression</em> must denote a variable or a value, or a compile-time error occurs.</del></p>
<p><del>When a <code>return</code> statement with an <em>Expression</em> appears in a method declaration, the <em>Expression</em> must be assignable (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>) to the declared return type of the method, or a compile-time error occurs.</del></p>
<p><strong>It is a compile-time error if the return target of a <code>return</code> statement with an <em>Expression</em> is a constructor or a method that is declared <code>void</code>.</strong></p>
<p><strong>It is a compile-time error if the return target of a <code>return</code> statement with an <em>Expression</em> is a method with declared return type <em>T</em>, and <em>Expression</em> is not assignable (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>) to <em>T</em>.</strong></p>
<p><strong>Execution of a <code>return</code> statement with no value always completes abruptly, the reason being a return with no value.</strong></p>
<p><del>A <code>return</code> statement with an <em>Expression</em> attempts to transfer control to the invoker of the method or lambda body that contains it; the value of the <em>Expression</em> becomes the value of the method invocation. More precisely, execution of such a <code>return</code> statement first evaluates the <em>Expression</em>.</del> <strong>Execution of a <code>return</code> statement with an <em>Expression</em> first evaluates the <em>Expression</em>.</strong> If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>return</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <em>V</em>, then the <code>return</code> statement completes abruptly, the reason being a return with value <em>V</em>.</p>
<p>If the expression is of type <code>float</code> and is not FP-strict (<a href="../../se11/html/jls-15.html#jls-15.4">15.4</a>), then the value may be an element of either the float value set or the float-extended-exponent value set (<a href="../../se11/html/jls-4.html#jls-4.2.3">4.2.3</a>). If the expression is of type <code>double</code> and is not FP-strict, then the value may be an element of either the double value set or the double-extended-exponent value set.</p>
<blockquote>
<p>It can be seen, then, that a <code>return</code> statement always completes abruptly.</p>
</blockquote>
<blockquote>
<p>The preceding descriptions say &quot;attempts to transfer control&quot; rather than just &quot;transfers control&quot; because if there are any <code>try</code> statements (<a href="../../se11/html/jls-14.html#jls-14.20">14.20</a>) within the method or constructor whose <code>try</code> blocks or <code>catch</code> clauses contain the <code>return</code> statement, then any <code>finally</code> clauses of those <code>try</code> statements will be executed, in order, innermost to outermost, before control is transferred to the invoker of the method or constructor. Abrupt completion of a <code>finally</code> clause can disrupt the transfer of control initiated by a <code>return</code> statement.</p>
</blockquote>
<h3 id="jep354-14.21">14.21 <strong>The <code>yield</code> Statement</strong></h3>
<div class="editorial">
<p>This replaces the current section 14.21, which is renumbered as 14.22.</p>
</div>
<div class="inserted">
<p>A <code>yield</code> statement transfers control by causing an enclosing <code>switch</code> expression to produce a specified value.</p>
<dl>
<dt><em>YieldStatement:</em></dt>
<dd><code>yield</code> <em>Expression</em> <code>;</code>
</dd>
</dl>
<p>A <code>yield</code> statement attempts to transfer control to the innermost enclosing <code>switch</code> expression; this expression, which is called the <em>yield target</em>, then immediately completes normally and the value of the <em>Expression</em> becomes the value of the <code>switch</code> expression.</p>
<p>It is a compile-time error if a <code>yield</code> statement has no yield target.</p>
<p>It is a compile-time error if the yield target contains any method, constructor, initializer, or lambda expression that encloses the <code>yield</code> statement. <!-- Don't need to say switch expression, as the break target is the innermost switch expression --></p>
<!--SwitchExpressions1 spec. Removed for SwitchExpressions2.
It is a compile-time error if the break target of a `yield` statement
contains any `switch`, `while`, `do` or `for` statement that encloses the
`yield` statement._
-->
<p>It is a compile-time error if the <em>Expression</em> of a <code>yield</code> statement is void (<a href="switch-expressions.html#jep354-15.1">15.1</a>).</p>
<p>Execution of a <code>yield</code> statement first evaluates the <em>Expression</em>. If the evaluation of the <em>Expression</em> completes abruptly for some reason, then the <code>yield</code> statement completes abruptly for that reason. If evaluation of the <em>Expression</em> completes normally, producing a value <em>V</em>, then the <code>yield</code> statement completes abruptly, the reason being a yield with value <em>V</em>.</p>
<blockquote>
<p>It can be seen that, like a <code>break</code> statement, a <code>yield</code> statement always completes abruptly.</p>
</blockquote>
<div class="example">
<p>Example 14.15-2. The <code>yield</code> Statement</p>
<p>In the following example, a <code>yield</code> statement is used to produce a value for the enclosing <code>switch</code> expression.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">class</span> <span class="bu">Enum</span> {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">    <span class="kw">enum</span> Day {</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">        MONDAY,</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">        TUESDAY,</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">        WEDNESDAY,</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">        THURSDAY,</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">        FRIDAY,</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">        SATURDAY,</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">        SUNDAY</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb22-12" data-line-number="12">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">calculate</span>(Day d) {</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">        <span class="kw">return</span> <span class="kw">switch</span> (d) {</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">            <span class="kw">case</span> MONDAY  -&gt; <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">            <span class="kw">case</span> TUESDAY -&gt; <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb22-16" data-line-number="16">            <span class="kw">default</span>      -&gt; {</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">                <span class="dt">int</span> l = d.<span class="fu">toString</span>().<span class="fu">length</span>();</a>
<a class="sourceLine" id="cb22-18" data-line-number="18">                yield l*l;               <span class="co">// Value of switch expression</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">            }</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">        };</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb22-22" data-line-number="22">}</a></code></pre></div>
</div>
</div>
<h3 id="jep354-14.22"><del>14.21</del> <strong>14.22</strong> Unreachable Statements</h3>
<div class="editorial">
<p>This section has been renumbered from 14.21 to 14.22.</p>
</div>
<p>It is a compile-time error if a statement cannot be executed because it is <em>unreachable</em>.</p>
<blockquote>
<p>This section is devoted to a precise explanation of the word &quot;reachable.&quot; The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of <code>while</code>, <code>do</code>, and <code>for</code> statements whose condition expression has the constant value <code>true</code>, the values of expressions are not taken into account in the flow analysis.</p>
</blockquote>
<blockquote>
<p>For example, a Java compiler will accept the code:</p>
<pre><code>{
    int n = 5;
    while (n &gt; 7) k = 2;
}</code></pre>
<p>even though the value of <code>n</code> is known at compile time and in principle it can be known at compile time that the assignment to <code>k</code> can never be executed.</p>
</blockquote>
<p>The rules in this section define two technical terms:</p>
<ul>
<li><p>whether a statement is <em>reachable</em></p></li>
<li><p>whether a statement <em>can complete normally</em></p></li>
</ul>
<p>The definitions here allow a statement to complete normally only if it is reachable.</p>
<p>To shorten the description of the rules, the customary abbreviation &quot;iff&quot; is used to mean &quot;if and only if.&quot;</p>
<p>A reachable <code>break</code> statement <em>exits a statement</em> if, within the break target, either there are no <code>try</code> statements whose <code>try</code> blocks contain the <code>break</code> statement, or there are <code>try</code> statements whose <code>try</code> blocks contain the <code>break</code> statement and all <code>finally</code> clauses of those <code>try</code> statements can complete normally.</p>
<blockquote>
<p>This definition is based on the logic around &quot;attempts to transfer control&quot; in <a href="switch-expressions.html#jep354-14.15">14.15</a>.</p>
</blockquote>
<p>A <code>continue</code> statement <em>continues a <code>do</code> statement</em> if, within the <code>do</code> statement, either there are no <code>try</code> statements whose <code>try</code> blocks contain the <code>continue</code> statement, or there are <code>try</code> statements whose <code>try</code> blocks contain the <code>continue</code> statement and all <code>finally</code> clauses of those <code>try</code> statements can complete normally.</p>
<p>The rules are as follows:</p>
<ul>
<li><p>The block that is the body of a constructor, method, instance initializer, <del>or static initializer</del> <strong>static initializer, lambda expression, or <code>switch</code> expression</strong> is reachable.</p></li>
<li><p>An empty block that is not a switch block can complete normally iff it is reachable.</p>
<p>A non-empty block that is not a switch block can complete normally iff the last statement in it can complete normally.</p>
<p>The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.</p>
<p>Every other statement <em>S</em> in a non-empty block that is not a switch block is reachable iff the statement preceding <em>S</em> can complete normally.</p></li>
<li><p>A local class declaration statement can complete normally iff it is reachable.</p></li>
<li><p>A local variable declaration statement can complete normally iff it is reachable.</p></li>
<li><p>An empty statement can complete normally iff it is reachable.</p></li>
<li><p>A labeled statement can complete normally if at least one of the following is true:</p>
<ul>
<li><p>The contained statement can complete normally.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the labeled statement.</p></li>
</ul>
<p>The contained statement is reachable iff the labeled statement is reachable.</p></li>
<li><p>An expression statement can complete normally iff it is reachable.</p></li>
<li><p>An <code>if</code>-<code>then</code> statement can complete normally iff it is reachable.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable.</p>
<p>An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.</p>
<p>The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable.</p>
<blockquote>
<p>This handling of an <code>if</code> statement, whether or not it has an <code>else</code> part, is rather unusual. The rationale is given at the end of this section.</p>
</blockquote></li>
<li><p>An <code>assert</code> statement can complete normally iff it is reachable.</p></li>
<li><p><strong>A <code>switch</code> statement whose switch block is empty, or contains only switch labels, completes normally.</strong></p></li>
<li><p>A <code>switch</code> statement <strong>with a switch block that consists of switch labeled statement groups</strong> can complete normally iff at least one of the following is true:</p>
<ul>
<li><p><del>The switch block is empty or contains only switch labels.</del></p></li>
<li><p>The last statement in the switch block can complete normally.</p></li>
<li><p>There is at least one switch label after the last switch block statement group.</p></li>
<li><p>The switch block does not contain a <code>default</code> label.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>switch</code> statement.</p></li>
</ul></li>
<li><p><strong>A <code>switch</code> statement with a switch block that consists of switch labeled rules can complete normally iff at least one of the following is true:</strong></p>
<ul>
<li><p><strong>One of the switch labeled rules is a switch labeled expression (which is necessarily a statement expression).</strong></p></li>
<li><p><strong>One of the switch labeled rules is a switch labeled block that can complete normally.</strong></p></li>
<li><p><strong>One of the switch labeled rules is a switch labeled block that contains a reachable <code>break</code> statement that exits the <code>switch</code> statement.</strong></p></li>
</ul></li>
<li><p>A switch block is reachable iff its <code>switch</code> statement is reachable.</p></li>
<li><p>A statement in a switch block <strong>that consists of switch labeled statement groups</strong> is reachable iff <del>its <code>switch</code> statement</del> <strong>the switch block</strong> is reachable and at least one of the following is true:</p>
<ul>
<li><p>It bears a <code>case</code> or <code>default</code> label.</p></li>
<li><p>There is a statement preceding it in the switch block and that preceding statement can complete normally.</p></li>
</ul></li>
<li><p><strong>A switch labeled block in a switch block is reachable iff the switch block is reachable.</strong></p></li>
<li><p>A <code>while</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>while</code> statement is reachable and the condition expression is not a constant expression (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>) with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>while</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>while</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>A <code>do</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The contained statement can complete normally and the condition expression is not a constant expression (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>) with value <code>true</code>.</p></li>
<li><p>The <code>do</code> statement contains a reachable <code>continue</code> statement with no label, and the <code>do</code> statement is the innermost <code>while</code>, <code>do</code>, or <code>for</code> statement that contains that <code>continue</code> statement, and the <code>continue</code> statement continues that <code>do</code> statement, and the condition expression is not a constant expression with value <code>true</code>.</p></li>
<li><p>The <code>do</code> statement contains a reachable <code>continue</code> statement with a label <em>L</em>, and the <code>do</code> statement has label <em>L</em>, and the <code>continue</code> statement continues that <code>do</code> statement, and the condition expression is not a constant expression with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>do</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>do</code> statement is reachable.</p></li>
<li><p>A basic <code>for</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>for</code> statement is reachable, there is a condition expression, and the condition expression is not a constant expression (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>) with value <code>true</code>.</p></li>
<li><p>There is a reachable <code>break</code> statement that exits the <code>for</code> statement.</p></li>
</ul>
<p>The contained statement is reachable iff the <code>for</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>An enhanced <code>for</code> statement can complete normally iff it is reachable.</p></li>
<li><p>A <code>break</code>, <strong><code>yield</code>,</strong> <code>continue</code>, <code>return</code>, or <code>throw</code> statement cannot complete normally.</p></li>
<li><p>A <code>synchronized</code> statement can complete normally iff the contained statement can complete normally.</p>
<p>The contained statement is reachable iff the <code>synchronized</code> statement is reachable.</p></li>
<li><p>A <code>try</code> statement can complete normally iff both of the following are true:</p>
<ul>
<li><p>The <code>try</code> block can complete normally or any <code>catch</code> block can complete normally.</p></li>
<li><p>If the <code>try</code> statement has a <code>finally</code> block, then the <code>finally</code> block can complete normally.</p></li>
</ul></li>
<li><p>The <code>try</code> block is reachable iff the <code>try</code> statement is reachable.</p></li>
<li><p>A <code>catch</code> block <em>C</em> is reachable iff both of the following are true:</p>
<ul>
<li><p>Either the type of <em>C</em>'s parameter is an unchecked exception type or <code>Exception</code> or a superclass of <code>Exception</code>, or some expression or <code>throw</code> statement in the <code>try</code> block is reachable and can throw a checked exception whose type is assignable to the type of <em>C</em>'s parameter. (An expression is reachable iff the innermost statement containing it is reachable.)</p>
<blockquote>
<p>See <a href="switch-expressions.html#jep354-15.6">15.6</a> for normal and abrupt completion of expressions.</p>
</blockquote></li>
<li><p>There is no earlier <code>catch</code> block <em>A</em> in the <code>try</code> statement such that the type of <em>C</em>'s parameter is the same as or a subclass of the type of <em>A</em>'s parameter.</p></li>
</ul></li>
<li><p>The <em>Block</em> of a <code>catch</code> block is reachable iff the <code>catch</code> block is reachable.</p></li>
<li><p>If a <code>finally</code> block is present, it is reachable iff the <code>try</code> statement is reachable.</p></li>
</ul>
<blockquote>
<p>One <em>might expect</em> the <code>if</code> statement to be handled in the following manner:</p>
</blockquote>
<blockquote>
<ul>
<li><p>An <code>if</code>-<code>then</code> statement can complete normally iff at least one of the following is true:</p>
<ul>
<li><p>The <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.</p></li>
<li><p>The <code>then</code>-statement can complete normally.</p></li>
</ul>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p></li>
<li><p>An <code>if</code>-<code>then</code>-<code>else</code> statement can complete normally iff the <code>then</code>-statement can complete normally or the <code>else</code>-statement can complete normally.</p>
<p>The <code>then</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>false</code>.</p>
<p>The <code>else</code>-statement is reachable iff the <code>if</code>-<code>then</code>-<code>else</code> statement is reachable and the condition expression is not a constant expression whose value is <code>true</code>.</p></li>
</ul>
</blockquote>
<blockquote>
<p>This approach would be consistent with the treatment of other control structures. However, in order to allow the <code>if</code> statement to be used conveniently for &quot;conditional compilation&quot; purposes, the actual rules differ.</p>
</blockquote>
<blockquote>
<p>As an example, the following statement results in a compile-time error:</p>
</blockquote>
<blockquote>
<pre><code>while (false) { x=3; }</code></pre>
</blockquote>
<blockquote>
<p>because the statement <code>x=3;</code> is not reachable; but the superficially similar case:</p>
</blockquote>
<blockquote>
<pre><code>if (false) { x=3; }</code></pre>
</blockquote>
<blockquote>
<p>does not result in a compile-time error. An optimizing compiler may realize that the statement <code>x=3;</code> will never be executed and may choose to omit the code for that statement from the generated <code>class</code> file, but the statement <code>x=3;</code> is not regarded as &quot;unreachable&quot; in the technical sense specified here.</p>
</blockquote>
<blockquote>
<p>The rationale for this differing treatment is to allow programmers to define &quot;flag&quot; variables such as:</p>
</blockquote>
<blockquote>
<pre><code>static final boolean DEBUG = false;</code></pre>
</blockquote>
<blockquote>
<p>and then write code such as:</p>
</blockquote>
<blockquote>
<pre><code>if (DEBUG) { x=3; }</code></pre>
</blockquote>
<blockquote>
<p>The idea is that it should be possible to change the value of <code>DEBUG</code> from <code>false</code> to <code>true</code> or from <code>true</code> to <code>false</code> and then compile the code correctly with no other changes to the program text.</p>
</blockquote>
<blockquote>
<p>Conditional compilation comes with a caveat. If a set of classes that use a &quot;flag&quot; variable - or more precisely, any <code>static</code> constant variable (<a href="../../se11/html/jls-4.html#jls-4.12.4">4.12.4</a>) - are compiled and conditional code is omitted, it does not suffice later to distribute just a new version of the class or interface that contains the definition of the flag. The classes that use the flag will not see its new value, so their behavior may be surprising. In essence, a change to the value of a flag is binary compatible with pre-existing binaries (no <code>LinkageError</code> occurs) but not behaviorally compatible.</p>
</blockquote>
<blockquote>
<p>Another reason for &quot;inlining&quot; values of <code>static</code> constant variables is because of <code>switch</code> statements. They are the only kind of statement that relies on constant expressions, namely that each <code>case</code> label of a <code>switch</code> statement must be a constant expression whose value is different than every other <code>case</code> label. <code>case</code> labels are often references to <code>static</code> constant variables so it may not be immediately obvious that all the labels have different values. If it is proven that there are no duplicate labels at compile time, then inlining the values into the <code>class</code> file ensures there are no duplicate labels at run time either - a very desirable property.</p>
</blockquote>
<div class="example">
<p>Example 14.21-1. Conditional Compilation</p>
<p>If the example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">class</span> Flags { <span class="dt">static</span> <span class="dt">final</span> <span class="dt">boolean</span> DEBUG = <span class="kw">true</span>; }</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">        <span class="kw">if</span> (Flags.<span class="fu">DEBUG</span>)</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">            <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;DEBUG is true&quot;</span>);</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">}</a></code></pre></div>
<p>is compiled and executed, it produces the output:</p>
<pre><code>DEBUG is true</code></pre>
<p>Suppose that a new version of class <code>Flags</code> is produced:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">class</span> Flags { <span class="dt">static</span> <span class="dt">final</span> <span class="dt">boolean</span> DEBUG = <span class="kw">false</span>; }</a></code></pre></div>
<p>If <code>Flags</code> is recompiled but not <code>Test</code>, then running the new binary with the existing binary of <code>Test</code> produces the output:</p>
<pre><code>DEBUG is true</code></pre>
<p>because <code>DEBUG</code> is a <code>static</code> constant variable, so its value could have been used in compiling <code>Test</code> without making a reference to the class <code>Flags</code>.</p>
<p>This behavior would also occur if <code>Flags</code> was an interface, as in the modified example:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">interface</span> Flags { <span class="dt">boolean</span> DEBUG = <span class="kw">true</span>; }</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="kw">class</span> Test {</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">        <span class="kw">if</span> (Flags.<span class="fu">DEBUG</span>)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">            <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;DEBUG is true&quot;</span>);</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">}</a></code></pre></div>
<p>In fact, because the fields of interfaces are always <code>static</code> and <code>final</code>, we recommend that only constant expressions be assigned to fields of interfaces. We note, but do not recommend, that if a field of primitive type of an interface may change, its value may be expressed idiomatically as in:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">interface</span> Flags {</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">    <span class="dt">boolean</span> debug = <span class="bu">Boolean</span>.<span class="fu">valueOf</span>(<span class="kw">true</span>).<span class="fu">booleanValue</span>();</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">}</a></code></pre></div>
<p>ensuring that this value is not a constant expression. Similar idioms exist for the other primitive types.</p>
</div>
<h2 id="jep354-15">Chapter 15: Expressions</h2>
<h3 id="jep354-15.1">15.1 Evaluation, Denotation, and Result</h3>
<p>When an expression in a program is <em>evaluated</em> (<em>executed</em>), the result denotes one of three things:</p>
<ul>
<li><p>A variable (<a href="../../se11/html/jls-4.html#jls-4.12">4.12</a>) (in C, this would be called an <em>lvalue</em>)</p></li>
<li><p>A value (<a href="../../se11/html/jls-4.html#jls-4.2">4.2</a>, <a href="../../se11/html/jls-4.html#jls-4.3">4.3</a>)</p></li>
<li><p>Nothing (the expression is said to be void)</p></li>
</ul>
<p>If an expression denotes a variable, and a value is required for use in further evaluation, then the value of that variable is used. In this context, if the expression denotes a variable or a value, we may speak simply of the <em>value</em> of the expression.</p>
<p>Value set conversion (<a href="../../se11/html/jls-5.html#jls-5.1.13">5.1.13</a>) is applied to the result of every expression that produces a value, including when the value of a variable of type <code>float</code> or <code>double</code> is used.</p>
<p>An expression denotes nothing if and only if it is a method invocation (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) that invokes a method that does not return a value, that is, a method declared <code>void</code> (<a href="../../se11/html/jls-8.html#jls-8.4">8.4</a>). Such an expression can be used only as an expression statement (<a href="../../se11/html/jls-14.html#jls-14.8">14.8</a>) or as the single expression of a lambda body (<a href="../../se11/html/jls-15.html#jls-15.27.2">15.27.2</a>), because every other context in which an expression can appear requires the expression to denote something. An expression statement or lambda body that is a method invocation may also invoke a method that produces a result; in this case the value returned by the method is quietly discarded.</p>
<p>Evaluation of an expression can produce side effects, because expressions may contain embedded assignments, increment operators, decrement operators, and method invocations<strong>, as well as statements contained in <code>switch</code> expressions</strong>.</p>
<p>An expression occurs in either:</p>
<ul>
<li><p>The declaration of some (class or interface) type that is being declared: in a field initializer, in a static initializer, in an instance initializer, in a constructor declaration, in a method declaration, or in an annotation.</p></li>
<li><p>An annotation on a package declaration or on a top level type declaration.</p></li>
</ul>
<h3 id="jep354-15.2">15.2 Forms of Expressions</h3>
<p>Expressions can be broadly categorized into one of the following syntactic forms:</p>
<ul>
<li><p>Expression names (<a href="../../se11/html/jls-6.html#jls-6.5.6">6.5.6</a>)</p></li>
<li><p>Primary expressions (<a href="../../se11/html/jls-15.html#jls-15.8">15.8</a> - <a href="../../se11/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
<li><p>Unary operator expressions (<a href="../../se11/html/jls-15.html#jls-15.14">15.14</a> - <a href="../../se11/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>Binary operator expressions (<a href="../../se11/html/jls-15.html#jls-15.17">15.17</a> - <a href="../../se11/html/jls-15.html#jls-15.24">15.24</a>, and <a href="../../se11/html/jls-15.html#jls-15.26">15.26</a>)</p></li>
<li><p>Ternary operator expressions (<a href="switch-expressions.html#jep354-15.25">15.25</a>)</p></li>
<li><p>Lambda expressions (<a href="../../se11/html/jls-15.html#jls-15.27">15.27</a>)</p></li>
</ul>
<p>Precedence among operators is managed by a hierarchy of grammar productions. The lowest precedence operator is the arrow of a lambda expression (<code>-&gt;</code>), followed by the assignment operators. Thus, all expressions are syntactically included in the <em>LambdaExpression</em> and <em>AssignmentExpression</em> nonterminals:</p>
<dl>
<dt><em>Expression:</em></dt>
<dd><em>LambdaExpression</em>
</dd>
<dd><em>AssignmentExpression</em>
</dd>
</dl>
<p>When some expressions appear in certain contexts, they are considered <em>poly expressions</em>. The following forms of expressions may be poly expressions:</p>
<ul>
<li><p>Parenthesized expressions (<a href="../../se11/html/jls-15.html#jls-15.8.5">15.8.5</a>)</p></li>
<li><p>Class instance creation expressions (<a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>)</p></li>
<li><p>Method invocation expressions (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>)</p></li>
<li><p>Method reference expressions (<a href="../../se11/html/jls-15.html#jls-15.13">15.13</a>)</p></li>
<li><p>Conditional expressions (<a href="switch-expressions.html#jep354-15.25">15.25</a>)</p></li>
<li><p>Lambda expressions (<a href="../../se11/html/jls-15.html#jls-15.27">15.27</a>)</p></li>
<li><p><strong><code>switch</code> expressions (<a href="switch-expressions.html#jep354-15.28">15.28</a>)</strong></p></li>
</ul>
<p>The rules determining whether an expression of one of these forms is a poly expression are given in the individual sections that specify these forms of expressions.</p>
<p>Expressions that are not poly expressions are <em>standalone expressions</em>. Standalone expressions are expressions of the forms above when determined not to be poly expressions, as well as all expressions of all other forms. Expressions of all other forms are said to have a <em>standalone form</em>.</p>
<p>Some expressions have a value that can be determined at compile time. These are <em>constant expressions</em> (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>).</p>
<h3 id="jep354-15.6">15.6 Normal and Abrupt Completion of Evaluation</h3>
<p>Every expression has a normal mode of evaluation in which certain computational steps are carried out. The following sections describe the normal mode of evaluation for each kind of expression.</p>
<p>If all the steps are carried out without an exception being thrown, the expression is said to <em>complete normally</em>.</p>
<p>If, however, evaluation of an expression throws an exception, then the expression is said to <em>complete abruptly</em>. An abrupt completion always has an associated reason, which is always a <code>throw</code> with a given value.</p>
<p>Run-time exceptions are thrown by the predefined operators as follows:</p>
<ul>
<li><p>A class instance creation expression (<a href="../../se11/html/jls-15.html#jls-15.9.4">15.9.4</a>), array creation expression (<a href="../../se11/html/jls-15.html#jls-15.10.2">15.10.2</a>), method reference expression (<a href="../../se11/html/jls-15.html#jls-15.13.3">15.13.3</a>), array initializer expression (<a href="../../se11/html/jls-10.html#jls-10.6">10.6</a>), string concatenation operator expression (<a href="../../se11/html/jls-15.html#jls-15.18.1">15.18.1</a>), or lambda expression (<a href="../../se11/html/jls-15.html#jls-15.27.4">15.27.4</a>) throws an <code>OutOfMemoryError</code> if there is insufficient memory available.</p></li>
<li><p>An array creation expression (<a href="../../se11/html/jls-15.html#jls-15.10.2">15.10.2</a>) throws a <code>NegativeArraySizeException</code> if the value of any dimension expression is less than zero.</p></li>
<li><p>An array access expression (<a href="../../se11/html/jls-15.html#jls-15.10.4">15.10.4</a>) throws a <code>NullPointerException</code> if the value of the array reference expression is <code>null</code>.</p></li>
<li><p>An array access expression (<a href="../../se11/html/jls-15.html#jls-15.10.4">15.10.4</a>) throws an <code>ArrayIndexOutOfBoundsException</code> if the value of the array index expression is negative or greater than or equal to the <code>length</code> of the array.</p></li>
<li><p>A field access expression (<a href="../../se11/html/jls-15.html#jls-15.11">15.11</a>) throws a <code>NullPointerException</code> if the value of the object reference expression is <code>null</code>.</p></li>
<li><p>A method invocation expression (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) that invokes an instance method throws a <code>NullPointerException</code> if the target reference is <code>null</code>.</p></li>
<li><p>A cast expression (<a href="../../se11/html/jls-15.html#jls-15.16">15.16</a>) throws a <code>ClassCastException</code> if a cast is found to be impermissible at run time.</p></li>
<li><p>An integer division (<a href="../../se11/html/jls-15.html#jls-15.17.2">15.17.2</a>) or integer remainder (<a href="../../se11/html/jls-15.html#jls-15.17.3">15.17.3</a>) operator throws an <code>ArithmeticException</code> if the value of the right-hand operand expression is zero.</p></li>
<li><p>An assignment to an array component of reference type (<a href="../../se11/html/jls-15.html#jls-15.26.1">15.26.1</a>), a method invocation expression (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>), or a prefix or postfix increment (<a href="../../se11/html/jls-15.html#jls-15.14.2">15.14.2</a>, <a href="switch-expressions.html#jep354-15.15.1">15.15.1</a>) or decrement operator (<a href="../../se11/html/jls-15.html#jls-15.14.3">15.14.3</a>, <a href="switch-expressions.html#jep354-15.15.2">15.15.2</a>) may all throw an <code>OutOfMemoryError</code> as a result of boxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.7">5.1.7</a>).</p></li>
<li><p>An assignment to an array component of reference type (<a href="../../se11/html/jls-15.html#jls-15.26.1">15.26.1</a>) throws an <code>ArrayStoreException</code> when the value to be assigned is not compatible with the component type of the array (<a href="../../se11/html/jls-10.html#jls-10.5">10.5</a>).</p></li>
<li><p><strong>A switch expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) may throw an <code>IncompatibleClassChangeError</code> if no switch label matches the value of the selector expression.</strong></p></li>
</ul>
<p>A method invocation expression can also result in an exception being thrown if an exception occurs that causes execution of the method body to complete abruptly.</p>
<p>A class instance creation expression can also result in an exception being thrown if an exception occurs that causes execution of the constructor to complete abruptly.</p>
<p>Various linkage and virtual machine errors may also occur during the evaluation of an expression. By their nature, such errors are difficult to predict and difficult to handle.</p>
<p>If an exception occurs, then evaluation of one or more expressions may be terminated before all steps of their normal mode of evaluation are complete; such expressions are said to complete abruptly.</p>
<p>If evaluation of an expression requires evaluation of a subexpression, then abrupt completion of the subexpression always causes the immediate abrupt completion of the expression itself, with the same reason, and all succeeding steps in the normal mode of evaluation are not performed.</p>
<p>The terms &quot;complete normally&quot; and &quot;complete abruptly&quot; are also applied to the execution of statements (<a href="switch-expressions.html#jep354-14.1">14.1</a>). A statement may complete abruptly for a variety of reasons, not just because an exception is thrown.</p>
<h3 id="jep354-15.12">15.12 Method Invocation Expressions</h3>
<h4 id="jep354-15.12.2">15.12.2 Compile-Time Step 2: Determine Method Signature</h4>
<h5 id="jep354-15.12.2.1">15.12.2.1 Identify Potentially Applicable Methods</h5>
<p>The class or interface determined by compile-time step 1 (<a href="../../se11/html/jls-15.html#jls-15.12.1">15.12.1</a>) is searched for all member methods that are potentially applicable to this method invocation; members inherited from superclasses and superinterfaces are included in this search.</p>
<p>In addition, if the form of the method invocation expression is <em>MethodName</em> - that is, a single <em>Identifier</em> - then the search for potentially applicable methods also examines all member methods that are imported by single-static-import declarations and static-import-on-demand declarations of the compilation unit where the method invocation occurs (<a href="../../se11/html/jls-7.html#jls-7.5.3">7.5.3</a>, <a href="../../se11/html/jls-7.html#jls-7.5.4">7.5.4</a>) and that are not shadowed at the point where the method invocation appears.</p>
<p>A member method is <em>potentially applicable</em> to a method invocation if and only if all of the following are true:</p>
<ul>
<li><p>The name of the member is identical to the name of the method in the method invocation.</p></li>
<li><p>The member is accessible (<a href="../../se11/html/jls-6.html#jls-6.6">6.6</a>) to the class or interface in which the method invocation appears.</p>
<blockquote>
<p>Whether a member method is accessible at a method invocation depends on the access modifier (<code>public</code>, <code>protected</code>, no modifier (package access), or <code>private</code>) in the member's declaration, and on the inheritance of the member by the class or interface determined by compile-time step 1, and on where the method invocation appears.</p>
</blockquote></li>
<li><p>If the member is a fixed arity method with arity <em>n</em>, the arity of the method invocation is equal to <em>n</em>, and for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>), the <em>i</em>'th argument of the method invocation is <em>potentially compatible</em>, as defined below, with the type of the <em>i</em>'th parameter of the method.</p></li>
<li><p>If the member is a variable arity method with arity <em>n</em>, then for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>-1), the <em>i</em>'th argument of the method invocation is <em>potentially compatible</em> with the type of the <em>i</em>'th parameter of the method; and, where the <em>n</em>th parameter of the method has type <em>T</em><code>[]</code>, one of the following is true:</p>
<ul>
<li><p>The arity of the method invocation is equal to <em>n</em>-1.</p></li>
<li><p>The arity of the method invocation is equal to <em>n</em>, and the <em>n</em>th argument of the method invocation is potentially compatible with either <em>T</em> or <em>T</em><code>[]</code>.</p></li>
<li><p>The arity of the method invocation is <em>m</em>, where <em>m</em> &gt; <em>n</em>, and for all <em>i</em> (<em>n</em> <em>≤</em> <em>i</em> <em>≤</em> <em>m</em>), the <em>i</em>'th argument of the method invocation is potentially compatible with <em>T</em>.</p></li>
</ul></li>
<li><p>If the method invocation includes explicit type arguments, and the member is a generic method, then the number of type arguments is equal to the number of type parameters of the method.</p>
<blockquote>
<p>This clause implies that a non-generic method may be potentially applicable to an invocation that supplies explicit type arguments. Indeed, it may turn out to be applicable. In such a case, the type arguments will simply be ignored.</p>
</blockquote>
<blockquote>
<p>This rule stems from issues of compatibility and principles of substitutability. Since interfaces or superclasses may be generified independently of their subtypes, we may override a generic method with a non-generic one. However, the overriding (non-generic) method must be applicable to calls to the generic method, including calls that explicitly pass type arguments. Otherwise the subtype would not be substitutable for its generified supertype.</p>
</blockquote></li>
</ul>
<p>If the search does not yield at least one method that is potentially applicable, then a compile-time error occurs.</p>
<p>An expression is <em>potentially compatible</em> with a target type according to the following rules:</p>
<ul>
<li><p>A lambda expression (<a href="../../se11/html/jls-15.html#jls-15.27">15.27</a>) is potentially compatible with a functional interface type <em>T</em> (<a href="../../se11/html/jls-9.html#jls-9.8">9.8</a>) if all of the following are true:</p>
<ul>
<li><p>The arity of the function type of <em>T</em> (<a href="../../se11/html/jls-9.html#jls-9.9">9.9</a>) is the same as the arity of the lambda expression.</p></li>
<li><p>If the function type of <em>T</em> has a <code>void</code> return, then the lambda body is either a statement expression (<a href="../../se11/html/jls-14.html#jls-14.8">14.8</a>) or a void-compatible block (<a href="../../se11/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p></li>
<li><p>If the function type of <em>T</em> has a (non-<code>void</code>) return type, then the lambda body is either an expression or a value-compatible block (<a href="../../se11/html/jls-15.html#jls-15.27.2">15.27.2</a>).</p></li>
</ul></li>
<li><p>A method reference expression (<a href="../../se11/html/jls-15.html#jls-15.13">15.13</a>) is potentially compatible with a functional interface type <em>T</em> if, where the arity of the function type of <em>T</em> is <em>n</em>, there exists at least one potentially applicable method when the method reference expression targets the function type with arity <em>n</em> (<a href="../../se11/html/jls-15.html#jls-15.13.1">15.13.1</a>), and one of the following is true:</p>
<ul>
<li><p>The method reference expression has the form <em>ReferenceType</em> <code>::</code> <em>[TypeArguments]</em> <em>Identifier</em> and at least one potentially applicable method is either (i) <code>static</code> and supports arity <em>n</em>, or (ii) not <code>static</code> and supports arity <em>n</em>-1.</p></li>
<li><p>The method reference expression has some other form and at least one potentially applicable method is not <code>static</code>.</p></li>
</ul></li>
<li><p>A lambda expression or a method reference expression is potentially compatible with a type variable if the type variable is a type parameter of the candidate method.</p></li>
<li><p>A parenthesized expression (<a href="../../se11/html/jls-15.html#jls-15.8.5">15.8.5</a>) is potentially compatible with a type if its contained expression is potentially compatible with that type.</p></li>
<li><p>A conditional expression (<a href="switch-expressions.html#jep354-15.25">15.25</a>) is potentially compatible with a type if each of its second and third operand expressions are potentially compatible with that type.</p></li>
<li><p><strong>A <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) is potentially compatible with a type if all of its result expressions are potentially compatible with that type.</strong></p></li>
<li><p>A class instance creation expression, a method invocation expression, or an expression of a standalone form (<a href="switch-expressions.html#jep354-15.2">15.2</a>) is potentially compatible with any type.</p></li>
</ul>
<blockquote>
<p>The definition of potential applicability goes beyond a basic arity check to also take into account the presence and &quot;shape&quot; of functional interface target types. In some cases involving type argument inference, a lambda expression appearing as a method invocation argument cannot be properly typed until after overload resolution. These rules allow the form of the lambda expression to still be taken into account, discarding obviously incorrect target types that might otherwise cause ambiguity errors.</p>
</blockquote>
<h5 id="jep354-15.12.2.5">15.12.2.5 Choosing the Most Specific Method</h5>
<p>If more than one member method is both accessible and applicable to a method invocation, it is necessary to choose one to provide the descriptor for the run-time method dispatch. The Java programming language uses the rule that the <em>most specific</em> method is chosen.</p>
<p>The informal intuition is that one method is more specific than another if any invocation handled by the first method could be passed on to the other one without a compile-time error. In cases such as an explicitly typed lambda expression argument (<a href="../../se11/html/jls-15.html#jls-15.27.1">15.27.1</a>) or a variable arity invocation (<a href="../../se11/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>), some flexibility is allowed to adapt one signature to the other.</p>
<p>One applicable method <em>m<sub>1</sub></em> is <em>more specific</em> than another applicable method <em>m<sub>2</sub></em>, for an invocation with argument expressions <em>e<sub>1</sub></em>, ..., <em>e<sub>k</sub></em>, if any of the following are true:</p>
<ul>
<li><p><em>m<sub>2</sub></em> is generic, and <em>m<sub>1</sub></em> is inferred to be more specific than <em>m<sub>2</sub></em> for argument expressions <em>e<sub>1</sub></em>, ..., <em>e<sub>k</sub></em> by <a href="switch-expressions.html#jep354-18.5.4">18.5.4</a>.</p></li>
<li><p><em>m<sub>2</sub></em> is not generic, and <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by strict or loose invocation, and where <em>m<sub>1</sub></em> has formal parameter types <em>S<sub>1</sub></em>, ..., <em>S<sub>n</sub></em> and <em>m<sub>2</sub></em> has formal parameter types <em>T<sub>1</sub></em>, ..., <em>T<sub>n</sub></em>, the type <em>S<sub>i</sub></em> is <em>more specific</em> than <em>T<sub>i</sub></em> for argument <em>e<sub>i</sub></em> for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>, <em>n</em> = <em>k</em>).</p></li>
<li><p><em>m<sub>2</sub></em> is not generic, and <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by variable arity invocation, and where the first <em>k</em> variable arity parameter types of <em>m<sub>1</sub></em> are <em>S<sub>1</sub></em>, ..., <em>S<sub>k</sub></em> and the first <em>k</em> variable arity parameter types of <em>m<sub>2</sub></em> are <em>T<sub>1</sub></em>, ..., <em>T<sub>k</sub></em>, the type <em>S<sub>i</sub></em> is <em>more specific</em> than <em>T<sub>i</sub></em> for argument <em>e<sub>i</sub></em> for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>k</em>). Additionally, if <em>m<sub>2</sub></em> has <em>k</em>+1 parameters, then the <em>k+1</em>'th variable arity parameter type of <em>m<sub>1</sub></em> is a subtype of the <em>k+1</em>'th variable arity parameter type of <em>m<sub>2</sub></em>.</p></li>
</ul>
<p>The above conditions are the only circumstances under which one method may be more specific than another.</p>
<p>A type <em>S</em> is <em>more specific</em> than a type <em>T</em> for <em>any</em> expression if <em>S</em> <code>&lt;:</code> <em>T</em> (<a href="../../se11/html/jls-4.html#jls-4.10">4.10</a>).</p>
<p>A functional interface type <em>S</em> is <em>more specific</em> than a functional interface type <em>T</em> for an expression <em>e</em> if all of the following are true:</p>
<ul>
<li><p>The interface of <em>S</em> is neither a superinterface nor a subinterface of the interface of <em>T</em>.</p>
<p>If <em>S</em> or <em>T</em> is an intersection type, it is not the case that any interface of <em>S</em> is a superinterface or a subinterface of any interface of <em>T</em>. (The &quot;interfaces of&quot; an intersection type refers here to the set of interfaces that appear as (possibly parameterized) interface types in the intersection.)</p></li>
<li><p>Let <em>MT<sub>S</sub></em> be the function type of the capture of <em>S</em>, and let <em>MT<sub>T</sub></em> be the function type of <em>T</em>. <em>MT<sub>S</sub></em> and <em>MT<sub>T</sub></em> must have the same type parameters (if any) (<a href="../../se11/html/jls-8.html#jls-8.4.4">8.4.4</a>).</p></li>
<li><p>Let <em>P<sub>1</sub></em>, ..., <em>P<sub>n</sub></em> be the formal parameter types of <em>MT<sub>S</sub></em>, adapted to the type parameters of <em>MT<sub>T</sub></em>. Let <em>P<sub>1</sub></em>', ..., <em>P<sub>n</sub></em>' be the formal parameter types of the function type of <em>S</em> (without capture), adapted to the type parameters of <em>MT<sub>T</sub></em>. Let <em>Q<sub>1</sub></em>, ..., <em>Q<sub>n</sub></em> be the formal parameter types of <em>MT<sub>T</sub></em>. Then, for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>n</em>), <em>Q<sub>i</sub></em> <code>&lt;:</code> <em>P<sub>i</sub></em> and <em>Q<sub>i</sub></em> = <em>P<sub>i</sub></em>'.</p>
<blockquote>
<p>Generally, this rule asserts that the formal parameter types derived from <em>S</em> and <em>T</em> are the same. But in the case in which <em>S</em> is a wildcard-parameterized type, the check is more complex in order to allow capture variables to occur in formal parameter types: first, each formal parameter type of <em>T</em> must be a subtype of the corresponding formal parameter type of the capture of <em>S</em>; second, after mapping the wildcards to their bounds (<a href="../../se11/html/jls-9.html#jls-9.9">9.9</a>), the formal parameter types of the resulting function types are the same.</p>
</blockquote></li>
<li><p>Let <em>R<sub>S</sub></em> be the return type of <em>MT<sub>S</sub></em>, adapted to the type parameters of <em>MT<sub>T</sub></em>, and let <em>R<sub>T</sub></em> be the return type of <em>MT<sub>T</sub></em>. One of the following must be true:</p>
<ul>
<li><p><em>e</em> is an explicitly typed lambda expression (<a href="../../se11/html/jls-15.html#jls-15.27.1">15.27.1</a>), and one of the following is true:</p>
<ul>
<li><p><em>R<sub>T</sub></em> is <code>void</code>.</p></li>
<li><p><em>R<sub>S</sub></em> <code>&lt;:</code> <em>R<sub>T</sub></em>.</p></li>
<li><p><em>R<sub>S</sub></em> and <em>R<sub>T</sub></em> are functional interface types, and there is at least one result expression, and <em>R<sub>S</sub></em> is more specific than <em>R<sub>T</sub></em> for each result expression of <em>e</em>.</p>
<p>The result expression of a lambda expression with a block body is defined in <a href="../../se11/html/jls-15.html#jls-15.27.2">15.27.2</a>; the result expression of a lambda expression with an expression body is simply the body itself.</p></li>
<li><p><em>R<sub>S</sub></em> is a primitive type, and <em>R<sub>T</sub></em> is a reference type, and there is at least one result expression, and each result expression of <em>e</em> is a standalone expression (<a href="switch-expressions.html#jep354-15.2">15.2</a>) of a primitive type.</p></li>
<li><p><em>R<sub>S</sub></em> is a reference type, and <em>R<sub>T</sub></em> is a primitive type, and there is at least one result expression, and each result expression of <em>e</em> is either a standalone expression of a reference type or a poly expression.</p></li>
</ul></li>
<li><p><em>e</em> is an exact method reference expression (<a href="../../se11/html/jls-15.html#jls-15.13.1">15.13.1</a>), and one of the following is true:</p>
<ul>
<li><p><em>R<sub>T</sub></em> is <code>void</code>.</p></li>
<li><p><em>R<sub>S</sub></em> <code>&lt;:</code> <em>R<sub>T</sub></em>.</p></li>
<li><p><em>R<sub>S</sub></em> is a primitive type, <em>R<sub>T</sub></em> is a reference type, and the compile-time declaration for the method reference has a return type which is a primitive type.</p></li>
<li><p><em>R<sub>S</sub></em> is a reference type, <em>R<sub>T</sub></em> is a primitive type, and the compile-time declaration for the method reference has a return type which is a reference type.</p></li>
</ul></li>
<li><p><em>e</em> is a parenthesized expression, and one of these conditions applies recursively to the contained expression.</p></li>
<li><p><em>e</em> is a conditional expression, and, for each of the second and third operands, one of these conditions applies recursively.</p></li>
<li><p><strong><em>e</em> is a <code>switch</code> expression, and, for each of its result expressions, one of these conditions applies recursively.</strong></p></li>
</ul></li>
</ul>
<p>A method <em>m<sub>1</sub></em> is <em>strictly more specific</em> than another method <em>m<sub>2</sub></em> if and only if <em>m<sub>1</sub></em> is more specific than <em>m<sub>2</sub></em> and <em>m<sub>2</sub></em> is not more specific than <em>m<sub>1</sub></em>.</p>
<p>A method is said to be <em>maximally specific</em> for a method invocation if it is accessible and applicable and there is no other method that is accessible and applicable that is strictly more specific.</p>
<p>If there is exactly one maximally specific method, then that method is in fact the <em>most specific method</em>; it is necessarily more specific than any other accessible method that is applicable. It is then subjected to some further compile-time checks as specified in <a href="../../se11/html/jls-15.html#jls-15.12.3">15.12.3</a>.</p>
<p>It is possible that no method is the most specific, because there are two or more methods that are maximally specific. In this case:</p>
<ul>
<li><p>If all the maximally specific methods have override-equivalent signatures (<a href="../../se11/html/jls-8.html#jls-8.4.2">8.4.2</a>), and <em>exactly one</em> of the maximally specific methods is concrete (that is, neither <code>abstract</code> nor default), then it is the most specific method.</p></li>
<li><p>Otherwise, if all the maximally specific methods have override-equivalent signatures, and <em>all</em> the maximally specific methods are <code>abstract</code> or default, and the declarations of these methods have the same erased parameter types, and at least one maximally specific method is <em>preferred</em> according to the rules below, then the most specific method is chosen arbitrarily among the subset of the maximally specific methods that are preferred. The most specific method is then considered to be <code>abstract</code>.</p>
<p>A maximally specific method is <em>preferred</em> if it has:</p>
<ul>
<li><p>a signature that is a subsignature of every maximally specific method's signature; and</p></li>
<li><p>a return type <em>R</em> (possibly <code>void</code>), where either <em>R</em> is the same as every maximally specific method's return type, or <em>R</em> is a reference type and is a subtype of every maximally specific method's return type (after adapting for any type parameters (<a href="../../se11/html/jls-8.html#jls-8.4.4">8.4.4</a>) if the two methods have the same signature).</p></li>
</ul>
<p>If no preferred method exists according to the above rules, then a maximally specific method is <em>preferred</em> if it:</p>
<ul>
<li><p>has a signature that is a subsignature of every maximally specific method's signature; and</p></li>
<li><p>is return-type-substitutable (<a href="../../se11/html/jls-8.html#jls-8.4.5">8.4.5</a>) for every maximally specific method.</p></li>
</ul>
<p>The thrown exception types of the most specific method are derived from the <code>throws</code> clauses of the maximally specific methods, as follows:</p>
<ol type="1">
<li><p>If the most specific method is generic, the <code>throws</code> clauses are first adapted to the type parameters of the most specific method (<a href="../../se11/html/jls-8.html#jls-8.4.4">8.4.4</a>).</p>
<p>If the most specific method is not generic but at least one maximally specific method is generic, the <code>throws</code> clauses are first erased.</p></li>
<li><p>Then, the thrown exception types include every type <em>E</em> which satisfies the following constraints:</p>
<ul>
<li><p>E is mentioned in one of the <code>throws</code> clauses.</p></li>
<li><p>For each <code>throws</code> clause, <em>E</em> is a subtype of some type named in that clause.</p></li>
</ul></li>
</ol>
<blockquote>
<p>These rules for deriving a single method type from a group of overloaded methods are also used to identify the function type of a functional interface (<a href="../../se11/html/jls-9.html#jls-9.9">9.9</a>).</p>
</blockquote></li>
<li><p>Otherwise, the method invocation is <em>ambiguous</em>, and a compile-time error occurs.</p></li>
</ul>
<h3 id="jep354-15.15">15.15 Unary <del>Operators</del> <strong>Expressions</strong></h3>
<p>The operators <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, and the cast operator (<a href="../../se11/html/jls-15.html#jls-15.16">15.16</a>) are called the <em>unary operators</em><strong>, which are used to form unary expressions</strong>. <strong>In addition, the <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) is treated grammatically as a unary expression.</strong></p>
<dl>
<dt><em>UnaryExpression:</em></dt>
<dd><em>PreIncrementExpression</em>
</dd>
<dd><em>PreDecrementExpression</em>
</dd>
<dd><code>+</code> <em>UnaryExpression</em>
</dd>
<dd><code>-</code> <em>UnaryExpression</em>
</dd>
<dd><em>UnaryExpressionNotPlusMinus</em>
</dd>
<dt><em>PreIncrementExpression:</em></dt>
<dd><code>++</code> <em>UnaryExpression</em>
</dd>
<dt><em>PreDecrementExpression:</em></dt>
<dd><code>--</code> <em>UnaryExpression</em>
</dd>
<dt><em>UnaryExpressionNotPlusMinus:</em></dt>
<dd><em>PostfixExpression</em>
</dd>
<dd><code>~</code> <em>UnaryExpression</em>
</dd>
<dd><code>!</code> <em>UnaryExpression</em>
</dd>
<dd><em>CastExpression</em>
</dd>
<dd><strong><em>SwitchExpression</em></strong>
</dd>
</dl>
<blockquote>
<p><del>The following production from <a href="../../se11/html/jls-15.html#jls-15.16">15.16</a> is shown here for convenience:</del></p>
<dl>
<dt><del><em>CastExpression:</em></del></dt>
<dd><del><code>(</code> <em>PrimitiveType</em> <code>)</code> <em>UnaryExpression</em></del>
</dd>
<dd><del><code>(</code> <em>ReferenceType</em> {<em>AdditionalBound</em>} <code>)</code> <em>UnaryExpressionNotPlusMinus</em></del>
</dd>
<dd><del><code>(</code> <em>ReferenceType</em> {<em>AdditionalBound</em>} <code>)</code> <em>LambdaExpression</em></del>
</dd>
</dl>
</blockquote>
<p>Expressions with unary operators group right-to-left, so that <code>-~x</code> means the same as <code>-(~x)</code>.</p>
<blockquote>
<p>This portion of the grammar contains some tricks to avoid two potential syntactic ambiguities.</p>
</blockquote>
<blockquote>
<p>The first potential ambiguity would arise in expressions such as <code>(p)+q</code>, which looks, to a C or C++ programmer, as though it could be either a cast to type <code>p</code> of a unary <code>+</code> operating on <code>q</code>, or a binary addition of two quantities <code>p</code> and <code>q</code>. In C and C++, the parser handles this problem by performing a limited amount of semantic analysis as it parses, so that it knows whether <code>p</code> is the name of a type or the name of a variable.</p>
</blockquote>
<blockquote>
<p>Java takes a different approach. The result of the <code>+</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a cast of a unary expression. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)+q</code> can make sense only as a binary arithmetic operation. Similar remarks apply to the <code>-</code> operator. The grammar shown above splits <em>CastExpression</em> into two cases to make this distinction. The nonterminal <em>UnaryExpression</em> includes all unary operators, but the nonterminal <em>UnaryExpressionNotPlusMinus</em> excludes uses of all unary operators that could also be binary operators, which in Java are <code>+</code> and <code>-</code>.</p>
</blockquote>
<blockquote>
<p>The second potential ambiguity is that the expression <code>(p)++</code> could, to a C or C++ programmer, appear to be either a postfix increment of a parenthesized expression or the beginning of a cast, for example, in <code>(p)++q</code>. As before, parsers for C and C++ know whether <code>p</code> is the name of a type or the name of a variable. But a parser using only one-token lookahead and no semantic analysis during the parse would not be able to tell, when <code>++</code> is the lookahead token, whether <code>(p)</code> should be considered a <em>Primary</em> expression or left alone for later consideration as part of a <em>CastExpression</em>.</p>
</blockquote>
<blockquote>
<p>In Java, the result of the <code>++</code> operator must be numeric, and all type names involved in casts on numeric values are known keywords. Thus, if <code>p</code> is a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a cast of a prefix increment expression, and there had better be an operand such as <code>q</code> following the <code>++</code>. However, if <code>p</code> is not a keyword naming a primitive type, then <code>(p)++</code> can make sense only as a postfix increment of <code>p</code>. Similar remarks apply to the <code>--</code> operator. The nonterminal <em>UnaryExpressionNotPlusMinus</em> therefore also excludes uses of the prefix operators <code>++</code> and <code>--</code>.</p>
</blockquote>
<h3 id="jep354-15.25">15.25 Conditional Operator <code>? :</code></h3>
<p>The conditional operator <code>? :</code> uses the boolean value of one expression to decide which of two other expressions should be evaluated.</p>
<dl>
<dt><em>ConditionalExpression:</em></dt>
<dd><em>ConditionalOrExpression</em>
</dd>
<dd><em>ConditionalOrExpression</em> <code>?</code> <em>Expression</em> <code>:</code> <em>ConditionalExpression</em>
</dd>
<dd><em>ConditionalOrExpression</em> <code>?</code> <em>Expression</em> <code>:</code> <em>LambdaExpression</em> #
</dd>
</dl>
<p>The conditional operator is syntactically right-associative (it groups right-to-left). Thus, <code>a?b:c?d:e?f:g</code> means the same as <code>a?b:(c?d:(e?f:g))</code>.</p>
<p>The conditional operator has three operand expressions. <code>?</code> appears between the first and second expressions, and <code>:</code> appears between the second and third expressions.</p>
<p>The first expression must be of type <code>boolean</code> or <code>Boolean</code>, or a compile-time error occurs.</p>
<p>It is a compile-time error for either the second or the third operand expression to be an invocation of a <code>void</code> method.</p>
<blockquote>
<p>In fact, by the grammar of expression statements (<a href="../../se11/html/jls-14.html#jls-14.8">14.8</a>), it is not permitted for a conditional expression to appear in any context where an invocation of a <code>void</code> method could appear.</p>
</blockquote>
<p>There are three kinds of conditional expressions, classified according to the second and third operand expressions: <em>boolean conditional expressions</em>, <em>numeric conditional expressions</em>, and <em>reference conditional expressions</em>. The classification rules are as follows:</p>
<ul>
<li><p>If both the second and the third operand expressions are <em>boolean expressions</em>, the conditional expression is a boolean conditional expression.</p>
<p>For the purpose of classifying a conditional, the following expressions are boolean expressions:</p>
<ul>
<li><p>An expression of a standalone form (<a href="switch-expressions.html#jep354-15.2">15.2</a>) that has type <code>boolean</code> or <code>Boolean</code>.</p></li>
<li><p>A parenthesized <code>boolean</code> expression (<a href="../../se11/html/jls-15.html#jls-15.8.5">15.8.5</a>).</p></li>
<li><p>A class instance creation expression (<a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>) for class <code>Boolean</code>.</p></li>
<li><p>A method invocation expression (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) for which the chosen most specific method (<a href="switch-expressions.html#jep354-15.12.2.5">15.12.2.5</a>) has return type <code>boolean</code> or <code>Boolean</code>.</p>
<blockquote>
<p>Note that, for a generic method, this is the type <em>before</em> instantiating the method's type arguments.</p>
</blockquote></li>
<li><p>A <code>boolean</code> conditional expression.</p></li>
<li><p><strong>A <code>switch</code> expression whose result expressions are all <code>boolean</code> expressions.</strong></p></li>
</ul></li>
<li><p>If both the second and the third operand expressions are <em>numeric expressions</em>, the conditional expression is a numeric conditional expression.</p>
<p>For the purpose of classifying a conditional, the following expressions are numeric expressions:</p>
<ul>
<li><p>An expression of a standalone form (<a href="switch-expressions.html#jep354-15.2">15.2</a>) with a type that is convertible to a numeric type (<a href="../../se11/html/jls-4.html#jls-4.2">4.2</a>, <a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p></li>
<li><p>A parenthesized numeric expression (<a href="../../se11/html/jls-15.html#jls-15.8.5">15.8.5</a>).</p></li>
<li><p>A class instance creation expression (<a href="../../se11/html/jls-15.html#jls-15.9">15.9</a>) for a class that is convertible to a numeric type.</p></li>
<li><p>A method invocation expression (<a href="../../se11/html/jls-15.html#jls-15.12">15.12</a>) for which the chosen most specific method (<a href="switch-expressions.html#jep354-15.12.2.5">15.12.2.5</a>) has a return type that is convertible to a numeric type.</p>
<blockquote>
<p>Note that, for a generic method, this is the type <em>before</em> instantiating the method's type arguments.</p>
</blockquote></li>
<li><p>A numeric conditional expression.</p></li>
<li><p><strong>A <code>switch</code> expression whose result expressions are all numeric expressions.</strong></p></li>
</ul></li>
<li><p>Otherwise, the conditional expression is a reference conditional expression.</p></li>
</ul>
<p>The process for determining the type of a conditional expression depends on the kind of conditional expression, as outlined in the following sections.</p>
<p>...</p>
<h4 id="jep354-15.25.1">15.25.1 Boolean Conditional Expressions</h4>
<p>Boolean conditional expressions are standalone expressions (<a href="switch-expressions.html#jep354-15.2">15.2</a>).</p>
<p>The type of a boolean conditional expression is determined as follows:</p>
<ul>
<li><p>If the second and third operands are both of type <code>Boolean</code>, the conditional expression has type <code>Boolean</code>.</p></li>
<li><p>Otherwise, the conditional expression has type <code>boolean</code>.</p></li>
</ul>
<h4 id="jep354-15.25.2">15.25.2 Numeric Conditional Expressions</h4>
<p>Numeric conditional expressions are standalone expressions (<a href="switch-expressions.html#jep354-15.2">15.2</a>).</p>
<p>The type of a numeric conditional expression is determined as follows:</p>
<ul>
<li><p>If the second and third operands have the same type, then that is the type of the conditional expression.</p></li>
<li><p>If one of the second and third operands is of primitive type <em>T</em>, and the type of the other is the result of applying boxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.7">5.1.7</a>) to <em>T</em>, then the type of the conditional expression is <em>T</em>.</p></li>
<li><p>If one of the operands is of type <code>byte</code> or <code>Byte</code> and the other is of type <code>short</code> or <code>Short</code>, then the type of the conditional expression is <code>short</code>.</p></li>
<li><p>If one of the operands is of type <em>T</em> where <em>T</em> is <code>byte</code>, <code>short</code>, or <code>char</code>, and the other operand is a constant expression (<del><a href="switch-expressions.html#jep354-15.29">15.28</a></del> <strong><a href="switch-expressions.html#jep354-15.29">15.29</a></strong>) of type <code>int</code> whose value is representable in type <em>T</em>, then the type of the conditional expression is <em>T</em>.</p></li>
<li><p>If one of the operands is of type <em>T</em>, where <em>T</em> is <code>Byte</code>, <code>Short</code>, or <code>Character</code>, and the other operand is a constant expression of type <code>int</code> whose value is representable in the type <em>U</em> which is the result of applying unboxing conversion to <em>T</em>, then the type of the conditional expression is <em>U</em>.</p></li>
<li><p>Otherwise, binary numeric promotion (<a href="switch-expressions.html#jep354-5.6">5.6</a>) is applied to the <strong>second and third</strong> operand types, and the type of the conditional expression is the promoted type of the second and third operands.</p>
<blockquote>
<p>Note that binary numeric promotion performs value set conversion (<a href="../../se11/html/jls-5.html#jls-5.1.13">5.1.13</a>) and may perform unboxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>).</p>
</blockquote></li>
</ul>
<h4 id="jep354-15.25.3">15.25.3 Reference Conditional Expressions</h4>
<p>A reference conditional expression is a poly expression if it appears in an assignment context or an invocation context (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>. <a href="../../se11/html/jls-5.html#jls-5.3">5.3</a>). Otherwise, it is a standalone expression.</p>
<p>Where a poly reference conditional expression appears in a context of a particular kind with target type <em>T</em>, its second and third operand expressions similarly appear in a context of the same kind with target type <em>T</em>.</p>
<p>A poly reference conditional expression is compatible with a target type <em>T</em> if its second and third operand expressions are compatible with <em>T</em>.</p>
<p>The type of a poly reference conditional expression is the same as its target type.</p>
<p>The type of a standalone reference conditional expression is determined as follows:</p>
<ul>
<li><p>If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.</p></li>
<li><p>If the type of one of the second and third operands is the null type, and the type of the other operand is a reference type, then the type of the conditional expression is that reference type.</p></li>
<li><p>Otherwise, the second and third operands are of types <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> respectively. Let <em>T<sub>1</sub></em> be the type that results from applying boxing conversion to <em>S<sub>1</sub></em>, and let <em>T<sub>2</sub></em> be the type that results from applying boxing conversion to <em>S<sub>2</sub></em>. The type of the conditional expression is the result of applying capture conversion (<a href="../../se11/html/jls-5.html#jls-5.1.10">5.1.10</a>) to lub(<em>T<sub>1</sub></em>, <em>T<sub>2</sub></em>).</p></li>
</ul>
<blockquote>
<p>Because reference conditional expressions can be poly expressions, they can &quot;pass down&quot; context to their operands. This allows lambda expressions and method reference expressions to appear as operands:</p>
</blockquote>
<blockquote>
<pre><code>return ... ? (x `-&gt;` x) : (x `-&gt;` -x);</code></pre>
</blockquote>
<blockquote>
<p>It also allows use of extra information to improve type checking of generic method invocations. Prior to Java SE 8, this assignment was well-typed:</p>
</blockquote>
<blockquote>
<pre><code>List&lt;String&gt; ls = Arrays.asList();</code></pre>
</blockquote>
<blockquote>
<p>but this was not:</p>
</blockquote>
<blockquote>
<pre><code>List&lt;String&gt; ls = ... ? Arrays.asList() : Arrays.asList(&quot;a&quot;,&quot;b&quot;);</code></pre>
</blockquote>
<blockquote>
<p>The rules above allow both assignments to be considered well-typed.</p>
</blockquote>
<blockquote>
<p>Note that a reference conditional expression does not have to <em>contain</em> a poly expression as an operand in order to <em>be</em> a poly expression. It is a poly expression simply by virtue of the context in which it appears. For example, in the following code, the conditional expression is a poly expression, and each operand is considered to be in an assignment context targeting <code>Class&lt;? super Integer&gt;</code>:</p>
</blockquote>
<blockquote>
<div class="sourceCode" id="cb37"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="bu">Class</span>&lt;? <span class="kw">super</span> <span class="bu">Integer</span>&gt; <span class="fu">choose</span>(<span class="dt">boolean</span> b,</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">                              <span class="bu">Class</span>&lt;<span class="bu">Integer</span>&gt; c1,</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">                              <span class="bu">Class</span>&lt;<span class="bu">Number</span>&gt; c2) {</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">    <span class="kw">return</span> b ? c1 : c2;</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">}</a></code></pre></div>
</blockquote>
<blockquote>
<p>If the conditional expression was not a poly expression, then a compile-time error would occur, as its type would be lub(<code>Class&lt;Integer&gt;</code>, <code>Class&lt;Number&gt;</code>) = <code>Class&lt;? extends Number&gt;</code> which is incompatible with the return type of <code>choose</code>.</p>
</blockquote>
<h3 id="jep354-15.28"><strong>15.28 <code>switch</code> Expressions</strong></h3>
<div class="inserted">
<p>A <code>switch</code> expression is the expression analogue of the <code>switch</code> statement (<a href="switch-expressions.html#jep354-14.11">14.11</a>). It consists of a <em>selector expression</em> and a <em>switch block</em> (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>). A <code>switch</code> expression matches the value of the selector expression against the switch labels associated with the switch block to determine which code contained in the switch block to execute to return a value. In contrast to a <code>switch</code> statement, the switch block is checked to ensure that the <code>switch</code> expression either completes normally with a value or completes abruptly.</p>
<dl>
<dt><em>SwitchExpression:</em></dt>
<dd><code>switch</code> <code>(</code> <em>Expression</em> <code>)</code> <em>SwitchBlock</em>
</dd>
</dl>
<p>The type of the selector expression must be <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>Character</code>, <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>String</code>, or an enum type (<a href="../../se11/html/jls-8.html#jls-8.9">8.9</a>), or a compile-time error occurs.</p>
</div>
<h3 id="jep354-15.28.1"><strong>15.28.1 The switch block of a <code>switch</code> expression</strong></h3>
<div class="inserted">
<p>Given a <code>switch</code> expression, all of the following must be true or a compile-time error occurs:</p>
<ul>
<li><p>The switch block must be compatible with the type of the selector expression (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>).</p></li>
<li><p>No two of the <code>case</code> constants associated with the switch block may have the same value.</p></li>
<li><p>Either there is exactly one <code>default</code> label associated with the switch block; or if the type of the selector expression is an enum type, then the set of all the <code>case</code> constants associated with the switch block must contain all the enum constants of that enum type.</p></li>
<li><p>If the switch block consists of switch labeled rules, then any switch labeled block (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) <!--must complete abruptly.-->cannot complete normally.</p></li>
<li><p>If the switch block consists of switch labeled statement groups, then the last statement in the switch block <!--must complete abruptly--> cannot complete normally (<a href="switch-expressions.html#jep354-14.1">14.1</a>), and the switch block must not have any switch labels after the last switch labeled statement group.</p></li>
</ul>
<blockquote>
<p>This forbids a <code>switch</code> expression to have an empty switch block.</p>
</blockquote>
<blockquote>
<p>Switch labeled rules in <code>switch</code> expressions differ from those in <code>switch</code> statements (<a href="switch-expressions.html#jep354-14.11.2">14.11.2</a>). In <code>switch</code> expressions they may be any switch labeled expression, whereas in <code>switch</code> statements they must be switch labeled <em>statement</em> expressions (<a href="../../se11/html/jls-14.html#jls-14.8">14.8</a>).</p>
</blockquote>
<p>The <em>result expressions</em> of a <code>switch</code> expression are determined as follows:</p>
<ul>
<li><p>If the switch block consists of switch labeled rules, then each is considered in turn:</p>
<ul>
<li><p>if it is a switch labeled expression, then this expression is a result expression of the <code>switch</code> expression.</p></li>
<li><p>if it is a switch labeled block, then every expression immediately contained in a <code>yield</code> statement in the block whose yield target is the given <code>switch</code> expression is a result expression of the <code>switch</code> expression</p></li>
</ul></li>
<li><p>If the switch block consists of switch labeled statement groups, then every expression immediately contained in a <code>yield</code> statement in the block whose yield target is the given <code>switch</code> expression is a result expression of the <code>switch</code> expression.</p></li>
</ul>
<p>It is a compile-time error if a <code>switch</code> expression has no result expressions.</p>
<p>A <code>switch</code> expression is a poly expression if it appears in an assignment context or an invocation context (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>, <a href="../../se11/html/jls-5.html#jls-5.3">5.3</a>). Otherwise, it is a standalone expression.</p>
<p>Where a poly <code>switch</code> expression appears in a context of a particular kind with target type <em>T</em>, its result expressions similarly appear in a context of the same kind with target type <em>T</em>.</p>
<p>A poly <code>switch</code> expression is compatible with a target type <em>T</em> if each of its result expressions is compatible with <em>T</em>.</p>
<p>The type of a poly <code>switch</code> expression is the same as its target type.</p>
<p>The type of a standalone <code>switch</code> expression is determined as follows:</p>
<ul>
<li><p>If the result expressions all have the same type (which may be the <code>null</code> type), then that is the type of the <code>switch</code> expression.</p></li>
<li><p>Otherwise, if the type of each result expression is <code>boolean</code> or <code>Boolean</code>, an unboxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>) is applied to each result expression of type <code>Boolean</code>, and the <code>switch</code> expression has type <code>boolean</code>.</p></li>
<li><p>Otherwise, if the type of each result expression is convertible to a numeric type (<a href="../../se11/html/jls-5.html#jls-5.1.8">5.1.8</a>), the type of the <code>switch</code> expression is the result of numeric promotion (<a href="switch-expressions.html#jep354-5.6">5.6</a>) applied to the result expressions.</p></li>
<li><p>Otherwise, boxing conversion (<a href="../../se11/html/jls-5.html#jls-5.1.7">5.1.7</a>) is applied to each result expression that has a primitive type, after which the type of the <code>switch</code> expression is the result of applying capture conversion (<a href="../../se11/html/jls-5.html#jls-5.1.10">5.1.10</a>) to the least upper bound (<a href="../../se11/html/jls-4.html#jls-4.10.4">4.10.4</a>) of the types of the result expressions.</p></li>
</ul>
</div>
<h3 id="jep354-15.28.2"><strong>15.28.2 Run-Time Evaluation of <code>switch</code> Expressions</strong></h3>
<div class="inserted">
<p>When the <code>switch</code> expression is executed, first the selector expression is evaluated; exactly one of three outcomes are possible.</p>
<ol type="1">
<li><p>If evaluation of the selector expression completes abruptly for some reason, the <code>switch</code> expression completes abruptly for the same reason.</p></li>
<li><p>If the selector expression evaluates to <code>null</code>, then a <code>NullPointerException</code> is thrown and the entire <code>switch</code> expression completes abruptly for that reason.</p></li>
<li><p>Otherwise, execution continues by determining if a switch label associated with the switch block matches (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) the value of the selector expression.</p>
<p>If no switch label matches, then an <code>IncompatibleClassChangeError</code> is thrown and the entire <code>switch</code> expression completes abruptly for that reason.</p>
<p>If a switch label matches, then one of the following applies:</p>
<ul>
<li><p>If it is the switch label for an expression, then this expression is evaluated. If the result of evaluation is a value, then the <code>switch</code> expression completes normally with the same value.</p></li>
<li><p>If it is the switch label for a block, then the block is executed.</p></li>
<li><p>If it is the switch label for a <code>throw</code> statement, then the <code>throw</code> statement is executed.</p></li>
<li><p>Otherwise, all the statements in the switch block after the matching switch label are executed in order.</p></li>
</ul>
<p>If execution of any statement or expression completes abruptly, it is handled as follows:</p>
<ul>
<li><p>If execution of an expression completes abruptly for a reason, then the <code>switch</code> expression completes abruptly for the same reason.</p></li>
<li><p>If execution of a statement completes abruptly for the reason of a <code>yield</code> with value <em>V</em>, then the <code>switch</code> expression completes normally and the value of the <code>switch</code> expression is <em>V</em>.</p></li>
<li><p>If execution of a statement completes abruptly for any reason other than a <code>yield</code> with value, then the <code>switch</code> expression completes abruptly for the same reason.</p></li>
</ul></li>
</ol>
</div>
<h3 id="jep354-15.29"><del>15.28</del> <strong>15.29</strong> Constant Expressions</h3>
<dl>
<dt><em>ConstantExpression:</em></dt>
<dd><em>Expression</em>
</dd>
</dl>
<p>A <em>constant expression</em> is an expression denoting a value of primitive type or a <code>String</code> that does not complete abruptly and is composed using only the following:</p>
<ul>
<li><p>Literals of primitive type and literals of type <code>String</code> (<a href="../../se11/html/jls-3.html#jls-3.10.1">3.10.1</a>, <a href="../../se11/html/jls-3.html#jls-3.10.2">3.10.2</a>, <a href="../../se11/html/jls-3.html#jls-3.10.3">3.10.3</a>, <a href="../../se11/html/jls-3.html#jls-3.10.4">3.10.4</a>, <a href="../../se11/html/jls-3.html#jls-3.10.5">3.10.5</a>)</p></li>
<li><p>Casts to primitive types and casts to type <code>String</code> (<a href="../../se11/html/jls-15.html#jls-15.16">15.16</a>)</p></li>
<li><p>The unary operators <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code> (but not <code>++</code> or <code>--</code>) (<a href="switch-expressions.html#jep354-15.15.3">15.15.3</a>, <a href="switch-expressions.html#jep354-15.15.4">15.15.4</a>, <a href="switch-expressions.html#jep354-15.15.5">15.15.5</a>, <a href="switch-expressions.html#jep354-15.15.6">15.15.6</a>)</p></li>
<li><p>The multiplicative operators <code>*</code>, <code>/</code>, and <code>%</code> (<a href="../../se11/html/jls-15.html#jls-15.17">15.17</a>)</p></li>
<li><p>The additive operators <code>+</code> and <code>-</code> (<a href="../../se11/html/jls-15.html#jls-15.18">15.18</a>)</p></li>
<li><p>The shift operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> (<a href="../../se11/html/jls-15.html#jls-15.19">15.19</a>)</p></li>
<li><p>The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> (but not <code>instanceof</code>) (<a href="../../se11/html/jls-15.html#jls-15.20">15.20</a>)</p></li>
<li><p>The equality operators <code>==</code> and <code>!=</code> (<a href="../../se11/html/jls-15.html#jls-15.21">15.21</a>)</p></li>
<li><p>The bitwise and logical operators <code>&amp;</code>, <code>^</code>, and <code>|</code> (<a href="../../se11/html/jls-15.html#jls-15.22">15.22</a>)</p></li>
<li><p>The conditional-and operator <code>&amp;&amp;</code> and the conditional-or operator <code>||</code> (<a href="../../se11/html/jls-15.html#jls-15.23">15.23</a>, <a href="../../se11/html/jls-15.html#jls-15.24">15.24</a>)</p></li>
<li><p>The ternary conditional operator <code>? :</code> (<a href="switch-expressions.html#jep354-15.25">15.25</a>)</p></li>
<li><p>Parenthesized expressions (<a href="../../se11/html/jls-15.html#jls-15.8.5">15.8.5</a>) whose contained expression is a constant expression.</p></li>
<li><p>Simple names (<a href="../../se11/html/jls-6.html#jls-6.5.6.1">6.5.6.1</a>) that refer to constant variables (<a href="../../se11/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p></li>
<li><p>Qualified names (<a href="../../se11/html/jls-6.html#jls-6.5.6.2">6.5.6.2</a>) of the form <em>TypeName</em> <code>.</code> <em>Identifier</em> that refer to constant variables (<a href="../../se11/html/jls-4.html#jls-4.12.4">4.12.4</a>).</p></li>
</ul>
<p>Constant expressions of type <code>String</code> are always &quot;interned&quot; so as to share unique instances, using the method <code>String.intern</code>.</p>
<p>A constant expression is always treated as FP-strict (<a href="../../se11/html/jls-15.html#jls-15.4">15.4</a>), even if it occurs in a context where a non-constant expression would not be considered to be FP-strict.</p>
<blockquote>
<p>Constant expressions are used as <code>case</code> labels in <code>switch</code> statements <strong>and <code>switch</code> expressions</strong> (<a href="switch-expressions.html#jep354-14.11">14.11</a><strong>, <a href="switch-expressions.html#jep354-15.28">15.28</a></strong>) and have a special significance in assignment contexts (<a href="../../se11/html/jls-5.html#jls-5.2">5.2</a>) and the initialization of a class or interface (<a href="../../se11/html/jls-12.html#jls-12.4.2">12.4.2</a>). They may also govern the ability of a <code>while</code>, <code>do</code>, or <code>for</code> statement to complete normally (<a href="switch-expressions.html#jep354-14.21">14.21</a>), and the type of a conditional operator <code>? :</code> with numeric operands.</p>
</blockquote>
<div class="example">
<p>Example <del>15.28-1</del> <strong>15.29-1</strong>. Constant Expressions</p>
<pre><code>true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI
&quot;The integer &quot; + Long.MAX_VALUE + &quot; is mighty big.&quot;</code></pre>
</div>
<h2 id="jep354-16">Chapter 16: Definite Assignment</h2>
<h3 id="jep354-16.1">16.1 Definite Assignment and Expressions</h3>
<h4 id="jep354-16.1.7"><strong>16.1.7 <code>switch</code> Expressions</strong></h4>
<div class="inserted">
<p>Suppose that the switch expression has result expressions <em>e1</em>, ..., <em>en</em>, all of which are boolean-valued.</p>
<p>The following rules apply only if the switch block of a <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) consists of switch labeled statement groups:</p>
<ul>
<li><p><em>V</em> is definitely assigned after a <code>switch</code> expression when true iff for every <code>yield</code> statement with an expression <em>e</em> in the switch block that may exit the <code>switch</code> expression, <em>V</em> is definitely assigned after <em>e</em> when true.</p></li>
<li><p><em>V</em> is definitely assigned after a <code>switch</code> expression when false iff for every <code>yield</code> statement with an expression <em>e</em> in the switch block that may exit the <code>switch</code> expression, <em>V</em> is definitely assigned after <em>e</em> when false.</p></li>
<li><p><em>V</em> is definitely unassigned after a <code>switch</code> expression when true iff for every <code>yield</code> statement with an expression <em>e</em> in the switch block that may exit the <code>switch</code> expression, <em>V</em> is definitely unassigned before the <code>yield</code> statement and <em>V</em> is definitely unassigned after <em>e</em> when true.</p></li>
<li><p><em>V</em> is definitely unassigned after a <code>switch</code> expression when false iff for every <code>yield</code> statement with an expression <em>e</em> in the switch block that may exit the <code>switch</code> expression, <em>V</em> is definitely unassigned before the <code>yield</code> statement and <em>V</em> is definitely unassigned after <em>e</em> when false.</p></li>
<li><p><em>V</em> is [un]assigned before the selector expression iff <em>V</em> is [un]assigned before the <code>switch</code> statement.</p></li>
<li><p><em>V</em> is [un]assigned before the first statement of the first switch labeled statement group in the switch block iff <em>V</em> is [un]assigned after the selector expression.</p></li>
<li><p><em>V</em> is [un]assigned before the first statement of any switch labeled statement group other than the first iff <em>V</em> is [un]assigned after the selector expression and <em>V</em> is [un]assigned after the preceding statement.</p></li>
</ul>
<p>The following rules apply only if the switch block of a <code>switch</code> expression consists of switch labeled rules:</p>
<ul>
<li><p><em>V</em> is definitely assigned after a <code>switch</code> expression when true iff for every switch labeled rule one of the following is true:</p>
<ul>
<li><p>It is a switch labeled expression <em>e</em> and <em>V</em> is definitely assigned after <em>e</em> when true.</p></li>
<li><p>It is a switch labeled block <em>b</em> and for every <code>yield</code> statement with expression <em>e</em> contained in <em>b</em> that may exit the <code>switch</code> expression, <em>V</em> is definitely assigned after <em>e</em> when true.</p></li>
<li><p>It is a switch labeled <code>throw</code> statement.</p></li>
</ul></li>
<li><p><em>V</em> is definitely assigned after a <code>switch</code> expression when false iff for every switch labeled rule one of the following is true:</p>
<ul>
<li><p>It is a switch labeled expression <em>e</em> and <em>V</em> is definitely assigned after <em>e</em> when false.</p></li>
<li><p>It is a switch labeled block <em>b</em> and for every <code>yield</code> statement with an expression <em>e</em> contained in <em>b</em> that may exit the <code>switch</code> expression, <em>V</em> is definitely assigned after <em>e</em> when false.</p></li>
<li><p>It is a switch labeled <code>throw</code> statement.</p></li>
</ul></li>
<li><p><em>V</em> is definitely unassigned after a <code>switch</code> expression when true iff for every switch labeled rule one of the following is true:</p>
<ul>
<li><p>It is a switch labeled expression <em>e</em> and <em>V</em> is definitely unassigned after <em>e</em> when true .</p></li>
<li><p>It is a switch labeled block <em>b</em> and for every <code>yield</code> statement with expression <em>e</em> contained in <em>b</em> that may exit the <code>switch</code> expression, <em>V</em> is definitely unassigned before the <code>yield</code> statement and <em>V</em> is definitely unassigned after <em>e</em> when true.</p></li>
<li><p>It is a switch labeled <code>throw</code> statement.</p></li>
</ul></li>
<li><p><em>V</em> is definitely unassigned after a <code>switch</code> expression when false iff for every switch labeled rule one of the following is true:</p>
<ul>
<li><p>It is a switch labeled expression <em>e</em> and <em>V</em> is definitely unassigned after <em>e</em> when false.</p></li>
<li><p>It is a switch labeled block <em>b</em> and for every <code>yield</code> statement with expression <em>e</em> contained in <em>b</em> that may exit the <code>switch</code> expression, <em>V</em> is definitely unassigned before the <code>yield</code> statement and <em>V</em> is definitely unassigned after <em>e</em> when false.</p></li>
<li><p>It is a switch labeled <code>throw</code> statement.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before any switch labeled expression or statement in the switch block iff <em>V</em> is [un]assigned after the selector expression.</p></li>
</ul>
</div>
<h4 id="jep354-16.1.8"><strong>16.1.8 <code>switch</code> Expressions</strong></h4>
<div class="inserted">
<p>Suppose that the switch expression has result expressions <code>e1</code>, ..., <code>en</code>, not all of which are boolean-valued.</p>
<!--
The following rules apply only if the switch block of a `switch` expression
([15.28]) consists of switch labeled statement groups:

-   *V* is [un]assigned after a `switch` expression iff for every
    `yield` statement with an expression *e* in the switch block that may exit the
    `switch` expression, *V* is [un]assigned after *e*.

-   *V* is [un]assigned before the selector expression iff *V* is [un]assigned
    before the `switch` statement.

-   *V* is [un]assigned before the first statement of the first switch labeled
    statement group in the switch block iff *V* is [un]assigned after the
    selector expression.

-   *V* is [un]assigned before the first statement of any switch labeled
    statement group other than the first iff *V* is [un]assigned after the
    selector expression and *V* is [un]assigned after the preceding statement.

The following rules apply only if the switch block of a `switch` expression
consists of switch labeled rules:

-   *V* is [un]assigned after a `switch` expression iff for every switch
    labeled rule one of the following is true:

    -   It is a switch labeled expression *e* and *V* is definitely assigned
        after *e*.

    -   It is a switch labeled block *b* and for every `yield` statement with
        expression *e* contained in *b* that may exit the `switch` expression,
        *V* is [un]assigned after *e*.

    -   It is a switch labeled `throw` statement with expression *e* and *V* is [un]assigned after *e*.

-   *V* is [un]assigned before any expression, block or `throw` statement of a switch labeled rule in the switch block iff *V* is [un]assigned after the selector expression.
-->
<ul>
<li><p><em>V</em> is [un]assigned after a <code>switch</code> expression (<a href="switch-expressions.html#jep354-15.28">15.28</a>) iff all of the following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned before every <code>yield</code> statement that may exit the <code>switch</code> statement.</p></li>
<li><p>For each switch labeled rule (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) in the switch block, <em>V</em> is [un]assigned after the expression, block, or throw statement of the switch labeled rule.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before the selector expression of a <code>switch</code> expression iff <em>V</em> is [un]assigned before the <code>switch</code> expression.</p></li>
<li><p><em>V</em> is [un]assigned before the expression, block, or throw statement of a switch labeled rule of a <code>switch</code> expression iff <em>V</em> is [un]assigned after the selector expression of the <code>switch</code> expression.</p></li>
<li><p><em>V</em> is [un]assigned before the first block statement of a switch labeled statement group (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) of a <code>switch</code> expression iff both of following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned after the selector expression of the <code>switch</code> statement.</p></li>
<li><p>If the switch labeled statement group is not the first in the switch block, <em>V</em> is [un]assigned after the last block statement of the preceding switch labeled statement group.</p></li>
</ul></li>
<li><em>V</em> is [un]assigned before a block statement that is not the first of a switch labeled statement group of a <code>switch</code> expression iff <em>V</em> is [un]assigned after the preceding block statement.</li>
</ul>
</div>
<h4 id="jep354-16.1.9"><del>16.1.7</del> <strong>16.1.9</strong> Other Expressions of Type <code>boolean</code></h4>
<p>Suppose that <em>e</em> is an expression of type <code>boolean</code> and is not a boolean constant expression, logical complement expression <code>!</code><em>a</em>, conditional-and expression <em>a</em> <code>&amp;&amp;</code> <em>b</em>, conditional-or expression <em>a</em> <code>||</code> <em>b</em>, or conditional expression <em>a</em> <code>?</code> <em>b</em> <code>:</code> <em>c</em>.</p>
<ul>
<li><p><em>V</em> is [un]assigned after <em>e</em> when true iff <em>V</em> is [un]assigned after <em>e</em>.</p></li>
<li><p><em>V</em> is [un]assigned after <em>e</em> when false iff <em>V</em> is [un]assigned after <em>e</em>.</p></li>
</ul>
<h4 id="jep354-16.1.10"><del>16.1.8</del> <strong>16.1.10</strong> Assignment Expressions</h4>
<p>Consider an assignment expression <em>a</em> <code>=</code> <em>b</em>, <em>a</em> <code>+=</code> <em>b</em>, <em>a</em> <code>-=</code> <em>b</em>, <em>a</em> <code>*=</code> <em>b</em>, <em>a</em> <code>/=</code> <em>b</em>, <em>a</em> <code>%=</code> <em>b</em>, <em>a</em> <code>&lt;&lt;=</code> <em>b</em>, <em>a</em> <code>&gt;&gt;=</code> <em>b</em>, <em>a</em> <code>&gt;&gt;&gt;=</code> <em>b</em>, <em>a</em> <code>&amp;=</code> <em>b</em>, <em>a</em> <code>|=</code> <em>b</em>, or <em>a</em> <code>^=</code> <em>b</em> (<a href="../../se11/html/jls-15.html#jls-15.26">15.26</a>).</p>
<ul>
<li><p><em>V</em> is definitely assigned after the assignment expression iff either:</p>
<ul>
<li><em>a</em> is <em>V</em>, or</li>
<li><em>V</em> is definitely assigned after <em>b</em>.</li>
</ul></li>
<li><p><em>V</em> is definitely unassigned after the assignment expression iff <em>a</em> is not <em>V</em> and <em>V</em> is definitely unassigned after <em>b</em>.</p></li>
<li><p><em>V</em> is [un]assigned before <em>a</em> iff <em>V</em> is [un]assigned before the assignment expression.</p></li>
<li><p><em>V</em> is [un]assigned before <em>b</em> iff <em>V</em> is [un]assigned after <em>a</em>.</p></li>
</ul>
<blockquote>
<p>Note that if <em>a</em> is <em>V</em> and <em>V</em> is not definitely assigned before a compound assignment such as <em>a</em> <code>&amp;=</code> <em>b</em>, then a compile-time error will necessarily occur. The first rule for definite assignment stated above includes the disjunct &quot;<em>a</em> is <em>V</em>&quot; even for compound assignment expressions, not just simple assignments, so that <em>V</em> will be considered to have been definitely assigned at later points in the code. Including the disjunct &quot;<em>a</em> is <em>V</em>&quot; does not affect the binary decision as to whether a program is acceptable or will result in a compile-time error, but it affects how many different points in the code may be regarded as erroneous, and so in practice it can improve the quality of error reporting. A similar remark applies to the inclusion of the conjunct &quot;<em>a</em> is not <em>V</em>&quot; in the first rule for definite unassignment stated above.</p>
</blockquote>
<h4 id="jep354-16.1.11"><del>16.1.9</del> <strong>16.1.11</strong> Operators <code>++</code> and <code>--</code></h4>
<ul>
<li><p><em>V</em> is definitely assigned after <code>++</code><em>a</em> (<a href="switch-expressions.html#jep354-15.15.1">15.15.1</a>), <code>--</code><em>a</em> (<a href="switch-expressions.html#jep354-15.15.2">15.15.2</a>), <em>a</em><code>++</code> (<a href="../../se11/html/jls-15.html#jls-15.14.2">15.14.2</a>), or <em>a</em><code>--</code> (<a href="../../se11/html/jls-15.html#jls-15.14.3">15.14.3</a>) iff either <em>a</em> is <em>V</em> or <em>V</em> is definitely assigned after the operand expression.</p></li>
<li><p><em>V</em> is definitely unassigned after <code>++</code><em>a</em>, <code>--</code><em>a</em>, <em>a</em><code>++</code>, or <em>a</em><code>--</code> iff <em>a</em> is not <em>V</em> and <em>V</em> is definitely unassigned after the operand expression.</p></li>
<li><p><em>V</em> is [un]assigned before <em>a</em> iff <em>V</em> is [un]assigned before <code>++</code><em>a</em>, <code>--</code><em>a</em>, <em>a</em><code>++</code>, or <em>a</em><code>--</code>.</p></li>
</ul>
<h4 id="jep354-16.1.12"><del>16.1.10</del> <strong>16.1.12</strong> Other Expressions</h4>
<p>If an expression is not a boolean constant expression, and is not a preincrement expression <code>++</code><em>a</em>, predecrement expression <code>--</code><em>a</em>, postincrement expression <em>a</em><code>++</code>, postdecrement expression <em>a</em><code>--</code>, logical complement expression <code>!</code><em>a</em>, conditional-and expression <em>a</em> <code>&amp;&amp;</code> <em>b</em>, conditional-or expression <em>a</em> <code>||</code> <em>b</em>, conditional expression <em>a</em> <code>?</code> <em>b</em> <code>:</code> <em>c</em>, assignment expression, or lambda expression, then the following rules apply:</p>
<ul>
<li><p>If the expression has no subexpressions, <em>V</em> is [un]assigned after the expression iff <em>V</em> is [un]assigned before the expression.</p>
<blockquote>
<p>This case applies to literals, names, <code>this</code> (both qualified and unqualified), unqualified class instance creation expressions with no arguments, array creation expressions with initializers that contain no expressions, superclass field access expressions, unqualified and type-qualified method invocation expressions with no arguments, superclass method invocation expressions with no arguments, and superclass and type-qualified method reference expressions.</p>
</blockquote></li>
<li><p>If the expression has subexpressions, <em>V</em> is [un]assigned after the expression iff <em>V</em> is [un]assigned after its rightmost immediate subexpression.</p></li>
</ul>
<blockquote>
<p>There is a piece of subtle reasoning behind the assertion that a variable <em>V</em> can be known to be definitely unassigned after a method invocation expression. Taken by itself, at face value and without qualification, such an assertion is not always true, because an invoked method can perform assignments. But it must be remembered that, for the purposes of the Java programming language, the concept of definite unassignment is applied only to blank <code>final</code> variables. If <em>V</em> is a blank <code>final</code> local variable, then only the method to which its declaration belongs can perform assignments to <em>V</em>. If <em>V</em> is a blank <code>final</code> field, then only a constructor or an initializer for the class containing the declaration for <em>V</em> can perform assignments to <em>V</em>; no method can perform assignments to <em>V</em>. Finally, explicit constructor invocations (<a href="../../se11/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>) are handled specially (<a href="../../se11/html/jls-16.html#jls-16.9">16.9</a>); although they are syntactically similar to expression statements containing method invocations, they are not expression statements and therefore the rules of this section do not apply to explicit constructor invocations.</p>
</blockquote>
<p>If an expression is a lambda expression, then the following rules apply:</p>
<ul>
<li><p><em>V</em> is [un]assigned after the expression iff <em>V</em> is [un]assigned before the expression.</p></li>
<li><p><em>V</em> is definitely assigned before the expression or block that is the lambda body (<a href="../../se11/html/jls-15.html#jls-15.27.2">15.27.2</a>) iff <em>V</em> is definitely assigned before the lambda expression.</p>
<blockquote>
<p>No rule allows <em>V</em> to be definitely unassigned before a lambda body. This is by design: a variable that was definitely unassigned before the lambda body may end up being assigned to later on, so we cannot conclude that the variable will be unassigned when the body is executed.</p>
</blockquote></li>
</ul>
<p>For any immediate subexpression <em>y</em> of an expression <em>x</em>, where <em>x</em> is not a lambda expression, <em>V</em> is [un]assigned before <em>y</em> iff one of the following is true:</p>
<ul>
<li><p><em>y</em> is the leftmost immediate subexpression of <em>x</em> and <em>V</em> is [un]assigned before <em>x</em>.</p></li>
<li><p><em>y</em> is the right-hand operand of a binary operator and <em>V</em> is [un]assigned after the left-hand operand.</p></li>
<li><p><em>x</em> is an array access, <em>y</em> is the subexpression within the brackets, and <em>V</em> is [un]assigned after the subexpression before the brackets.</p></li>
<li><p><em>x</em> is a primary method invocation expression, <em>y</em> is the first argument expression in the method invocation expression, and <em>V</em> is [un]assigned after the primary expression that computes the target object.</p></li>
<li><p><em>x</em> is a method invocation expression or a class instance creation expression; <em>y</em> is an argument expression, but not the first; and <em>V</em> is [un]assigned after the argument expression to the left of <em>y</em>.</p></li>
<li><p><em>x</em> is a qualified class instance creation expression, <em>y</em> is the first argument expression in the class instance creation expression, and <em>V</em> is [un]assigned after the primary expression that computes the qualifying object.</p></li>
<li><p><em>x</em> is an array creation expression; <em>y</em> is a dimension expression, but not the first; and <em>V</em> is [un]assigned after the dimension expression to the left of <em>y</em>.</p></li>
<li><p><em>x</em> is an array creation expression initialized via an array initializer; <em>y</em> is the array initializer in <em>x</em>; and <em>V</em> is [un]assigned after the dimension expression to the left of <em>y</em>.</p></li>
</ul>
<h3 id="jep354-16.2">16.2 Definite Assignment and Statements</h3>
<h4 id="jep354-16.2.9">16.2.9 <code>switch</code> Statements</h4>
<div class="deleted">
<ul>
<li><p><em>V</em> is [un]assigned after a <code>switch</code> statement (<a href="switch-expressions.html#jep354-14.11">14.11</a>) iff all of the following are true:</p>
<ul>
<li><p>Either there is a <code>default</code> label in the switch block or <em>V</em> is [un]assigned after the switch expression.</p></li>
<li><p>Either there are no switch labels in the switch block that do not begin a block-statement-group (that is, there are no switch labels immediately before the &quot;<code>}</code>&quot; that ends the switch block) or <em>V</em> is [un]assigned after the switch expression.</p></li>
<li><p>Either the switch block contains no block-statement-groups or <em>V</em> is [un]assigned after the last block-statement of the last block-statement-group.</p></li>
<li><p><em>V</em> is [un]assigned before every <code>break</code> statement that may exit the <code>switch</code> statement.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before the switch expression iff <em>V</em> is [un]assigned before the <code>switch</code> statement.</p></li>
</ul>
<p>If a switch block contains at least one block-statement-group, then the following rules also apply:</p>
<ul>
<li><p><em>V</em> is [un]assigned before the first block-statement of the first block-statement-group in the switch block iff <em>V</em> is [un]assigned after the switch expression.</p></li>
<li><em>V</em> is [un]assigned before the first block-statement of any block-statement-group other than the first iff <em>V</em> is [un]assigned after the switch expression and <em>V</em> is [un]assigned after the preceding block-statement.</li>
</ul>
</div>
<div class="inserted">
<ul>
<li><p><em>V</em> is [un]assigned after a <code>switch</code> statement (<a href="switch-expressions.html#jep354-14.11">14.11</a>) iff all of the following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned before every <code>break</code> statement that may exit the <code>switch</code> statement.</p></li>
<li><p>For each switch labeled rule (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) in the switch block, <em>V</em> is [un]assigned after the expression, block, or throw statement of the switch labeled rule.</p></li>
<li><p>If there is a switch labeled statement group (<a href="switch-expressions.html#jep354-14.11.1">14.11.1</a>) in the switch block, then <em>V</em> is [un]assigned after the last block statement of the last switch labeled statement group.</p></li>
<li><p>If there is no <code>default</code> label in the switch block, or if the switch block ends with a switch label followed by <code>}</code>, then <em>V</em> is [un]assigned after the selector expression.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before the selector expression of a <code>switch</code> statement iff <em>V</em> is [un]assigned before the <code>switch</code> statement.</p></li>
<li><p><em>V</em> is [un]assigned before the expression, block, or throw statement of a switch labeled rule of a <code>switch</code> statement iff <em>V</em> is [un]assigned after the selector expression of the <code>switch</code> statement.</p></li>
<li><p><em>V</em> is [un]assigned before the first block statement of a switch labeled statement group of a <code>switch</code> statement iff both of the following are true:</p>
<ul>
<li><p><em>V</em> is [un]assigned after the selector expression of the <code>switch</code> statement.</p></li>
<li><p>If the switch labeled statement group is not the first in the switch block, <em>V</em> is [un]assigned after the last block statement of the preceding switch labeled statement group.</p></li>
</ul></li>
<li><p><em>V</em> is [un]assigned before a block statement that is not the first of a switch labeled statement group of a <code>switch</code> statement iff <em>V</em> is [un]assigned after the preceding block statement.</p></li>
</ul>
</div>
<!--
**The following rule applies to all `switch` statements, regardless of the form of the switch block:**

- ***V* is [un]assigned before the selector expression iff *V* is [un]assigned before the `switch` statement.**

**The following rules apply only if the switch block of a `switch` statement
([14.11]) is empty, consists of just switch labels, or consists of switch
labeled statement groups:**

-   *V* is [un]assigned after a `switch` statement ~~([14.11])~~ iff all of the
    following are true:

    -   Either there is a `default` label in the switch block or *V* is
        [un]assigned after the ~~switch~~ **selector** expression.

    -   Either there are no switch labels in the switch block that do not begin
        a ~~block-statement-group~~ **switch labeled statement group** (that is,
        there are no switch labels immediately before the "`}`" that ends the
        switch block) or *V* is [un]assigned after the ~~switch~~ **selector**
        expression.

    -   Either the switch block contains no ~~block-statement-groups~~ **switch
        labeled statement groups** or *V* is [un]assigned after the last
        ~~block-statement~~ **block statement** of the last
        ~~block-statement-group~~ **switch labeled statement group**.

    -   *V* is [un]assigned before every `break` statement that may exit the
        `switch` statement.

-  ~~*V* is [un]assigned before the switch expression iff *V* is
   [un]assigned before the `switch` statement.~~

If a switch block contains at least one ~~block-statement-group~~ **switch
labeled statement group**, then the following rules also apply:

-   *V* is [un]assigned before the first ~~block-statement~~ **block statement**
    of the first ~~block-statement-group~~ **switch labeled statement group** in
    the switch block iff *V* is [un]assigned after the ~~switch~~ **selector**
    expression.

-   *V* is [un]assigned before the first ~~block-statement~~ **block statement**
    of any ~~block-statement-group~~ **switch labeled statement group** other
    than the first iff *V* is [un]assigned after the ~~switch~~ **selector**
    expression and *V* is [un]assigned after the preceding ~~block-statement~~
    **block statement**.

:::inserted

The following rules apply only if the switch block of the `switch` statement
consists of switch labeled rules:

- *V* is assigned after a `switch` statement iff either of the following are true:
    
    - *V* is assigned after the selector expression, or
    
    - There is a `default` labeled rule and for every switch
      labeled rule one of the following is true:

        -  It is a switch labeled expression *e* and *V* is assigned
        after *e*.

        - It is a switch labeled block *b* and both *V* is assigned after *b* and *V* is assigned before every `break` statement contained in
        *b* that may exit the `switch` statement.

        -  It is a switch labeled `throw` statement.

- *V* is unassigned after a `switch` statement iff both of the following rules are true:
    
    - *V* is unassigned after the selector expression, and
    
    - For every switch labeled rule one of the following is true:

        - It is a switch labeled expression *e* and *V* is unassigned after *e*.

        - It is a switch labeled block *b* and both *V* is unassigned after *b* and *V* is unassigned before every `break` statement contained in
        *b* that may exit the `switch` statement.

        - It is a switch labeled `throw` statement.

- *V* is [un]assigned before any switch labeled expression, switch labeled block, or switch labeled `throw` statement iff *V* is [un]assigned after the selector expression.

:::
-->
<h4 id="jep354-16.2.13">16.2.13 <code>break</code>, <strong><code>yield</code>,</strong> <code>continue</code>, <code>return</code>, and <code>throw</code> Statements</h4>
<ul>
<li><p>By convention, we say that <em>V</em> is [un]assigned after any <code>break</code>, <strong><code>yield</code>,</strong> <code>continue</code>, <code>return</code>, or <code>throw</code> statement (<a href="switch-expressions.html#jep354-14.15">14.15</a>, <strong><a href="switch-expressions.html#jep354-14.21">14.21</a>,</strong> <a href="switch-expressions.html#jep354-14.16">14.16</a>, <a href="switch-expressions.html#jep354-14.17">14.17</a>, <a href="../../se11/html/jls-14.html#jls-14.18">14.18</a>).</p>
<blockquote>
<p>The notion that a variable is &quot;[un]assigned after&quot; a statement or expression really means &quot;is [un]assigned after the statement or expression completes normally&quot;. Because a <code>break</code>, <code>continue</code>, <code>return</code>, or <code>throw</code> statement never completes normally, it vacuously satisfies this notion.</p>
</blockquote></li>
<li><p>In a <code>return</code> statement with an expression <em>e</em><strong>,</strong> <del>or a</del> <code>throw</code> statement with an expression <em>e</em>, <strong>or a <code>yield</code> statement with an expression <em>e</em>,</strong> <em>V</em> is [un]assigned before <em>e</em> iff <em>V</em> is [un]assigned before the <code>return</code><strong>,</strong> <del>or</del> <code>throw</code> <strong>or <code>yield</code></strong> statement.</p></li>
</ul>
<h2 id="jep354-18">Chapter 18: Type Inference</h2>
<h3 id="jep354-18.2">18.2 Reduction</h3>
<h4 id="jep354-18.2.1">18.2.1 Expression Compatibility Constraints</h4>
<p>A constraint formula of the form ‹<em>Expression</em> <em>→</em> <em>T</em>› is reduced as follows:</p>
<ul>
<li><p>If <em>T</em> is a proper type, the constraint reduces to <em>true</em> if the expression is compatible in a loose invocation context with <em>T</em> (<a href="../../se11/html/jls-5.html#jls-5.3">5.3</a>), and <em>false</em> otherwise.</p></li>
<li><p>Otherwise, if the expression is a standalone expression (<a href="switch-expressions.html#jep354-15.2">15.2</a>) of type <em>S</em>, the constraint reduces to ‹<em>S</em> <em>→</em> <em>T</em>›.</p></li>
<li><p>Otherwise, the expression is a poly expression (<a href="switch-expressions.html#jep354-15.2">15.2</a>). The result depends on the form of the expression:</p>
<ul>
<li><p>If the expression is a parenthesized expression of the form <code>(</code> <em>Expression</em>' <code>)</code>, the constraint reduces to ‹<em>Expression</em>' <em>→</em> <em>T</em>›.</p></li>
<li><p>If the expression is a class instance creation expression or a method invocation expression, the constraint reduces to the bound set <em>B<sub>3</sub></em> which would be used to determine the expression's compatibility with target type <em>T</em>, as defined in <a href="switch-expressions.html#jep354-18.5.2.1">18.5.2.1</a>. (For a class instance creation expression, the corresponding &quot;method&quot; used for inference is defined in <a href="../../se11/html/jls-15.html#jls-15.9.3">15.9.3</a>.)</p>
<p>This bound set may contain new inference variables, as well as dependencies between these new variables and the inference variables in <em>T</em>.</p></li>
<li><p>If the expression is a conditional expression of the form <em>e<sub>1</sub></em> <code>?</code> <em>e<sub>2</sub></em> <code>:</code> <em>e<sub>3</sub></em>, the constraint reduces to two constraint formulas, ‹<em>e<sub>2</sub></em> <em>→</em> <em>T</em>› and ‹<em>e<sub>3</sub></em> <em>→</em> <em>T</em>›.</p></li>
<li><p><strong>If the expression is a <code>switch</code> expression with a set of result expressions <em>e<sub>1</sub></em>, ..., <em>e<sub>n</sub></em>, the constraint reduces to <em>n</em> constraint formulas, ‹<em>e<sub>1</sub></em> <em>→</em> <em>T</em>›, ..., ‹<em>e<sub>n</sub></em> <em>→</em> <em>T</em>›.</strong></p></li>
<li><p>If the expression is a lambda expression or a method reference expression, the result is specified below.</p></li>
</ul></li>
</ul>
<blockquote>
<p>By treating nested generic method invocations as poly expressions, we improve the behavior of inference for nested invocations. For example, the following is illegal in Java SE 7 but legal in Java SE 8:</p>
</blockquote>
<blockquote>
<pre><code>ProcessBuilder b = new ProcessBuilder(Collections.emptyList());
  // ProcessBuilder&#39;s constructor expects a List&lt;String&gt;</code></pre>
</blockquote>
<blockquote>
<p>When <em>both</em> the outer and the nested invocation require inference, the problem is more difficult. For example:</p>
</blockquote>
<blockquote>
<pre><code>List&lt;String&gt; ls = new ArrayList&lt;&gt;(Collections.emptyList());</code></pre>
</blockquote>
<blockquote>
<p>Our approach is to &quot;lift&quot; the bounds inferred for the nested invocation (simply { <em>α</em> <code>&lt;:</code> <code>Object</code> } in the case of <code>emptyList</code>) into the outer inference process (in this case, trying to infer <em>β</em> where the constructor is for type <code>ArrayList&lt;</code><em>β</em><code>&gt;</code>). We also infer dependencies between the nested inference variables and the outer inference variables (the constraint ‹<code>List&lt;</code><em>α</em><code>&gt;</code> <em>→</em> <code>Collection&lt;</code><em>β</em><code>&gt;</code>› would reduce to the dependency <em>α</em> = <em>β</em>). In this way, resolution of the inference variables in the nested invocation can wait until additional information can be inferred from the outer invocation (based on the assignment target, <em>β</em> = <code>String</code>).</p>
</blockquote>
<p>...</p>
<h3 id="jep354-18.5">18.5 Uses of Inference</h3>
<h4 id="jep354-18.5.2">18.5.2 Invocation Type Inference</h4>
<h5 id="jep354-18.5.2.2">18.5.2.2 Additional Argument Constraints</h5>
<p>The invocation type for the chosen method is determined after considering additional constraints that may be implied by the argument expressions of the method invocation expression, as follows:</p>
<ul>
<li><p>If the method invocation expression is a poly expression, let <em>B<sub>3</sub></em> be the bound set generated in <a href="switch-expressions.html#jep354-18.5.2.1">18.5.2.1</a> to demonstrate compatibility with the actual target type of the method invocation.</p>
<p>If the method invocation expression is not a poly expression, let <em>B<sub>3</sub></em> be the same as the bound set produced by reduction in order to demonstrate that <em>m</em> is applicable in <a href="../../se11/html/jls-18.html#jls-18.5.1">18.5.1</a>.</p>
<p>(While it was necessary in <a href="../../se11/html/jls-18.html#jls-18.5.1">18.5.1</a> and <a href="switch-expressions.html#jep354-18.5.2.1">18.5.2.1</a> to demonstrate that the inference variables in the bound set could be resolved, the instantiations produced by these resolution steps are <em>not</em> considered part of <em>B<sub>3</sub></em>.)</p></li>
<li><p>A set of constraint formulas, <em>C</em>, is generated as follows.</p>
<p>Let <em>e<sub>1</sub></em>, ..., <em>e<sub>k</sub></em> be the actual argument expressions of the method invocation expression.</p>
<p>If <em>m</em> is applicable by strict or loose invocation, let <em>F<sub>1</sub></em>, ..., <em>F<sub>k</sub></em> be the formal parameter types of <em>m</em>; if <em>m</em> is applicable by variable arity invocation, let <em>F<sub>1</sub></em>, ..., <em>F<sub>k</sub></em> the first <em>k</em> variable arity parameter types of <em>m</em> (<a href="../../se11/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>).</p>
<p>Let <em>θ</em> be the substitution <code>[</code><em>P<sub>1</sub></em>:=<em>α<sub>1</sub></em>, ..., <em>P<sub>p</sub></em>:=<em>α<sub>p</sub></em><code>]</code> defined in <a href="../../se11/html/jls-18.html#jls-18.5.1">18.5.1</a> to replace the type parameters of <em>m</em> with inference variables.</p>
<p>Then, for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>k</em>):</p>
<ul>
<li><p>If <em>e<sub>i</sub></em> is not pertinent to applicability, <em>C</em> contains ‹<em>e<sub>i</sub></em> <em>→</em> <em>F<sub>i</sub></em> <em>θ</em>›.</p></li>
<li><p>Additional constraints may be included, depending on the form of <em>e<sub>i</sub></em>:</p>
<ul>
<li><p>If <em>e<sub>i</sub></em> is a <em>LambdaExpression</em>, <em>C</em> contains ‹<em>LambdaExpression</em> <em>→</em><sub><em>throws</em></sub> <em>F<sub>i</sub></em> <em>θ</em>›, and the lambda body is searched for additional constraints:</p>
<ul>
<li><p>For a block lambda body, the search is applied recursively to each result expression.</p></li>
<li><p>For a poly class instance creation expression or a poly method invocation expression , <em>C</em> contains all the constraint formulas that would appear in the set <em>C</em> generated by <a href="switch-expressions.html#jep354-18.5.2">18.5.2</a> when inferring the poly expression's invocation type.</p></li>
<li><p>For a parenthesized expression, the search is applied recursively to the contained expression.</p></li>
<li><p>For a conditional expression, the search is applied recursively to the second and third operands.</p></li>
<li><p><strong>For a <code>switch</code> expression, the search is applied recursively to each of its result expressions.</strong></p></li>
<li><p>For a lambda expression, the search is applied recursively to the lambda body.</p></li>
</ul></li>
<li><p>If <em>e<sub>i</sub></em> is a <em>MethodReference</em>, <em>C</em> contains ‹<em>MethodReference</em> <em>→</em><sub><em>throws</em></sub> <em>F<sub>i</sub></em> <em>θ</em>›.</p></li>
<li><p>If <em>e<sub>i</sub></em> is a poly class instance creation expression or a poly method invocation expression, <em>C</em> contains all the constraint formulas that would appear in the set <em>C</em> generated by <a href="switch-expressions.html#jep354-18.5.2">18.5.2</a> when inferring the poly expression's invocation type.</p></li>
<li><p>If <em>e<sub>i</sub></em> is a parenthesized expression, these rules are applied recursively to the contained expression.</p></li>
<li><p>If <em>e<sub>i</sub></em> is a conditional expression, these rules are applied recursively to the second and third operands.</p></li>
<li><p><strong>If <em>e<sub>i</sub></em> is a <code>switch</code> expression, these rules are applied recursively to each of its result expressions.</strong></p></li>
</ul></li>
</ul></li>
<li><p>While <em>C</em> is not empty, the following process is repeated, starting with the bound set <em>B<sub>3</sub></em> and accumulating new bounds into a &quot;current&quot; bound set, ultimately producing a new bound set, <em>B<sub>4</sub></em>:</p>
<ol type="1">
<li><p>A subset of constraints is selected in <em>C</em>, satisfying the property that, for each constraint, no input variable can influence an output variable of another constraint in <em>C</em>. The terms <em>input variable</em> and <em>output variable</em> are defined below. An inference variable <em>α</em> <em>can influence</em> an inference variable <em>β</em> if <em>α</em> depends on the resolution of <em>β</em> (<a href="../../se11/html/jls-18.html#jls-18.4">18.4</a>), or vice versa; or if there exists a third inference variable <em>γ</em> such that <em>α</em> can influence <em>γ</em> and <em>γ</em> can influence <em>β</em>.</p>
<p>If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints. In this case, the constraints in <em>C</em> that participate in a dependency cycle (or cycles) and do not depend on any constraints outside of the cycle (or cycles) are considered. A single constraint is selected from these considered constraints, as follows:</p>
<ul>
<li><p>If any of the considered constraints have the form ‹<em>Expression</em> <em>→</em> <em>T</em>›, then the selected constraint is the considered constraint of this form that contains the expression to the left (<a href="../../se11/html/jls-3.html#jls-3.5">3.5</a>) of the expression of every other considered constraint of this form.</p></li>
<li><p>If no considered constraint has the form ‹<em>Expression</em> <em>→</em> <em>T</em>›, then the selected constraint is the considered constraint that contains the expression to the left of the expression of every other considered constraint.</p></li>
</ul></li>
<li><p>The selected constraint(s) are removed from <em>C</em>.</p></li>
<li><p>The input variables <em>α<sub>1</sub></em>, ..., <em>α<sub>m</sub></em> of all the selected constraint(s) are resolved.</p></li>
<li><p>Where <em>T<sub>1</sub></em>, ..., <em>T<sub>m</sub></em> are the instantiations of <em>α<sub>1</sub></em>, ..., <em>α<sub>m</sub></em>, the substitution <code>[</code><em>α<sub>1</sub></em>:=<em>T<sub>1</sub></em>, ..., <em>α<sub>m</sub></em>:=<em>T<sub>m</sub></em><code>]</code> is applied to every constraint.</p></li>
<li><p>The constraint(s) resulting from substitution are reduced and incorporated with the current bound set.</p></li>
</ol></li>
<li><p>Finally, if <em>B<sub>4</sub></em> does not contain the bound <em>false</em>, the inference variables in <em>B<sub>4</sub></em> are resolved.</p>
<p>If resolution succeeds with instantiations <em>T<sub>1</sub></em>, ..., <em>T<sub>p</sub></em> for inference variables <em>α<sub>1</sub></em>, ..., <em>α<sub>p</sub></em>, let <em>θ</em>' be the substitution <code>[</code><em>P<sub>1</sub></em>:=<em>T<sub>1</sub></em>, ..., <em>P<sub>p</sub></em>:=<em>T<sub>p</sub></em><code>]</code>. Then:</p>
<ul>
<li><p>If unchecked conversion was necessary for the method to be applicable during constraint set reduction in <a href="../../se11/html/jls-18.html#jls-18.5.1">18.5.1</a>, then the parameter types of the invocation type of <em>m</em> are obtained by applying <em>θ</em>' to the parameter types of <em>m</em>'s type, and the return type and thrown types of the invocation type of <em>m</em> are given by the erasure of the return type and thrown types of <em>m</em>'s type.</p></li>
<li><p>If unchecked conversion was not necessary for the method to be applicable, then the invocation type of <em>m</em> is obtained by applying <em>θ</em>' to the type of <em>m</em>.</p></li>
</ul>
<p>If <em>B<sub>4</sub></em> contains the bound <em>false</em>, or if resolution fails, then a compile-time error occurs.</p></li>
</ul>
<p>The process of reducing additional argument constraints may require carefully ordering constraint formulas of the forms ‹<em>Expression</em> <em>→</em> <em>T</em>›, ‹<em>LambdaExpression</em> <em>→</em><sub><em>throws</em></sub> <em>T</em>›, and ‹<em>MethodReference</em> <em>→</em><sub><em>throws</em></sub> <em>T</em>›. To facilitate this ordering, the <em>input variables</em> of these constraints are defined as follows:</p>
<ul>
<li><p>For ‹<em>LambdaExpression</em> <em>→</em> <em>T</em>›:</p>
<ul>
<li><p>If <em>T</em> is an inference variable, it is the (only) input variable.</p></li>
<li><p>If <em>T</em> is a functional interface type, and a function type can be derived from <em>T</em> (<a href="../../se11/html/jls-15.html#jls-15.27.3">15.27.3</a>), then the input variables include (i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and (ii) if the function type's return type, <em>R</em>, is not <code>void</code>, then for each result expression <em>e</em> in the lambda body (or for the body itself if it is an expression), the input variables of ‹<em>e</em> <em>→</em> <em>R</em>›.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>LambdaExpression</em> <em>→</em><sub><em>throws</em></sub> <em>T</em>›:</p>
<ul>
<li><p>If <em>T</em> is an inference variable, it is the (only) input variable.</p></li>
<li><p>If <em>T</em> is a functional interface type, and a function type can be derived, as described in <a href="../../se11/html/jls-15.html#jls-15.27.3">15.27.3</a>, the input variables include (i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and (ii) the inference variables mentioned by the function type's return type.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>MethodReference</em> <em>→</em> <em>T</em>›:</p>
<ul>
<li><p>If <em>T</em> is an inference variable, it is the (only) input variable.</p></li>
<li><p>If <em>T</em> is a functional interface type with a function type, and if the method reference is inexact (<a href="../../se11/html/jls-15.html#jls-15.13.1">15.13.1</a>), the input variables are the inference variables mentioned by the function type's parameter types.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>MethodReference</em> <em>→</em><sub><em>throws</em></sub> <em>T</em>›:</p>
<ul>
<li><p>If <em>T</em> is an inference variable, it is the (only) input variable.</p></li>
<li><p>If <em>T</em> is a functional interface type with a function type, and if the method reference is inexact (<a href="../../se11/html/jls-15.html#jls-15.13.1">15.13.1</a>), the input variables are the inference variables mentioned by the function type's parameter types and the function type's return type.</p></li>
<li><p>Otherwise, there are no input variables.</p></li>
</ul></li>
<li><p>For ‹<em>Expression</em> <em>→</em> <em>T</em>›, if <em>Expression</em> is a parenthesized expression:</p>
<p>Where the contained expression of <em>Expression</em> is <em>Expression</em>', the input variables are the input variables of ‹<em>Expression</em>' <em>→</em> <em>T</em>›.</p></li>
<li><p>For ‹<em>ConditionalExpression</em> <em>→</em> <em>T</em>›:</p>
<p>Where the conditional expression has the form <em>e<sub>1</sub></em> <code>?</code> <em>e<sub>2</sub></em> <code>:</code> <em>e<sub>3</sub></em>, the input variables are the input variables of ‹<em>e<sub>2</sub></em> <em>→</em> <em>T</em>› and ‹<em>e<sub>3</sub></em> <em>→</em> <em>T</em>›.</p></li>
<li><p><strong>For ‹<em>SwitchExpression</em> <em>→</em> <em>T</em>›:</strong></p>
<p><strong>Where the switch expression has result expression <em>e<sub>1</sub></em>, ..., <em>e<sub>n</sub></em>, the input variables are, for all <em>i</em>, <em>1 ≤ i ≤ n</em>, the input variables of ‹<em>e<sub>i</sub></em> <em>→</em> <em>T</em>›.</strong></p></li>
<li><p>For all other constraint formulas, there are no input variables.</p></li>
</ul>
<p>The <em>output variables</em> of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, <em>T</em>, that are not input variables.</p>
<h4 id="jep354-18.5.4">18.5.4 More Specific Method Inference</h4>
<p>When testing that one applicable method is <em>more specific</em> than another (<a href="switch-expressions.html#jep354-15.12.2.5">15.12.2.5</a>), where the second method is generic, it is necessary to test whether some instantiation of the second method's type parameters can be inferred to make the first method more specific than the second.</p>
<p>Let <em>m<sub>1</sub></em> be the first method and <em>m<sub>2</sub></em> be the second method. Where <em>m<sub>2</sub></em> has type parameters <em>P<sub>1</sub></em>, ..., <em>P<sub>p</sub></em>, let <em>α<sub>1</sub></em>, ..., <em>α<sub>p</sub></em> be inference variables, and let <em>θ</em> be the substitution <code>[</code><em>P<sub>1</sub></em>:=<em>α<sub>1</sub></em>, ..., <em>P<sub>p</sub></em>:=<em>α<sub>p</sub></em><code>]</code>.</p>
<p>Let <em>e<sub>1</sub></em>, ..., <em>e<sub>k</sub></em> be the argument expressions of the corresponding invocation. Then:</p>
<ul>
<li><p>If <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by strict or loose invocation (<a href="../../se11/html/jls-15.html#jls-15.12.2.2">15.12.2.2</a>, <a href="../../se11/html/jls-15.html#jls-15.12.2.3">15.12.2.3</a>), then let <em>S<sub>1</sub></em>, ..., <em>S<sub>k</sub></em> be the formal parameter types of <em>m<sub>1</sub></em>, and let <em>T<sub>1</sub></em>, ..., <em>T<sub>k</sub></em> be the result of <em>θ</em> applied to the formal parameter types of <em>m<sub>2</sub></em>.</p></li>
<li><p>If <em>m<sub>1</sub></em> and <em>m<sub>2</sub></em> are applicable by variable arity invocation (<a href="../../se11/html/jls-15.html#jls-15.12.2.4">15.12.2.4</a>), then let <em>S<sub>1</sub></em>, ..., <em>S<sub>k</sub></em> be the first <em>k</em> variable arity parameter types of <em>m<sub>1</sub></em>, and let <em>T<sub>1</sub></em>, ..., <em>T<sub>k</sub></em> be the result of <em>θ</em> applied to the first <em>k</em> variable arity parameter types of <em>m<sub>2</sub></em>.</p></li>
</ul>
<blockquote>
<p>Note that no substitution is applied to <em>S<sub>1</sub></em>, ..., <em>S<sub>k</sub></em>; even if <em>m<sub>1</sub></em> is generic, the type parameters of <em>m<sub>1</sub></em> are treated as type variables, not inference variables.</p>
</blockquote>
<p>The process to determine if <em>m<sub>1</sub></em> is more specific than <em>m<sub>2</sub></em> is as follows:</p>
<ul>
<li><p>First, an initial bound set, <em>B</em>, is generated from the declared bounds of <em>P<sub>1</sub></em>, ..., <em>P<sub>p</sub></em>, as specified in <a href="../../se11/html/jls-18.html#jls-18.1.3">18.1.3</a>.</p></li>
<li><p>Second, for all <em>i</em> (1 <em>≤</em> <em>i</em> <em>≤</em> <em>k</em>), a set of constraint formulas or bounds is generated.</p>
<p>If <em>T<sub>i</sub></em> is a proper type, the result is <em>true</em> if <em>S<sub>i</sub></em> is more specific than <em>T<sub>i</sub></em> for <em>e<sub>i</sub></em> (<a href="switch-expressions.html#jep354-15.12.2.5">15.12.2.5</a>), and <em>false</em> otherwise. (Note that <em>S<sub>i</sub></em> is always a proper type.)</p>
<p>Otherwise, if <em>S<sub>i</sub></em> and <em>T<sub>i</sub></em> are not both functional interface types, the constraint formula ‹<em>S<sub>i</sub></em> <code>&lt;:</code> <em>T<sub>i</sub></em>› is generated.</p>
<p>Otherwise, if the interface of <em>S<sub>i</sub></em> is a superinterface or a subinterface of the interface of <em>T<sub>i</sub></em> (or, where <em>S<sub>i</sub></em> or <em>T<sub>i</sub></em> is an intersection type, some interface of <em>S<sub>i</sub></em> is a superinterface or a subinterface of some interface of <em>T<sub>i</sub></em>), the constraint formula ‹<em>S<sub>i</sub></em> <code>&lt;:</code> <em>T<sub>i</sub></em>› is generated.</p>
<p>Otherwise, let <em>MT<sub>S</sub></em> be the function type of the capture of <em>S<sub>i</sub></em>, let <em>MT<sub>S</sub></em>' be the function type of <em>S<sub>i</sub></em> (without capture), and let <em>MT<sub>T</sub></em> be the function type of <em>T<sub>i</sub></em>. If <em>MT<sub>S</sub></em> and <em>MT<sub>T</sub></em> have a different number of formal parameters or type parameters, or if <em>MT<sub>S</sub></em> and <em>MT<sub>S</sub></em>' do not have the same type parameters (<a href="../../se11/html/jls-8.html#jls-8.4.4">8.4.4</a>), the result is <em>false</em>. Otherwise, the following constraint formulas or bounds are generated from the type parameters, formal parameter types, and return types of <em>MT<sub>S</sub></em> and <em>MT<sub>T</sub></em>:</p>
<ul>
<li><p>Let <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em> be the type parameters of <em>MT<sub>S</sub></em>, and let <em>B<sub>1</sub></em>, ..., <em>B<sub>n</sub></em> be the type parameters of <em>MT<sub>T</sub></em>.</p>
<p>Let <em>θ</em>' be the substitution <code>[</code><em>B<sub>1</sub></em>:=<em>A<sub>1</sub></em>, ..., <em>B<sub>n</sub></em>:=<em>A<sub>n</sub></em><code>]</code>. Then, for all <em>j</em> (1 <em>≤</em> <em>j</em> <em>≤</em> <em>n</em>):</p>
<ul>
<li><p>If the bound of <em>A<sub>j</sub></em> mentions one of <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em>, and the bound of <em>B<sub>j</sub></em> is a not proper type, <em>false</em>.</p></li>
<li><p>Otherwise, where <em>X</em> is the bound of <em>A<sub>j</sub></em> and <em>Y</em> is the bound of <em>B<sub>j</sub></em>, ‹<em>X</em> = <em>Y</em> <em>θ</em>'›.</p></li>
</ul>
<blockquote>
<p>If the bound <em>A<sub>j</sub></em> mentions one of <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em>, and the bound of <em>B<sub>j</sub></em> is not a proper type, then producing an equality constraint would raise the possibility of an inference variable being bounded by an out-of-scope type variable. Since instantiating an inference variable with an out-of-scope type variable is nonsensical, we prefer to avoid the situation by giving up immediately whenever the possibility arises. This simplification is not completeness-preserving. (The same comment applies to the treatment of formal parameter types and return types below.)</p>
</blockquote></li>
<li><p>Let <em>U<sub>1</sub></em>, ..., <em>U<sub>k</sub></em> be the formal parameter types of <em>MT<sub>S</sub></em>, and let <em>V<sub>1</sub></em>, ..., <em>V<sub>k</sub></em> be the formal parameter types of <em>MT<sub>T</sub></em>. Then, for all <em>j</em> (1 <em>≤</em> <em>j</em> <em>≤</em> <em>k</em>):</p>
<ul>
<li><p>If <em>U<sub>j</sub></em> mentions one of <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em>, and <em>V<sub>j</sub></em> is not a proper type, <em>false</em>.</p></li>
<li><p>Otherwise, ‹<em>V<sub>j</sub></em> <em>θ</em>' <code>&lt;:</code> <em>U<sub>j</sub></em>›, and, where <em>U<sub>1</sub></em>', ..., <em>U<sub>k</sub></em>' are the formal parameter types of <em>MT<sub>S</sub></em>', and <em>A<sub>1</sub></em>', ..., <em>A<sub>n</sub></em>' are the type parameters of <em>MT<sub>S</sub></em>', ‹<em>V<sub>j</sub></em><code>[</code><em>B<sub>1</sub></em>:=<em>A<sub>1</sub></em>', ..., <em>B<sub>n</sub></em>:=<em>A<sub>n</sub></em>'<code>]</code> = <em>U<sub>j</sub></em>'›</p></li>
</ul></li>
<li><p>Let <em>R<sub>S</sub></em> be the return type of <em>MT<sub>S</sub></em>, and let <em>R<sub>T</sub></em> be the return type of <em>MT<sub>T</sub></em>. Then:</p>
<ul>
<li><p>If <em>R<sub>S</sub></em> mentions one of <em>A<sub>1</sub></em>, ..., <em>A<sub>n</sub></em>, and <em>R<sub>T</sub></em> is not a proper type, <em>false</em>.</p></li>
<li><p>Otherwise, if <em>e<sub>i</sub></em> is an explicitly typed lambda expression:</p>
<ul>
<li><p>If <em>R<sub>T</sub></em> is <code>void</code>, <em>true</em>.</p></li>
<li><p>Otherwise, if <em>R<sub>S</sub></em> and <em>R<sub>T</sub></em> are functional interface types, and <em>e<sub>i</sub></em> has at least one result expression, then for each result expression in <em>e<sub>i</sub></em>, this entire second step is repeated to infer constraints under which <em>R<sub>S</sub></em> is more specific than <em>R<sub>T</sub></em> <em>θ</em>' for the given result expression.</p></li>
<li><p>Otherwise, if <em>R<sub>S</sub></em> is a primitive type and <em>R<sub>T</sub></em> is not, and <em>e<sub>i</sub></em> has at least one result expression, and each result expression of <em>e<sub>i</sub></em> is a standalone expression (<a href="switch-expressions.html#jep354-15.2">15.2</a>) of a primitive type, <em>true</em>.</p></li>
<li><p>Otherwise, if <em>R<sub>T</sub></em> is a primitive type and <em>R<sub>S</sub></em> is not, and <em>e<sub>i</sub></em> has at least one result expression, and each result expression of <em>e<sub>i</sub></em> is either a standalone expression of a reference type or a poly expression, <em>true</em>.</p></li>
<li><p>Otherwise, ‹<em>R<sub>S</sub></em> <code>&lt;:</code> <em>R<sub>T</sub></em> <em>θ</em>'›.</p></li>
</ul></li>
<li><p>Otherwise, if <em>e<sub>i</sub></em> is an exact method reference:</p>
<ul>
<li><p>If <em>R<sub>T</sub></em> is <code>void</code>, <em>true</em>.</p></li>
<li><p>Otherwise, if <em>R<sub>S</sub></em> is a primitive type and <em>R<sub>T</sub></em> is not, and the compile-time declaration for <em>e<sub>i</sub></em> has a primitive return type, <em>true</em>.</p></li>
<li><p>Otherwise if <em>R<sub>T</sub></em> is a primitive type and <em>R<sub>S</sub></em> is not, and the compile-time declaration for <em>e<sub>i</sub></em> has a reference return type, <em>true</em>.</p></li>
<li><p>Otherwise, ‹<em>R<sub>S</sub></em> <code>&lt;:</code> <em>R<sub>T</sub></em> <em>θ</em>'›.</p></li>
</ul></li>
<li><p>Otherwise, if <em>e<sub>i</sub></em> is a parenthesized expression, these rules for constraints derived from <em>R<sub>S</sub></em> and <em>R<sub>T</sub></em> are applied recursively for the contained expression.</p></li>
<li><p>Otherwise, if <em>e<sub>i</sub></em> is a conditional expression, these rules for constraints derived from <em>R<sub>S</sub></em> and <em>R<sub>T</sub></em> are applied recursively for each of the second and third operands.</p></li>
<li><p><strong>Otherwise, if <em>e<sub>i</sub></em> is a <code>switch</code> expression, these rules for constraints derived from <em>R<sub>S</sub></em> and <em>R<sub>T</sub></em> are applied recursively for each of the result expressions.</strong></p></li>
<li><p>Otherwise, <em>false</em>.</p></li>
</ul></li>
</ul></li>
<li><p>Third, if <em>m<sub>2</sub></em> is applicable by variable arity invocation and has <em>k</em>+1 parameters, then where <em>S<sub>k+1</sub></em> is the <em>k</em>+1'th variable arity parameter type of <em>m<sub>1</sub></em> and <em>T<sub>k+1</sub></em> is the result of <em>θ</em> applied to the <em>k</em>+1'th variable arity parameter type of <em>m<sub>2</sub></em>, the constraint ‹<em>S<sub>k+1</sub></em> <code>&lt;:</code> <em>T<sub>k+1</sub></em>› is generated.</p></li>
<li><p>Fourth, the generated bounds and constraint formulas are reduced and incorporated with <em>B</em> to produce a bound set <em>B'</em>.</p>
<p>If <em>B'</em> does not contain the bound <em>false</em>, and resolution of all the inference variables in <em>B'</em> succeeds, then <em>m<sub>1</sub></em> is more specific than <em>m<sub>2</sub></em>.</p>
<p>Otherwise, <em>m<sub>1</sub></em> is not more specific than <em>m<sub>2</sub></em>.</p></li>
</ul>

</body>
</html>
